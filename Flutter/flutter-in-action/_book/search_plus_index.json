{"./":{"url":"./","title":"缘起","keywords":"","body":" 简介 本书是第一本系统介绍Flutter技术的中文书籍，它是Flutter中文社区发起的开源项目之一，旨在帮助开发者入门，系统地、循序渐进的了解Flutter。 本书官网访问量较大，由于服务器配置有限，所以某些时段访问本站可能略有延迟，如果延迟较久，读者可以直接在Github上阅读本书。 关于作者 作者wendux，高级技术专家(前端方向)、掘金知名专栏作者、Flutter中文网发起人、Flutter中文社区开源项目发起人；Github社区知名开发者，是dio、fly、dsBridge等多个知名开源项目作者。曾就职于百度、小赢科技等互联网公司，从事过PC桌面开发、移动端开发以及Web开发，负责过多次核心技术攻关，现就职于字节跳动业务团队，目前闲暇时，主要关注大前端行业发展。 广告：长期招聘前端、移动端高工，有意者请发简历到duwen32767@163.com 或加微信Demons-du，期待和你做同事！ 缘起 在全球，随着Flutter被越来越多的知名公司应用在自己的商业APP中，Flutter这门新技术也逐渐进入了移动开发者的视野，尤其是当Google在2018年IO大会上发布了第一个Preview版本后，国内刮起来一股学习Flutter的热潮。 在Flutter发布之初，当时，我在看完Flutter原理介绍后，就对它产生了浓厚的兴趣。当时笔者身边也一些人比较关注Flutter，我也被经常问到关于Flutter的一些问题，比如Flutter怎么样？和RN有什么区别？Flutter为什么要用Dart？当时也听到了一些批评的声音，比如有些人说Flutter只是重复造轮子，没啥亮点、Flutter最大的缺点就是使用了Dart语言等。在听到这些问题及论调后，我深知这是对Flutter的不了解而造成的，这和当时国内缺乏Flutter中文文档和教程有直接关系，很多人对Flutter的了解都只停留在Google的发布会介绍（有中文翻译）。 在笔者深入的了解Flutter后，深知Flutter必将是一个会改变移动开发格局的里程碑级作品，它从设计之初就对性能和开发效率兼顾，并且借鉴了React（一个Web开发框架）的响应式的UI框架设计思想等，总之，很难用一两句话说完Flutter的优点，同时我也很快成为了Flutter的路转粉。 为了更好的帮助中国开发者了解这门新技术，我在2018年初开始翻译Flutter官网文档，同年4月份上线了Flutter中文网，上线后反响很强烈，Flutter中文网也很快被传播开，百度搜索排名迅速蹿升到前三，截止目前，Flutter中文官网日PV在7万左右，每日独立访问人数近一万多。 虽然Flutter中文网给中国开发者提供了很好的第一手了解Flutter的资料，但是笔者还会经常遇到一些对Flutter技术处于围观而不愿尝试的开发者。这主要是因为当时Flutter在国内没有成功案例，再加上新技术都有学习成本，所以即使有文档，也会有一些开发者犹豫是否来学习。为了解决这部分开发者的疑虑，我就想如果能用Flutter开发一个完整的APP发布到应用商店，这样开发者就可以在犹豫的时候可以先实际感受一下Flutter应用，这样有个直观的了解后，就会容易做出判断，为此，我开发了Gitme，它是一个Github客户端，它支持了源码浏览、Issue、Label等Github的大多数功能，到目前为止，通过Gitme登录过Github账号的用户有8000多人，日活用户有1000人。更重要的是，有很多人正是用了Gitme后，才来学Flutter的。 无论是做Flutter中文网，还是写Gitme，主要目标都是帮助开发者学习Flutter，同时消除围观开发者疑虑。但当开发者们真正开始动手时，Flutter的生态问题就变得尤为突出。由于在2018年初Flutter刚起步时，很多基础的包和库都是空白，少数已有的一些库也大都是预览版（未到1.0），存在很多bug。这个状况不是一两个人花一两天能搞定的，这是需要聚整个Flutter开发者社群之力，耗费数年时间才可能有所改善。因此，在2018年4月份，我以Flutter中文网名义发起了Flutter开源计划，该计划主要是开发一些常用的包来丰富Flutter生态，帮助开发者提高开发效率。自在github建立Flutter中文开发者社区账号以来，前后开源了dio、cookieJar、flukit等多个项目，而dio在开源两周后，就迅速成为Flutter第三方包中Star排名第一的开源库。 虽然做的事情已经够多了，但是仍有一些很有必要去做的事情，由于时间原因，一直被搁置。 随着学习Flutter的人越来越多，一部分开发者通过查看官网的文档就能入门，但也有很多开发者感觉学习时仍然有些吃力，主要原因有两个，首先官网的文档主要是为了引导开发者快速上手的，讲的并不是很细；其次是我们虽然翻译了官方文档，但是对于Flutter SDK文档并没有翻译，而在开发中遇到的一些具体问题通常都得去查看SDK文档。所以，要解决这两个问题，必须得有一个系统化的Flutter教程，它不仅可以快速引导开发者入门，而且也能触及到一些细节和原理，最好也能提供一些学习和研究Flutter的方法。因此，如果能有一本能系统地介绍Flutter的书籍便是便是非常棒的！但是，当时没有一本关于Flutter的中文书籍，因此，我便计划写一本能由浅入深、系统介绍Flutter的书。2018年12月，《Flutter实战》完成初稿，并在Github上开源，同时上线了《Flutter实战》电子书官网 ，至今每天有3000多人在线浏览本书。那为什么不直接出版？如果直接出版，不仅有稿费，而且也能保护知识产权，而直接开源，不就就只能当雷锋了？其实，无论是做中文网、写Gitme、做Flutter开源项目，我的出发点都是为了能帮助中国开发者了解、学习Flutter，而这是一件非常有意义的事，只要坚持做对别人有价值的事，那么上帝迟早会奖赏你；当然我们也在网站中留了打赏的按钮，如果读者觉得有帮助，可以扫码打赏，请笔者喝一杯咖啡。另外由于成书比较仓促，当时书中也有很多错误，开源后，有很多读者提PR来纠正书中的错别字，时至今日，有78名开发者为本书提过PR，我在此，衷心的感谢你们。 起初，我没有出版实体书的打算，当时我以为开发者直接通过在线访问本书官网即方便又不用付费，何乐而不为。但在本书上线后，很多读者来添加微信好友，表示非常有收益，很期待出版纸质书，甚至有比较热心的读者想提前付定金预定！我理解，这是大家对我所做之事的认可和鼓励。考虑到，确实有一部分读者，尤其是还没毕业的同学，可能更喜欢通过书籍去学习，为此，我已经和机械工业出版社合作，目前本书纸质版正在出版中，敬请关注。 本书特色 笔者在大学时读过候捷（真名侯俊杰）写的一些C++相关书籍，在他的《深入浅出MFC》一书中，有一句话我映像非常深 “唯有深入，方能浅出”。我非常认同这句话，对于一门技术，只有了解的深入，才能用最浅显、通俗的话语描述出。我在写作本书时，深入浅出就是一个主要目标。所以，本书的目标不仅是想告诉读者如何使用Flutter，而且也非常关注各个知识点的底层实现以及设计思想。从本书章节划分上来看，入门篇为“浅出”，进阶篇则是“深入”。另外由于PC客户端开发、移动开发、Web开发这些经验我都有，而Flutter本质上是一个UI系统，而UI系统的设计和实现在”大前端“下有很多相通之处，所以在本书中的一些知识点我也会对比一些其他UI系统（主要是Android或Web）相应的实现，便于有相关开发经验的读者对比理解。 本书读者对象 读者至少熟悉一种编程语言。 读者最好接触过PC客户端、移动开发或Web前端开发中的一种。 本书不适合做为编程的入门读物。 关于随书源码 由于篇幅所限，本书中大多数示例代码都只是部分核心代码，读者可以去这里查看下载。 致谢 感谢一直以来支持Flutter中文网、Flutter开源项目的人以及所有对本书提过PR的人，正是因为有你们，才有这本书。另外尤其感谢给本书打赏过的同学，你们的支持给了我很大的鼓励。 权益 最后，知识是应该付费的，创作不易，开源不等于免费，如果您是本书读者并手头宽裕，可以点击下面打赏按钮打赏；当然，如果您囊中羞涩，您也可以阅读本书，但我对您有个小小的要求，希望您在阅读的过程中能积极参与到本书的纠错以及未完成内容的创作上来，也算是有所付出。 近来在网上发现很多原封不动复制本书的镜像网站和大量复制或引用了本书但未注明出处的博客、文章甚至书籍；对此，笔者在此声明，本书著作权归wendux所有，任何组织或个人在未经授权的情况下复制、拷贝、抄袭本书用于商业目的，笔者保留追究其法律责任的权利。如果是非商业目的的转载和引用，请注明出处并附上本书网址。另外如有出版机构愿意为本书出版实体书或者想转载本书内容，亦或是想合作，请加微信Demons-du. 最后 如果您发现本书中的错误，欢迎点击右上角的”编辑按钮“，提PR。如果您想一起参与本书创作，可以参考《Flutter实战》贡献指南。 "},"chapter1/":{"url":"chapter1/","title":"第一章：起步","keywords":"","body":"本章目录 移动开发技术简介 Flutter简介 搭建Flutter开发环境 Dart语言简介 "},"chapter1/mobile_development_intro.html":{"url":"chapter1/mobile_development_intro.html","title":"1.1：移动开发技术简介","keywords":"","body":"1.1 移动开发技术简介 本节将主要介绍一下移动开发技术的进化历程，主要是想让读者知道Flutter技术出现的背景。笔者认为，了解一门新技术出现的背景是非常重要的，因为只有了解之前是什么样的，才能理解为什么会是现在这样。 1.1.1 原生开发与跨平台技术 原生开发 原生应用程序是指某一个移动平台（比如iOS或安卓）所特有的应用，使用相应平台支持的开发工具和语言，并直接调用系统提供的SDK API。比如Android原生应用就是指使用Java或Kotlin语言直接调用Android SDK开发的应用程序；而iOS原生应用就是指通过Objective-C或Swift语言直接调用iOS SDK开发的应用程序。原生开发有以下主要优势： 可访问平台全部功能（GPS、摄像头）； 速度快、性能高、可以实现复杂动画及绘制，整体用户体验好； 主要缺点： 平台特定，开发成本高；不同平台必须维护不同代码，人力成本随之变大； 内容固定，动态化弱，大多数情况下，有新功能更新时只能发版； 在移动互联网发展初期，业务场景并不复杂，原生开发还可以应对产品需求迭代。 但近几年，随着物联网时代到来、移动互联网高歌猛进，日新月异，在很多业务场景中，传统的纯原生开发已经不能满足日益增长的业务需求。主要表现在： 动态化内容需求增大；当需求发生变化时，纯原生应用需要通过版本升级来更新内容，但应用上架、审核是需要周期的，这对高速变化的互联网时代来说是很难接受的，所以，对应用动态化(不发版也可以更新应用内容)的需求就变的迫在眉睫。 业务需求变化快，开发成本变大；由于原生开发一般都要维护Android、iOS两个开发团队，版本迭代时，无论人力成本，还是测试成本都会变大。 总结一下，纯原生开发主要面临动态化和开发成本两个问题，而针对这两个问题，诞生了一些跨平台的动态化框架。 跨平台技术简介 针对原生开发面临问题，人们一直都在努力寻找好的解决方案，而时至今日，已经有很多跨平台框架(注意，本书中所指的“跨平台”若无特殊说明，即特指Android和iOS两个平台)，根据其原理，主要分为三类： H5+原生（Cordova、Ionic、微信小程序） JavaScript开发+原生渲染 （React Native、Weex、快应用） 自绘UI+原生(QT for mobile、Flutter) 在接下来的章节中我们逐个来看看这三类框架的原理及优缺点。 1.1.2 Hybrid技术简介 H5+原生混合开发 这类框架主要原理就是将APP的一部分需要动态变动的内容通过H5来实现，通过原生的网页加载控件WebView (Android)或WKWebView（iOS）来加载（以后若无特殊说明，我们用WebView来统一指代android和iOS中的网页加载控件）。这样以来，H5部分是可以随时改变而不用发版，动态化需求能满足；同时，由于h5代码只需要一次开发，就能同时在Android和iOS两个平台运行，这也可以减小开发成本，也就是说，H5部分功能越多，开发成本就越小。我们称这种h5+原生的开发模式为混合开发 ，采用混合模式开发的APP我们称之为混合应用或Hybrid APP ，如果一个应用的大多数功能都是H5实现的话，我们称其为Web APP 。 目前混合开发框架的典型代表有：Cordova、Ionic 和微信小程序，值得一提的是微信小程序目前是在webview中渲染的，并非原生渲染，但将来有可能会采用原生渲染。 混合开发技术点 如之前所述，原生开发可以访问平台所有功能，而混合开发中，H5代码是运行在WebView中，而WebView实质上就是一个浏览器内核，其JavaScript依然运行在一个权限受限的沙箱中，所以对于大多数系统能力都没有访问权限，如无法访问文件系统、不能使用蓝牙等。所以，对于H5不能实现的功能，都需要原生去做。而混合框架一般都会在原生代码中预先实现一些访问系统能力的API， 然后暴露给WebView以供JavaScript调用，这样一来，WebView就成为了JavaScript与原生API之间通信的桥梁，主要负责JavaScript与原生之间传递调用消息，而消息的传递必须遵守一个标准的协议，它规定了消息的格式与含义，我们把依赖于WebView的用于在JavaScript与原生之间通信并实现了某种消息传输协议的工具称之为WebView JavaScript Bridge, 简称 JsBridge，它也是混合开发框架的核心。 示例：JavaScript调用原生API获取手机型号 下面我们以Android为例，实现一个获取手机型号的原生API供JavaScript调用。在这个示例中将展示JavaScript调用原生API的流程，读者可以直观的感受一下调用流程。我们选用笔者在Github上开源的dsBridge作为JsBridge来进行通信。dsBridge是一个支持同步调用的跨平台的JsBridge，此示例中只使用其同步调用功能。 首先在原生中实现获取手机型号的API getPhoneModel class JSAPI { @JavascriptInterface public Object getPhoneModel(Object msg) { return Build.MODEL; } } 将原生API通过WebView注册到JsBridge中 import wendu.dsbridge.DWebView ... //DWebView继承自WebView，由dsBridge提供 DWebView dwebView = (DWebView) findViewById(R.id.dwebview); //注册原生API到JsBridge dwebView.addJavascriptObject(new JsAPI(), null); 在JavaScript中调用原生API var dsBridge = require(\"dsbridge\") //直接调用原生API `getPhoneModel` var model = dsBridge.call(\"getPhoneModel\"); //打印机型 console.log(model); 上面示例演示了JavaScript调用原生API的过程，同样的，一般来说优秀的JsBridge也支持原生调用JavaScript，dsBridge也是支持的，如果您感兴趣，可以去github dsBridge项目主页查看。 现在，我们回头来看一下，混合应用无非就是在第一步中预先实现一系列API供JavaScript调用，让JavaScript有访问系统的能力，看到这里，我相信你也可以自己实现一个混合开发框架了。 总结 混合应用的优点是动态内容是H5，web技术栈，社区及资源丰富，缺点是性能不好，对于复杂用户界面或动画，WebView不堪重任。 1.1.3 React Native、Weex及快应用 本篇主要介绍一下 JavaScript开发+原生渲染的跨平台框架原理。 React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和Android两个平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。 由于RN和React原理相通，并且Flutter也是受React启发，很多思想也都是相通的，万丈高楼平地起，我们有必要深入了解一下React原理。React是一个响应式的Web框架，我们先了解一下两个重要的概念：DOM树与响应式编程。 DOM树与控件树 文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口，一种独立于平台和语言的方式访问和修改一个文档的内容和结构。换句话说，这是表示和处理一个HTML或XML文档的标准接口。简单来说，DOM就是文档树，与用户界面控件树对应，在前端开发中通常指HTML对应的渲染树，但广义的DOM也可以指Android中的XML布局文件对应的控件树，而术语DOM操作就是指直接来操作渲染树（或控件树）， 因此，可以看到其实DOM树和控件树是等价的概念，只不过前者常用于Web开发中，而后者常用于原生开发中。 响应式编程 React中提出一个重要思想：状态改变则UI随之自动改变，而React框架本身就是响应用户状态改变的事件而执行重新构建用户界面的工作，这就是典型的响应式编程范式，下面我们总结一下React中响应式原理： 开发者只需关注状态转移（数据），当状态发生变化，React框架会自动根据新的状态重新构建UI。 React框架在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。 值得注意的是，在第二步中，状态变化后React框架并不会立即去计算并渲染DOM树的变化部分，相反，React会在DOM的基础上建立一个抽象层，即虚拟DOM树，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到真实DOM中，而不是每次改变都去操作一下DOM。为什么不能每次改变都直接去操作DOM树？这是因为在浏览器中每一次DOM操作都有可能引起浏览器的重绘或回流： 如果DOM只是外观风格发生变化，如颜色变化，会导致浏览器重绘界面。 如果DOM树的结构发生变化，如尺寸、布局、节点隐藏等导致，浏览器就需要回流（及重新排版布局）。 而浏览器的重绘和回流都是比较昂贵的操作，如果每一次改变都直接对DOM进行操作，这会带来性能问题，而批量操作只会触发一次DOM更新。 思考题：Diff操作和DOM批量更新难道不应该是浏览器的职责吗？第三方框架中去做合不合适？ 此处需要有一张插图 React Native 上文已经提到React Native 是React 在原生移动应用平台的衍生产物，那两者主要的区别是什么呢？其实，主要的区别在于虚拟DOM映射的对象是什么？React中虚拟DOM最终会映射为浏览器DOM树，而RN中虚拟DOM会通过 JavaScriptCore 映射为原生控件树。 JavaScriptCore 是一个JavaScript解释器，它在React Native中主要有两个作用： 为JavaScript提供运行环境。 是JavaScript与原生应用之间通信的桥梁，作用和JsBridge一样，事实上，在iOS中，很多JsBridge的实现都是基于 JavaScriptCore 。 而RN中将虚拟DOM映射为原生控件的过程中分两步： 布局消息传递； 将虚拟DOM布局信息传递给原生； 原生根据布局信息通过对应的原生控件渲染控件树； 至此，React Native 便实现了跨平台。 相对于混合应用，由于React Native是原生控件渲染，所以性能会比混合应用中H5好很多，同时React Native是Web开发技术栈，也只需维护一份代码，同样是跨平台框架。 Weex Weex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL(Domain Specific Language) 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。 快应用 快应用是华为、小米、OPPO、魅族等国内9大主流手机厂商共同制定的轻量级应用标准，目标直指微信小程序。它也是采用JavaScript语言开发，原生控件渲染，与React Native和Weex相比主要有两点不同： 快应用自身不支持Vue或React语法，其采用原生JavaScript开发，其开发框架和微信小程序很像，值得一提的是小程序目前已经可以使用Vue语法开发（mpvue），从原理上来讲，Vue的语法也可以移植到快应用上。 React Native和Weex的渲染/排版引擎是集成到框架中的，每一个APP都需要打包一份，安装包体积较大；而快应用渲染/排版引擎是集成到ROM中的，应用中无需打包，安装包体积小，正因如此，快应用才能在保证性能的同时做到快速分发。 总结 JavaScript开发+原生渲染的方式主要优点如下： 采用Web开发技术栈，社区庞大、上手快、开发成本相对较低。 原生渲染，性能相比H5提高很多。 动态化较好，支持热更新。 不足： 渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿。 JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。 由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生UI系统限制，例如，在Android中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。 1.1.4 QT Mobile 在本篇中，我们看看最后一种跨平台技术：自绘UI+原生。这种技术的思路是，通过在不同平台实现一个统一接口的渲染引擎来绘制UI，而不依赖系统原生控件，所以可以做到不同平台UI的一致性。注意，自绘引擎解决的是UI的跨平台问题，如果涉及其它系统能力调用，依然要涉及原生开发。这种平台技术的优点如下： 性能高；由于自绘引擎是直接调用系统API来绘制UI，所以性能和原生控件接近。 灵活、组件库易维护、UI外观保真度和一致性高；由于UI渲染不依赖原生控件，也就不需要根据不同平台的控件单独维护一套组件库，所以代码容易维护。由于组件库是同一套代码、同一个渲染引擎，所以在不同平台，组件显示外观可以做到高保真和高一致性；另外，由于不依赖原生控件，也就不会受原生布局系统的限制，这样布局系统会非常灵活。 不足： 动态性不足；为了保证UI绘制性能，自绘UI系统一般都会采用AOT模式编译其发布包，所以应用发布后，不能像Hybrid和RN那些使用JavaScript（JIT）作为开发语言的框架那样动态下发代码。 开发效率低：QT使用C++作为其开发语言，而编程需要效率是直接会影响APP开发效率的，C++作为一门静态语言，在UI开发方面灵活性不及JavaScript这样的动态语言，另外，C++需要开发者手动去管理内存分配，没有JavaScript及Java中垃圾回收（GC）的机制。 也许你已经猜到Flutter就属于这一类跨平台技术，没错，Flutter正是实现一套自绘引擎，并拥有一套自己的UI布局系统。不过，自绘制引擎的思路并不是什么新概念，Flutter并不是第一个尝试这么做的，在它之前有一个典型的代表，即大名鼎鼎的QT。 QT简介 Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。2008年，Qt Company科技被诺基亚公司收购，Qt也因此成为诺基亚旗下的编程语言工具。2012年，Qt被Digia收购。2014年4月，跨平台集成开发环境Qt Creator 3.1.0正式发布，实现了对于iOS的完全支持，新增WinRT、Beautifier等插件，废弃了无Python接口的GDB调试支持，集成了基于Clang的C/C++代码模块，并对Android支持做出了调整，至此实现了全面支持iOS、Android、WP，它提供给应用程序开发者构建图形用户界面所需的所有功能。但是，QT虽然在PC端获得了巨大成功，备受社区追捧，然而其在移动端却表现不佳，在近几年，虽然偶尔能听到QT的声音，但一直很弱，无论QT本身技术如何、设计思想如何，但事实上终究是败了，究其原因，笔者认为主要有四： 第一：QT移动开发社区太小，学习资料不足，生态不好。 第二：官方推广不利，支持不够。 第三：移动端发力较晚，市场已被其它动态化框架占领（Hybrid和RN)。 第四：在移动开发中，C++开发和Web开发栈相比有着先天的劣势，直接结果就是QT开发效率太低。 基于此四点，尽管QT是移动端开发跨平台自绘引擎的先驱，但却成为了烈士。 1.1.5 Flutter出世 “千呼万唤始出来”，铺垫这么久，现在终于等到本书的主角出场了！ Flutter是Google发布的一个用于创建跨平台、高性能移动应用的框架。Flutter和QT mobile一样，都没有使用原生控件，相反都实现了一个自绘引擎，使用自身的布局、绘制系统。那么，我们会担心，QT mobile面对的问题Flutter是否也一样，Flutter会不会步入QT mobile后尘，成为另一个烈士？要回到这个问题，我们先来看看Flutter诞生过程： 2017 年 Google I/O 大会上，Google 首次推出了一款新的用于创建跨平台、高性能的移动应用框架——Flutter。 2018年2月，Flutter发布了第一个Beta版本，同年五月， 在2018年Google I/O 大会上，Flutter 更新到了 beta 3 版本。 2018年6月，Flutter发布了首个预览版本，这意味着 Flutter 进入了正式版（1.0）发布前的最后阶段。 观其发展，在2018年5月份，Flutter 进入了 GitHub stars 排行榜前 100 名，已有 27k star。而今天(2019年5月29日)，已经有65K的Star。经历了短短2年多的时间，Flutter 生态系统得以快速增长，由此可见，Flutter在开发者中受到了热烈的欢迎，其未来发展值得期待！ 现在，我们来和QT mobile做一个对比： 生态；从Github上来看，目前Flutter活跃用户正在高速增长。从Stackoverflow上提问来看，Flutter社区现在已经很庞大。Flutter的文档、资源也越来越丰富，开发过程中遇到的很多问题都可以在Stackoverflow或其github issue中找到答案。 技术支持；现在Google正在大力推广Flutter，Flutter的作者中很多人都是来自Chromium团队，并且github上活跃度很高。另一个角度，从今年上半年Flutter频繁的版本发布也可以看出Google对Flutter的投入的资源不小，所以在官方技术支持这方面，大可不必担心。 开发效率；Flutter的热重载可帮助开发者快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以实现毫秒级热重载，并且不会丢失状态。这真的很棒，相信我，如果你是一名原生开发者，体验了Flutter开发流后，很可能就不想重新回去做原生了，毕竟很少有人不吐槽原生开发的编译速度。 基于以上三点，相信读者和笔者一样，Flutter未来如何，心中自有定论。到现在为止，我们已经对移动端开发技术有了一个全面的了解，接下来我们便要进入本书的主题，你准备好了吗！ 1.1.6 小节 本章主要介绍了目前移动开发中三种跨平台技术，现在我们从框架角度对比一下： 技术类型 UI渲染方式 性能 开发效率 动态化 框架代表 H5+原生 WebView渲染 一般 高 ✔️ Cordova、Ionic JavaScript+原生渲染 原生控件渲染 好 中 ✔️ RN、Weex 自绘UI+原生 调用系统API渲染 好 Flutter高, QT低 默认不支持 QT、Flutter 上表中开发语言主要指UI的开发语言。而开发效率，是指整个开发周期的效率，包括编码时间、调试时间、以及排错、兼容时间。动态化主要指是否支持动态下发代码和是否支持热更新。值得注意的是Flutter的Release包默认是使用Dart AOT模式编译的，所以不支持动态化，但Dart还有JIT或snapshot运行方式，这些模式都是支持动态化的。 "},"chapter1/flutter_intro.html":{"url":"chapter1/flutter_intro.html","title":"1.2：初识Flutter","keywords":"","body":"1.2 初识Flutter 1.2.1 Flutter简介 Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加 native扩展。同时 Flutter还使用 Native引擎渲染视图，这无疑能为用户提供良好的体验。 跨平台自绘引擎 Flutter与用于构建移动应用程序的其它大多数框架不同，因为Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。 Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎。 高性能 Flutter高性能主要靠两点来保证，首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。 采用Dart语言开发 这是一个很有意思，但也很有争议的问题，在了解Flutter为什么选择了 Dart而不是 JavaScript之前我们先来介绍两个概念：JIT和AOT。 目前，程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”。AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。 现在我们看看Flutter为什么选择Dart语言？笔者根据官方解释以及自己对Flutter的理解总结了以下几条（由于其它跨平台框架都将JavaScript作为其开发语言，所以主要将Dart和JavaScript做一个对比）： 开发效率高 Dart运行时和编译器支持Flutter的两个关键特性的组合： 基于JIT的快速开发周期：Flutter在开发阶段采用，采用JIT模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间； 基于AOT的发布包: Flutter在发布时可以通过AOT生成高效的ARM代码以保证应用性能。而JavaScript则不具有这个能力。 高性能 Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。 快速内存分配 Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。 类型安全 由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。 Dart团队就在你身边 看似不起眼，实则举足轻重。由于有Dart团队的积极投入，Flutter团队可以获得更多、更方便的支持，正如Flutter官网所述“我们正与Dart社区进行密切合作，以改进Dart在Flutter中的使用。例如，当我们最初采用Dart时，该语言并没有提供生成原生二进制文件的工具链（这对于实现可预测的高性能具有很大的帮助），但是现在它实现了，因为Dart团队专门为Flutter构建了它。同样，Dart VM之前已经针对吞吐量进行了优化，但团队现在正在优化VM的延迟时间，这对于Flutter的工作负载更为重要。” 总结 本节主要介绍了一下Flutter的特点，如果你感到有些点还不是很好理解，不用着急，随着日后对Flutter细节的了解，再回过头来看，相信你会有更深的体会。 1.2.2 Flutter框架结构 本节我们先对Flutter的框架做一个整体介绍，旨在让读者心中有一个整体的印象，这对初学者来说非常重要。如果一下子便深入到Flutter中，就会像是一个在沙漠中没有地图的人，即使可以找到一个绿洲，但是他也不会知道下一个绿洲在哪。因此，无论学什么技术，都要现有一张清晰的“地图”，而我们的学习过程就是“按图索骥”，这样我们才不会陷于细节而“目无全牛”。言归正传，我们看一下Flutter官方提供的Flutter框架图，如图1-1所示： Flutter Framework 这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上，我们来简单介绍一下： 底下两层（Foundation和Animation、Painting、Gestures）在Google的一些视频中被合并为一个dart UI层，对应的是Flutter中的dart:ui包，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。 Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。 Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而我们Flutter开发的大多数场景，只是和这两层打交道。 Flutter Engine 这是一个纯 C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 dart:ui库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。 总结 Flutter框架本身有着良好的分层设计，本节旨在让读者对Flutter整体框架有个大概的印象，相信到现在为止，读者已经对Flutter有一个初始印象，在我们正式动手之前，我们还需要了解一下Flutter的开发语言Dart。 1.2.3 如何学习Flutter 本节给大家一些学习建议，分享一下笔者在学习Flutter中的一些心得，希望可以帮助你提高学习效率，避免不必要的坑。 资源 官网：阅读Flutter官网的资源是快速入门的最佳方式，同时官网也是了解最新Flutter发展动态的地方，由于目前Flutter仍然处于快速发展阶段，所以建议读者还是时不时的去官网看看有没有新的动态。 源码及注释：源码注释应作为学习Flutter的第一文档，Flutter SDK的源码是开源的，并且注释非常详细，也有很多示例，实际上，Flutter官方的SDK文档就是通过注释生成的。源码结合注释可以帮你解决大多数问题。 Github：如果遇到的问题在StackOverflow上也没有找到答案，可以去github flutter 项目下提issue。 Gallery源码：Gallery是Flutter官方示例APP，里面有丰富的示例，读者可以在网上下载安装。Gallery的源码在Flutter源码“examples”目录下。 社区 StackOverflow：如果你还没听过StackOverflow，这是目前全球最大的程序员问答社区，现在也是活跃度最高的Flutter问答社区。StackOverflow上面除了世界各地的Flutter使用者会在上面交流之外，Flutter开发团队的成员也经常会在上面回答问题。 Flutter中文网社区：Flutter中文网(https://flutterchina.club)是笔者维护中文网站，目前也是最大的中文资源社区，上面提供了Flutter官网的文档翻译、开源项目、及案例，还有申请加入组织的入口哦。 博客：随着Flutter技术的推广，相信很快网上将会有很多Flutter相关的文章、博客，读者可以多去浏览、阅读。 总结 有了资料和社区后，对于我们学习者自身来说，最重要的还是要多动手、多实践，在本书后面的章节中，希望读者能够亲自动手写一下示例。准备好了吗，下一章中，我们将正式进入Flutter的世界！ "},"chapter1/install_flutter.html":{"url":"chapter1/install_flutter.html","title":"1.3：搭建Flutter开发环境","keywords":"","body":"1.3 搭建Flutter开发环境 工欲善其事必先利其器，本节首先会分别介绍一下在Windows和macOS下Flutter SDK的安装，然后再介绍一下配IDE和模拟器的使用。 1.3.1 安装Flutter 由于Flutter会同时构建Android和IOS两个平台的发布包，所以Flutter同时依赖Android SDK和iOS SDK，在安装Flutter时也需要安装相应平台的构建工具和SDK。下面我们分别介绍一下Windows和macOS下的环境搭建。 注意：本节介绍的安装方式随着Flutter的升级可能会发生变化，如果下面介绍的内容在您安装Flutter时已经失效，请访问Flutter官网，按照官网最新的安装教程安装。 使用镜像 由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，大家可以将如下环境变量加入到用户环境变量中： export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 注意： 此镜像为临时镜像，并不能保证一直可用，读者可以参考https://flutter.io/community/china 以获得有关镜像服务器的最新动态。 在Windows上搭建Flutter开发环境 系统要求 要安装并运行Flutter，您的开发环境必须满足以下最低要求: 操作系统: Windows 7 或更高版本 (64-bit) 磁盘空间: 400 MB (不包括Android Studio的磁盘空间). 工具: Flutter 依赖下面这些命令行工具. PowerShell 5.0 或更新的版本 Git for Windows (Git命令行工具)； 如果已安装Git for Windows，请确保可以在命令提示符或PowerShell中运行 git 命令 获取Flutter SDK 去flutter官网下载其最新可用的安装包，下载地址：https://flutter.io/sdk-archive/，打开后如图1-2所示： 注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去Flutter github项目下去下载安装包，地址：https://github.com/flutter/flutter/releases 。 将安装包zip解压到你想安装Flutter SDK的路径（如：C:\\src\\flutter；注意，不要将flutter安装到需要一些高权限的路径如C:\\Program Files\\）。 在Flutter安装目录的flutter文件下找到flutter_console.bat，双击运行并启动flutter命令行，接下来，你就可以在Flutter命令行运行flutter命令了。 更新环境变量 如果你想在Windows系统自带命令行（而不是）运行flutter命令，需要添加以下环境变量到用户PATH： 转到 “控制面板>用户帐户>用户帐户>更改我的环境变量” 在“用户变量”下检查是否有名为“Path”的条目: 如果该条目存在， 追加 flutter\\bin的全路径，使用 ; 作为分隔符. 如果该条目不存在，创建一个新用户变量 Path ，然后将 flutter\\bin 的全路径作为它的值. 重启Windows以应用此更改. 运行 flutter doctor命令 在Flutter命令行运行如下命令来查看是否还需要安装其它依赖，如果需要，安装它们： flutter doctor 该命令检查你的环境并在命令行窗口中显示报告。Dart SDK已经在打包在Flutter SDK里了，没有必要单独安装Dart。 仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务。 例如： [-] Android toolchain - develop for Android devices • Android SDK at D:\\Android\\sdk ✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ • Try re-installing or updating your Android SDK, visit https://flutter.io/setup/#android-setup for detailed instructions. 第一次运行flutter命令（如flutter doctor）时，它会下载它自己的依赖项并自行编译。以后再运行就会快得多。缺失的依赖需要安装一下，安装完成后再运行flutter doctor命令来验证是否安装成功。 Android设置 Flutter依赖于Android Studio的全量安装。Android Studio不仅可以管理Android 平台依赖、SDK版本等，而且它也是Flutter开发推荐的IDE之一（当然，你也可以使用其它编辑器或IDE，我们将会在后面讨论）。 安装Android Studio 下载并安装 Android Studio，下载地址：https://developer.android.com/studio/index.html 。 启动Android Studio，然后执行“Android Studio安装向导”。这将安装最新的Android SDK、Android SDK平台工具和Android SDK构建工具，这些是用Flutter进行Android开发所需要的。 安装遇到问题？ 如果在安装过程中遇到问题，可以先去flutter官网查看一下安装方式是否发生变化，或者在网上搜索一下解决方案。 在macOS上搭建Flutter开发环境 在masOS下可以同时进行Android和iOS设备的测试。 系统要求 要安装并运行Flutter，您的开发环境必须满足以下最低要求: 操作系统: macOS (64-bit) 磁盘空间: 700 MB (不包括Xcode或Android Studio的磁盘空间）. 工具: Flutter 依赖下面这些命令行工具. bash、mkdir、rm、git、curl、unzip、which 获取Flutter SDK 去flutter官网下载其最新可用的安装包，官网地址：https://flutter.io/sdk-archive/#macos 注意，Flutter的渠道版本会不停变动，请以Flutter官网为准。另外，在中国大陆地区，要想正常获取安装包列表或下载安装包，可能需要翻墙，读者也可以去Flutter github项目下去下载安装包，地址：https://github.com/flutter/flutter/releases 。 解压安装包到你想安装的目录，如： cd ~/development unzip ~/Downloads/flutter_macos_v0.5.1-beta.zip 添加flutter相关工具到path中： export PATH=`pwd`/flutter/bin:$PATH 此代码只能暂时针对当前命令行窗口设置PATH环境变量，要想永久将Flutter添加到PATH中请参考下面更新环境变量 部分。 运行 flutter doctor命令 这一步和Windows下步骤一致，不再赘述。 更新环境变量 将Flutter添加到PATH中，可以在任何终端会话中运行flutter命令。 对于所有终端会话永久修改此变量的步骤是和特定计算机系统相关的。通常，您会在打开新窗口时将设置环境变量的命令添加到执行的文件中。例如 确定您Flutter SDK的目录记为“FLUTTER_INSTALL_PATH”，您将在步骤3中用到。 打开(或创建) $HOME/.bash_profile。文件路径和文件名可能在你的电脑上不同. 添加以下路径: export PATH=[FLUTTER_INSTALL_PATH]/flutter/bin:$PATH 例如笔者Flutter 安装目录是“~/code/flutter_dir”，那么代码为： export PATH=~/code/flutter_dir/flutter/bin:$PATH 运行 source $HOME/.bash_profile 刷新当前终端窗口。 注意: 如果你使用终端是zsh，终端启动时 ~/.bash_profile 将不会被加载，解决办法就是修改 ～/.zshrc ，在其中添加：source ～/.bash_profile 验证“flutter/bin”是否已在PATH中： echo $PATH 安装 Xcode 要为iOS开发Flutter应用程序，您需要Xcode 9.0或更高版本: 安装Xcode 9.0或更新版本(通过链接下载或苹果应用商店). 配置Xcode命令行工具以使用新安装的Xcode版本 sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer 对于大多数情况，当您想要使用最新版本的Xcode时，这是正确的路径。如果您需要使用不同的版本，请指定相应路径。 确保Xcode许可协议是通过打开一次Xcode或通过命令sudo xcodebuild -license同意过了. 使用Xcode，您可以在iOS设备或模拟器上运行Flutter应用程序。 安装Android Studio 和Window一样，要在Android设备上构建并运行Flutter程序都需要先安装Android Studio，读者可以先自行下载并安装Android Studio，在此不再赘述。 升级 Flutter Flutter SDK分支 Flutter SDK有多个分支，如beta、dev、master、stable，其中stable分支为稳定分支（日后有新的稳定版本发布后可能也会有新的稳定分支，如1.0.0），dev和master为开发分支，安装flutter后，你可以运行flutter channel查看所有分支，如笔者本地运行后，结果如下： Flutter channels: beta dev * master 带\"*\"号的分支即你本地的Flutter SDK 跟踪的分支，要切换分支，可以使用flutter channel beta 或 flutter channel master，Flutter官方建议跟踪稳定分支，但你也可以跟踪master分支，这样可以查看最新的变化，但这样稳定性要低的多。 升级Flutter SDK和依赖包 要升级flutter sdk，只需一句命令： flutter upgrade 该命令会同时更新Flutter SDK和你的flutter项目依赖包。如果你只想更新项目依赖包（不包括Flutter SDK），可以使用如下命令： flutter packages get获取项目所有的依赖包。 flutter packages upgrade 获取项目所有依赖包的最新版本。 1.3.2 IDE配置与使用 理论上可以使用任何文本编辑器与命令行工具来构建Flutter应用程序。 不过，Flutter官方建议使用Android Studio和VS Code之一以获得更好的开发体验。Flutter官方提供了这两款编辑器插件，通过IDE和插件可获得代码补全、语法高亮、widget编辑辅助、运行和调试支持等功能，可以帮助我们极大的提高开发效率。下面我们分别介绍一下Android Studio和VS Code的配置及使用（Android Studio和VS Code读者可以在其官网获得最新的安装，由于安装比较简单，故不再赘述）。 Android Studio 配置与使用 由于Android Studio是基于IntelliJ IDEA开发的，所以读者也可以使用IntelliJ IDEA。 安装Flutter和Dart插件 需要安装两个插件: Flutter插件： 支持Flutter开发工作流 (运行、调试、热重载等)。 Dart插件： 提供代码分析 (输入代码时进行验证、代码补全等)。 安装步骤： 启动Android Studio。 打开插件首选项 (macOS：Preferences>Plugins, Windows：File>Settings>Plugins)。 选择 Browse repositories…，选择 flutter 插件并点击 install。 重启Android Studio后插件生效。 接下来，让我们用Android Studio创建一个Flutter项目，然后运行它，并体验“热重载”。 创建Flutter应用 选择 File>New Flutter Project 。 选择 Flutter application 作为 project 类型, 然后点击 Next。 输入项目名称 (如 myapp)，然后点击 Next。 点击 Finish。 等待Android Studio安装SDK并创建项目。 上述命令创建一个Flutter项目，项目名为myapp，其中包含一个使用Material 组件的简单演示应用程序。 在项目目录中，您应用程序的代码位于 lib/main.dart。 运行应用程序 定位到Android Studio工具栏，如图1-3所示： 在 target selector 中, 选择一个运行该应用的Android设备。如果没有列出可用，请选择 Tools>Android>AVD Manager 并在那里创建一个。 在工具栏中点击 Run图标。 如果一切正常, 您应该在您的设备或模拟器上会看到启动的应用程序： 体验热重载 Flutter 可以通过 热重载（hot reload） 实现快速的开发周期，热重载就是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态。简单的对代码进行更改，然后告诉IDE或命令行工具你需要重新加载（点击reload按钮），你就会在你的设备或模拟器上看到更改。 打开lib/main.dart文件 将字符串 'You have pushed the button this many times:' 更改为 'You have clicked the button this many times:' 不要按“停止”按钮; 让您的应用继续运行. 要查更改，请调用 Save (cmd-s / ctrl-s)，或者点击 热重载按钮 (带有闪电⚡️图标的按钮)。 你会立即在运行的应用程序中看到更新的字符串。 VS Code的配置与使用 VS Code是一个轻量级编辑器，支持Flutter运行和调试。 安装flutter插件 启动 VS Code。 调用 View>Command Palette…。 输入 ‘install’, 然后选择 Extensions: Install Extension action。 在搜索框输入 flutter ，在搜索结果列表中选择 ‘Flutter’, 然后点击 Install。 选择 ‘OK’ 重新启动 VS Code。 验证配置 调用 View>Command Palette… 输入 ‘doctor’, 然后选择 ‘Flutter: Run Flutter Doctor’ action。 查看“OUTPUT”窗口中的输出是否有问题 创建Flutter应用 启动 VS Code 调用 View>Command Palette… 输入 ‘flutter’, 然后选择 ‘Flutter: New Project’ action 输入 Project 名称 (如myapp), 然后按回车键 指定放置项目的位置，然后按蓝色的确定按钮 等待项目创建继续，并显示main.dart文件 体验热重载 打开lib/main.dart文件。 将字符串 'You have pushed the button this many times:' 更改为 'You have clicked the button this many times:'。 不要按“停止”按钮; 让您的应用继续运行。 要查看您的更改，请调用 Save (cmd-s / ctrl-s), 或者点击 热重载按钮 (绿色圆形箭头按钮)。 你会立即在运行的应用程序中看到更新的字符串。 1.3.3 连接设备运行Flutter应用 Window下只支持为Android设备构建并运行Flutter应用，而macOS同时支持iOS和Android设备。下面分别介绍如何连接Android和iOS设备来运行flutter应用。 连接Android模拟器 要准备在Android模拟器上运行并测试Flutter应用，请按照以下步骤操作： 启动 Android Studio>Tools>Android>AVD Manager 并选择 Create Virtual Device. 选择一个设备并选择 Next。 为要模拟的Android版本选择一个或多个系统印象，然后选择 Next. 建议使用 x86 或 x86_64 image . 在 “Emulated Performance”下, 选择 Hardware - GLES 2.0 以启用 硬件加速. 验证AVD配置是否正确，然后选择 Finish。 有关上述步骤的详细信息，请参阅 Managing AVDs. 在“Android Virtual Device Manager”中，点击工具栏的 Run。模拟器启动并显示所选操作系统版本或设备的启动画面。 运行 flutter run 启动您的设备。 连接的设备名是 Android SDK built for ，其中 platform 是芯片系列，如 x86。 连接Android真机设备 要准备在Android设备上运行并测试Flutter应用，需要Android 4.1（API level 16）或更高版本的Android设备. 在Android设备上启用 开发人员选项 和 USB调试 。详细说明可在Android文档中找到。 使用USB将手机插入电脑。如果设备出现调试授权提示，请授权你的电脑可以访问该设备。 在命令行运行 flutter devices 命令以验证Flutter识别您连接的Android设备。 运行启动你应用程序 flutter run。 默认情况下，Flutter使用的Android SDK版本是基于你的 adb 工具版本。 如果想让Flutter使用不同版本的Android SDK，则必须将该 ANDROID_HOME 环境变量设置为相应的SDK安装目录。 连接iOS模拟器 要准备在iOS模拟器上运行并测试Flutter应用，请按以下步骤操作： 在你的MAC上，通过 Spotlight 或以下命令找到模拟器： open -a Simulator 通过检查模拟器 Hardware > Device 菜单中的设置，确保模拟器正在使用64位设备（iPhone 5s或更高版本）。 根据你电脑屏幕大小，模拟高清屏iOS设备可能会溢出屏幕。可以在模拟器的 Window> Scale 菜单下设置设备比例。 运行 flutter run启动flutter应用程序。 连接iOS真机设备 要将Flutter应用安装到iOS真机设备，需要一些额外的工具和一个Apple帐户，还需要在Xcode中进行一些设置。 安装 homebrew （如果已经安装了brew,跳过此步骤）。 打开终端并运行如下这些命令: brew update brew install --HEAD libimobiledevice brew install ideviceinstaller ios-deploy cocoapods pod setup 如果这些命令中的任何一个失败并出现错误，请运行brew doctor并按照说明解决问题. 遵循Xcode签名流程来配置您的项目: 在你Flutter项目目录中通过 open ios/Runner.xcworkspace 打开默认的Xcode workspace. 在Xcode中，选择导航面板左侧中的Runner项目。 在Runner target设置页面中，确保在 General > Signing > Team 下选择了你的开发团队。当你选择一个团队时，Xcode会创建并下载开发证书，向你的设备注册你的帐户，并创建和下载配置文件（如果需要）。 要开始您的第一个iOS开发项目，您可能需要使用您的Apple ID登录Xcode，如图1-5： 任何Apple ID都支持开发和测试，但若想将应用分发到App Store，就必须注册Apple开发者计划，有关详情读者可以自行了解。 当您第一次attach真机设备进行iOS开发时，需要同时信任你的Mac和该设备上的开发证书。首次将iOS设备连接到Mac时，请在对话框中选择 Trust。 然后，转到iOS设备上的设置菜单，选择 常规>设备管理 并信任您的证书。 如果Xcode中的自动签名失败，请验证项目的 General > Identity > Bundle Identifier 值是否唯一，如图1-7所示： 运行 flutter run启动flutter应用程序。 1.3.4 常见配置问题 Android Studio问题 缺少依赖库问题 上手安卓最常遇见的问题之一，错误如图1-8所示，此时点击超链接即可自动跳转到安装页面 安装之后重新运行即可，如图1-9： 连接不上Android Repository 这也是最常见的问题之一，当你发现自己无法下载部分依赖的时候，请优先考虑这种情况。进入 File -> Settings -> Appearance & Behavior -> System Settings -> Android SDK -> SDK Update Sites 列表，可以看到此时的 Android Repository 无法连接，如图1-10所示： 这是由于要去Google下载Android SDK，但在国内目前无法访问Google所致，因此，我们可以配置代理或使用vpn。 安卓包配置问题 一般格式为 Could not HEAD ** Could not Get ** 如：Android Studio Could not GET gradle-3.2.0.pom 这一类问题是由于无法连接到 Maven 库造成的，解决方法如下： 进入当前所在项目名/android 打开 build.gradle 找到下面这一部分，并加上 maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' } allprojects { repositories { google() jcenter() maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' } //添加这一句 } } 进入 File/ Settings/ Build, Execution, Deployment/ BuildTools/ Gradle/ Android Studio 中，勾选上 Enable embedded Maven repository ，重启 Android Studio 即可解决。 注意：存在这样的一种情况，当你根据上述步骤设置了之后，依旧无法解决这个问题，并有类似于 Could not HEAD maven.aliyun.com 的报错信息，请检查 C:\\Users\\{user_name}\\.gradle\\gradle.properties 是否有设置代理。删除后问题即可解决。 Hot Reload 热重载失效问题 在给 Terminal 之类的终端模拟器设置代理之后，会导致”Hot Reload“重载失效，此时调用 Save (cmd-s / ctrl-s)将不会进行热重载，热重载按钮 (带有闪电⚡️图标的按钮)也不会显示，将代理移除即可解决。 另外，有些情况下热重载是不生效的，比如修改了main函数、修改了全局静态方法等，读者可以认为”Hot Reload“只会重新构建整个widget树，如果变动不在构建widget树的过程中，”Hot Reload“就不会起作用。 "},"chapter1/dart.html":{"url":"chapter1/dart.html","title":"1.4：Dart语言简介","keywords":"","body":"1.4 Dart语言简介 在之前我们已经介绍过Dart语言的相关特性，读者可以翻看一下，如果读者已经熟悉Dart语法，可以跳过本节，如果你还不了解Dart，也不用担心，按照笔者经验，如果你有过其他编程语言经验（尤其是Java和JavaScript）的话会非常容易上手Dart。当然，如果你是iOS开发者，也不用担心，Dart中也有一些与Swift比较相似的特性，如命名参数等，笔者当时学习Dart时，只是花了一个小时，看完Dart官网的Language Tour，就开始动手写Flutter了。 在笔者看来，Dart的设计目标应该是同时借鉴了Java和JavaScript。Dart在静态语法方面和Java非常相似，如类型定义、函数声明、泛型等，而在动态特性方面又和JavaScript很像，如函数式特性、异步支持等。除了融合Java和JavaScript语言之所长之外，Dart也具有一些其它具有表现力的语法，如可选命名参数、..（级联运算符）和?.（条件成员访问运算符）以及??（判空赋值运算符）。其实，对编程语言了解比较多的读者会发现，在Dart中其实看到的不仅有Java和JavaScript的影子，它还具有其它编程语言中的身影，如命名参数在Objective-C和Swift中早就很普遍，而??操作符在PHP 7.0语法中就已经存在了，因此我们可以看到Google对Dart语言给予厚望，是想把Dart打造成一门集百家之所长的编程语言。 接下来，我们先对Dart语法做一个简单的介绍，然后再将Dart与JavaScript和Java做一个简要的对比，方便读者更好的理解。 注意：由于本书并非专门介绍Dart语言的书籍，所以本章主要会介绍一下在Flutter开发中常用的语法特性，如果想更多了解Dart，读者可以去Dart官网学习，现在互联网上Dart相关资料已经很多了。另外Dart 2.0已经正式发布，所以本书所有示例均采用Dart 2.0语法。 1.4.1 变量声明 var 类似于JavaScript中的var，它可以接收任何类型的变量，但最大的不同是Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型，如： var t; t = \"hi world\"; // 下面代码在dart中会报错，因为变量t的类型已经确定为String， // 类型一旦确定后则不能再更改其类型。 t = 1000; 上面的代码在JavaScript是没有问题的，前端开发者需要注意一下，之所以有此差异是因为Dart本身是一个强类型语言，任何变量都是有确定类型的，在Dart中，当用var声明一个变量后，Dart在编译时会根据第一次赋值数据的类型来推断其类型，编译结束后其类型就已经被确定，而JavaScript是纯粹的弱类型脚本语言，var只是变量的声明方式而已。 dynamic和Object Object 是Dart所有对象的根基类，也就是说所有类型都是Object的子类(包括Function和Null)，所以任何类型的数据都可以赋值给Object声明的对象. dynamic与var一样都是关键词,声明的变量可以赋值任意对象。 而dynamic与Object相同之处在于,他们声明的变量可以在后期改变赋值类型。 dynamic t; Object x; t = \"hi world\"; x = 'Hello Object'; //下面代码没有问题 t = 1000; x = 1000; dynamic与Object不同的是,dynamic声明的对象编译器会提供所有可能的组合, 而Object声明的对象只能使用Object的属性与方法, 否则编译器会报错。如: dynamic a; Object b; main() { a = \"\"; b = \"\"; printLengths(); } printLengths() { // no warning print(a.length); // warning: // The getter 'length' is not defined for the class 'Object' print(b.length); } 变量a不会报错, 变量b编译器会报错 dynamic的这个特性与Objective-C中的id作用很像. dynamic的这个特点使得我们在使用它时需要格外注意,这很容易引入一个运行时错误. final和const 如果您从未打算更改一个变量，那么使用 final 或 const，不是var，也不是一个类型。 一个 final 变量只能被设置一次，两者区别在于：const 变量是一个编译时常量，final变量在第一次使用时被初始化。被final或者const修饰的变量，变量类型可以省略，如： //可以省略String这个类型声明 final str = \"hi world\"; //final String str = \"hi world\"; const str1 = \"hi world\"; //const String str1 = \"hi world\"; 1.4.2 函数 Dart是一种真正的面向对象的语言，所以即使是函数也是对象，并且有一个类型Function。这意味着函数可以赋值给变量或作为参数传递给其他函数，这是函数式编程的典型特征。 函数声明 bool isNoble(int atomicNumber) { return _nobleGases[atomicNumber] != null; } Dart函数声明如果没有显式声明返回值类型时会默认当做dynamic处理，注意，函数返回值没有类型推断： typedef bool CALLBACK(); //不指定返回类型，此时默认为dynamic，不是bool isNoble(int atomicNumber) { return _nobleGases[atomicNumber] != null; } void test(CALLBACK cb){ print(cb()); } //报错，isNoble不是bool类型 test(isNoble); 对于只包含一个表达式的函数，可以使用简写语法 bool isNoble (int atomicNumber)=> _nobleGases [ atomicNumber ] ！= null ; 函数作为变量 var say = (str){ print(str); }; say(\"hi world\"); 函数作为参数传递 void execute(var callback) { callback(); } execute(() => print(\"xxx\")) 可选的位置参数 包装一组函数参数，用[]标记为可选的位置参数： String say(String from, String msg, [String device]) { var result = '$from says $msg'; if (device != null) { result = '$result with a $device'; } return result; } 下面是一个不带可选参数调用这个函数的例子： say('Bob', 'Howdy'); //结果是： Bob says Howdy 下面是用第三个参数调用这个函数的例子： say('Bob', 'Howdy', 'smoke signal'); //结果是：Bob says Howdy with a smoke signal 可选的命名参数 定义函数时，使用{param1, param2, …}，用于指定命名参数。例如： //设置[bold]和[hidden]标志 void enableFlags({bool bold, bool hidden}) { // ... } 调用函数时，可以使用指定命名参数。例如：paramName: value enableFlags(bold: true, hidden: false); 可选命名参数在Flutter中使用非常多。 1.4.3 异步支持 Dart类库有非常多的返回Future或者Stream对象的函数。 这些函数被称为异步函数：它们只会在设置好一些耗时操作之后返回，比如像 IO操作。而不是等到这个操作完成。 async和await关键词支持了异步编程，允许您写出和同步代码很像的异步代码。 Future Future与JavaScript中的Promise非常相似，表示一个异步操作的最终完成（或失败）及其结果值的表示。简单来说，它就是用于处理异步操作的，异步处理成功了就执行成功的操作，异步处理失败了就捕获错误或者停止后续操作。一个Future只会对应一个结果，要么成功，要么失败。 由于本身功能较多，这里我们只介绍其常用的API及特性。还有，请记住，Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用。 Future.then 为了方便示例，在本例中我们使用Future.delayed 创建了一个延时任务（实际场景会是一个真正的耗时任务，比如一次网络请求），即2秒后返回结果字符串\"hi world!\"，然后我们在then中接收异步结果并打印结果，代码如下： Future.delayed(new Duration(seconds: 2),(){ return \"hi world!\"; }).then((data){ print(data); }); Future.catchError 如果异步任务发生错误，我们可以在catchError中捕获错误，我们将上面示例改为： Future.delayed(new Duration(seconds: 2),(){ //return \"hi world!\"; throw AssertionError(\"Error\"); }).then((data){ //执行成功会走到这里 print(\"success\"); }).catchError((e){ //执行失败会走到这里 print(e); }); 在本示例中，我们在异步任务中抛出了一个异常，then的回调函数将不会被执行，取而代之的是 catchError回调函数将被调用；但是，并不是只有 catchError回调才能捕获错误，then方法还有一个可选参数onError，我们也可以它来捕获异常： Future.delayed(new Duration(seconds: 2), () { //return \"hi world!\"; throw AssertionError(\"Error\"); }).then((data) { print(\"success\"); }, onError: (e) { print(e); }); Future.whenComplete 有些时候，我们会遇到无论异步任务执行成功或失败都需要做一些事的场景，比如在网络请求前弹出加载对话框，在请求结束后关闭对话框。这种场景，有两种方法，第一种是分别在then或catch中关闭一下对话框，第二种就是使用Future的whenComplete回调，我们将上面示例改一下： Future.delayed(new Duration(seconds: 2),(){ //return \"hi world!\"; throw AssertionError(\"Error\"); }).then((data){ //执行成功会走到这里 print(data); }).catchError((e){ //执行失败会走到这里 print(e); }).whenComplete((){ //无论成功或失败都会走到这里 }); Future.wait 有些时候，我们需要等待多个异步任务都执行结束后才进行一些操作，比如我们有一个界面，需要先分别从两个网络接口获取数据，获取成功后，我们需要将两个接口数据进行特定的处理后再显示到UI界面上，应该怎么做？答案是Future.wait，它接受一个Future数组参数，只有数组中所有Future都执行成功后，才会触发then的成功回调，只要有一个Future执行失败，就会触发错误回调。下面，我们通过模拟Future.delayed 来模拟两个数据获取的异步任务，等两个异步任务都执行成功时，将两个异步任务的结果拼接打印出来，代码如下： Future.wait([ // 2秒后返回结果 Future.delayed(new Duration(seconds: 2), () { return \"hello\"; }), // 4秒后返回结果 Future.delayed(new Duration(seconds: 4), () { return \" world\"; }) ]).then((results){ print(results[0]+results[1]); }).catchError((e){ print(e); }); 执行上面代码，4秒后你会在控制台中看到“hello world”。 Async/await Dart中的async/await 和JavaScript中的async/await功能和用法是一模一样的，如果你已经了解JavaScript中的async/await的用法，可以直接跳过本节。 回调地狱(Callback Hell) 如果代码中有大量异步逻辑，并且出现大量异步任务依赖其它异步任务的结果时，必然会出现Future.then回调中套回调情况。举个例子，比如现在有个需求场景是用户先登录，登录成功后会获得用户ID，然后通过用户ID，再去请求用户个人信息，获取到用户个人信息后，为了使用方便，我们需要将其缓存在本地文件系统，代码如下： //先分别定义各个异步任务 Future login(String userName, String pwd){ ... //用户登录 }; Future getUserInfo(String id){ ... //获取用户信息 }; Future saveUserInfo(String userInfo){ ... // 保存用户信息 }; 接下来，执行整个任务流： login(\"alice\",\"******\").then((id){ //登录成功后通过，id获取用户信息 getUserInfo(id).then((userInfo){ //获取用户信息后保存 saveUserInfo(userInfo).then((){ //保存用户信息，接下来执行其它操作 ... }); }); }) 可以感受一下，如果业务逻辑中有大量异步依赖的情况，将会出现上面这种在回调里面套回调的情况，过多的嵌套会导致的代码可读性下降以及出错率提高，并且非常难维护，这个问题被形象的称为回调地狱（Callback Hell）。回调地狱问题在之前JavaScript中非常突出，也是JavaScript被吐槽最多的点，但随着ECMAScript6和ECMAScript7标准发布后，这个问题得到了非常好的解决，而解决回调地狱的两大神器正是ECMAScript6引入了Promise，以及ECMAScript7中引入的async/await。 而在Dart中几乎是完全平移了JavaScript中的这两者：Future相当于Promise，而async/await连名字都没改。接下来我们看看通过Future和async/await如何消除上面示例中的嵌套问题。 使用Future消除Callback Hell login(\"alice\",\"******\").then((id){ return getUserInfo(id); }).then((userInfo){ return saveUserInfo(userInfo); }).then((e){ //执行接下来的操作 }).catchError((e){ //错误处理 print(e); }); 正如上文所述， “Future 的所有API的返回值仍然是一个Future对象，所以可以很方便的进行链式调用” ，如果在then中返回的是一个Future的话，该future会执行，执行结束后会触发后面的then回调，这样依次向下，就避免了层层嵌套。 使用async/await消除callback hell 通过Future回调中再返回Future的方式虽然能避免层层嵌套，但是还是有一层回调，有没有一种方式能够让我们可以像写同步代码那样来执行异步任务而不使用回调的方式？答案是肯定的，这就要使用async/await了，下面我们先直接看代码，然后再解释，代码如下： task() async { try{ String id = await login(\"alice\",\"******\"); String userInfo = await getUserInfo(id); await saveUserInfo(userInfo); //执行接下来的操作 } catch(e){ //错误处理 print(e); } } async用来表示函数是异步的，定义的函数会返回一个Future对象，可以使用then方法添加回调函数。 await 后面是一个Future，表示等待该异步任务完成，异步完成后才会往下走；await必须出现在 async 函数内部。 可以看到，我们通过async/await将一个异步流用同步的代码表示出来了。 其实，无论是在JavaScript还是Dart中，async/await都只是一个语法糖，编译器或解释器最终都会将其转化为一个Promise（Future）的调用链。 1.4.4 Stream Stream 也是用于接收异步事件数据，和Future 不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。 Stream 常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子： Stream.fromFutures([ // 1秒后返回结果 Future.delayed(new Duration(seconds: 1), () { return \"hello 1\"; }), // 抛出一个异常 Future.delayed(new Duration(seconds: 2),(){ throw AssertionError(\"Error\"); }), // 3秒后返回结果 Future.delayed(new Duration(seconds: 3), () { return \"hello 3\"; }) ]).listen((data){ print(data); }, onError: (e){ print(e.message); },onDone: (){ }); 上面的代码依次会输出： I/flutter (17666): hello 1 I/flutter (17666): Error I/flutter (17666): hello 3 代码很简单，就不赘述了。 思考题：既然Stream可以接收多次事件，那能不能用Stream来实现一个订阅者模式的事件总线？ 1.4.5 Dart和Java及JavaScript对比 通过上面介绍，相信你对Dart应该有了一个初步的印象，由于笔者平时也使用Java和JavaScript，下面笔者根据自己的经验，结合Java和JavaScript，谈一下自己的看法。 之所以将Dart与Java和JavaScript对比，是因为，这两者分别是强类型语言和弱类型语言的典型代表，并且Dart 语法中很多地方也都借鉴了Java和JavaScript。 Dart vs Java 客观的来讲，Dart在语法层面确实比Java更有表现力；在VM层面，Dart VM在内存回收和吞吐量都进行了反复的优化，但具体的性能对比，笔者没有找到相关测试数据，但在笔者看来，只要Dart语言能流行，VM的性能就不用担心，毕竟Google在Go（没用VM但有GC）、JavaScript（v8）、Dalvik（Android上的Java VM）上已经有了很多技术积淀。值得注意的是Dart在Flutter中已经可以将GC做到10ms以内，所以Dart和Java相比，决胜因素并不会是在性能方面。而在语法层面，Dart要比Java更有表现力，最重要的是Dart对函数式编程支持要远强于Java(目前只停留在Lambda表达式)，而Dart目前真正的不足是生态，但笔者相信，随着Flutter的逐渐火热，会回过头来反推Dart生态加速发展，对于Dart来说，现在需要的是时间。 Dart vs JavaScript JavaScript的弱类型一直被抓短，所以TypeScript、CoffeeScript甚至是Facebook的flow（虽然并不能算JavaScript的一个超集，但也通过标注和打包工具提供了静态类型检查）才有市场。就笔者使用过的脚本语言中（笔者曾使用过Python、PHP），JavaScript无疑是动态化支持最好的脚本语言，比如在JavaScript中，可以给任何对象在任何时候动态扩展属性，对于精通JavaScript的高手来说，这无疑是一把利剑。但是，任何事物都有两面性，JavaScript的强大的动态化特性也是把双刃剑，你可经常听到另一个声音，认为JavaScript的这种动态性糟糕透了，太过灵活反而导致代码很难预期，无法限制不被期望的修改。毕竟有些人总是对自己或别人写的代码不放心，他们希望能够让代码变得可控，并期望有一套静态类型检查系统来帮助自己减少错误。正因如此，在Flutter中，Dart几乎放弃了脚本语言动态化的特性，如不支持反射、也不支持动态创建函数等。并且Dart在2.0强制开启了类型检查（Strong Mode），原先的检查模式（checked mode）和可选类型（optional type）将淡出，所以在类型安全这个层面来说，Dart和TypeScript、CoffeeScript是差不多的，所以单从这一点来看，Dart并不具备什么明显优势，但综合起来看，Dart既能进行服务端脚本、APP开发、web开发，这就有优势了！ 综上所述，笔者还是很看好Dart语言的将来，之所以表这个态，是因为在新技术发展初期，很多人可能还有所摇摆，有所犹豫，所以有必要给大家打一剂强心针，当然，这是一个见仁见智的问题，大家可以各抒己见。 "},"chapter2/":{"url":"chapter2/","title":"第二章：第一个Flutter应用","keywords":"","body":"简介 本章将通过一些简单的示例来一步步介绍Flutter的开发流程. 本章目录 2.1：计数器示例 2.2：路由管理 2.3：包管理 2.4：资源管理 2.5：调试Flutter APP 2.6：Dart线程模型及异常捕获 "},"chapter2/first_flutter_app.html":{"url":"chapter2/first_flutter_app.html","title":"2.1：计数器示例","keywords":"","body":"2.1 计数器应用示例 用Android Studio和VS Code创建的Flutter应用模板默认是一个简单的计数器示例。本节先仔细讲解一下这个计数器Demo的源码，让读者对Flutter应用程序结构有个基本了解，然后在随后的小节中将会基于此示例，一步一步添加一些新的功能来介绍Flutter应用的其它概念与技术。 对于接下来的示例，希望读者可以跟着笔者一起亲自动手来写一下，这样不仅可以加深印象，而且也会对介绍的概念与技术有一个真切的体会。如果你还不是很熟悉Dart语言或者没有移动开发经验，不用担心，只要你熟悉面向对象和基本编程概念（如变量、循环和条件控制），则可以完成本示例。 2.1.1 创建Flutter应用模板 通过Android Studio或VS Code创建一个新的Flutter工程，命名为\"first_flutter_app\"。创建好后，就会得到一个计数器应用的Demo。 注意，默认Demo示例可能随着编辑器Flutter插件的版本变化而变化，本例中会介绍计数器示例的全部代码，所以不会对本示例产生影响。 我们先运行创建的工程，效果如图2-1所示： 该计数器示例中，每点击一次右下角带“+”号的悬浮按钮，屏幕中央的数字就会加1。 在这个示例中，主要Dart代码是在 lib/main.dart 文件中，下面是它的源码： import 'package:flutter/material.dart'; void main() => runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), home: new MyHomePage(title: 'Flutter Demo Home Page'), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() => new _MyHomePageState(); } class _MyHomePageState extends State { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), body: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: [ new Text( 'You have pushed the button this many times:', ), new Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: new Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. ); } } 分析 导入包。 import 'package:flutter/material.dart'; 此行代码作用是导入了Material UI组件库。Material是一种标准的移动端和web端的视觉设计语言， Flutter默认提供了一套丰富的Material风格的UI组件。 应用入口。 void main() => runApp(MyApp()); 与C/C++、Java类似，Flutter 应用中main函数为应用程序的入口。main函数中调用了runApp 方法，它的功能是启动Flutter应用。runApp它接受一个Widget参数，在本示例中它是一个MyApp对象，MyApp()是Flutter应用的根组件。 main函数使用了(=>)符号，这是Dart中单行函数或方法的简写。 应用结构。 class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( //应用名称 title: 'Flutter Demo', theme: new ThemeData( //蓝色主题 primarySwatch: Colors.blue, ), //应用首页路由 home: new MyHomePage(title: 'Flutter Demo Home Page'), ); } } MyApp类代表Flutter应用，它继承了 StatelessWidget类，这也就意味着应用本身也是一个widget。 在Flutter中，大多数东西都是widget（后同”组件“或”部件“），包括对齐(alignment)、填充(padding)和布局(layout)等，它们都是以widget的形式提供。 Flutter在构建页面时，会调用组件的build方法，widget的主要工作是提供一个build()方法来描述如何构建UI界面（通常是通过组合、拼装其它基础widget）。 MaterialApp 是Material库中提供的Flutter APP框架，通过它可以设置应用的名称、主题、语言、首页及路由列表等。MaterialApp也是一个widget。 Scaffold 是Material库中提供的页面脚手架，它包含导航栏和Body以及FloatingActionButton（如果需要的话）。 本书后面示例中，路由默认都是通过Scaffold创建。 home 为Flutter应用的首页，它也是一个widget。 2.1.2 首页 class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() => new _MyHomePageState(); } class _MyHomePageState extends State { ... } MyHomePage 是Flutter应用的首页，它继承自StatefulWidget类，表示它是一个有状态的组件（Stateful widget）。关于Stateful widget我们将在第三章”Widget简介“一节自习介绍，现在我们只需简单认为有状态的组件（Stateful widget） 和无状态的组件（Stateless widget）有两点不同： Stateful widget可以拥有状态，这些状态在widget生命周期中是可以变的，而Stateless widget是不可变的。 Stateful widget至少由两个类组成： 一个StatefulWidget类。 一个 State类； StatefulWidget类本身是不变的，但是State类中持有的状态在widget生命周期中可能会发生变化。 _MyHomePageState类是MyHomePage类对应的状态类。看到这里，读者可能已经发现：和MyApp 类不同， MyHomePage类中并没有build方法，取而代之的是，build方法被挪到了_MyHomePageState方法中，至于为什么这么做，先留个疑问，在分析完完整代码后再来解答。 State类 接下来，我们看看_MyHomePageState中都包含哪些东西： 该组件的状态。由于我们只需要维护一个点击次数计数器，所以定义一个_counter状态： int _counter = 0; //用于记录按钮点击的总次数 _counter 为保存屏幕右下角带“+”号按钮点击次数的状态。 设置状态的自增函数。 void _incrementCounter() { setState(() { _counter++; }); } 当按钮点击时，会调用此函数，该函数的作用是先自增_counter，然后调用setState 方法。setState方法的作用是通知Flutter框架，有状态发生了改变，Flutter框架收到通知后，会执行build方法来根据新的状态重新构建界面， Flutter 对此方法做了优化，使重新执行变的很快，所以你可以重新构建任何需要更新的东西，而无需分别去修改各个widget。 构建UI界面 构建UI界面的逻辑在build方法中，当MyHomePage第一次创建时，_MyHomePageState类会被创建，当初始化完成后，Flutter框架会调用Widget的build方法来构建widget树，最终将widget树渲染到设备屏幕上。所以，我们看看_MyHomePageState的build方法中都干了什么事： Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(widget.title), ), body: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.center, children: [ new Text( 'You have pushed the button this many times:', ), new Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: new Icon(Icons.add), ), ); } Scaffold 是 Material组件库中提供的一个组件，它提供了默认的导航栏、标题和包含主屏幕widget树（后同”组件树“或”部件树“）的body属性。组件树可以很复杂。 body的组件树中包含了一个Center 组件，Center 可以将其子组件树对齐到屏幕中心。此例中， Center 子组件是一个Column 组件，Column的作用是将其所有子组件沿屏幕垂直方向依次排列； 此例中Column子组件是两个 Text，第一个Text 显示固定文本 “You have pushed the button this many times:”，第二个Text 显示_counter状态的数值。 floatingActionButton是页面右下角的带“+”的悬浮按钮，它的onPressed属性接受一个回调函数，代表它被点击后的处理器，本例中直接将_incrementCounter方法作为其处理函数。 现在，我们将整个计数器执行流程串起来：当右下角的floatingActionButton按钮被点击之后，会调用_incrementCounter方法。在_incrementCounter方法中，首先会自增_counter计数器（状态），然后setState会通知Flutter框架状态发生变化，接着，Flutter框架会调用build方法以新的状态重新构建UI，最终显示在设备屏幕上。 为什么要将build方法放在State中，而不是放在StatefulWidget中？ 现在，我们回答之前提出的问题，为什么build()方法放在State（而不是StatefulWidget）中 ？这主要是为了提高开发的灵活性。如果将build()方法在StatefulWidget中则会有两个问题： 状态访问不便 试想一下，如果我们的StatefulWidget有很多状态，而每次状态改变都要调用build方法，由于状态是保存在State中的，如果build方法在StatefulWidget中，那么build方法和状态分别在两个类中，那么构建时读取状态将会很不方便！试想一下，如果真的将build方法放在StatefulWidget中的话，由于构建用户界面过程需要依赖State，所以build方法将必须加一个State参数，大概是下面这样： Widget build(BuildContext context, State state){ //state.counter ... } 这样的话就只能将State的所有状态声明为公开的状态，这样才能在State类外部访问状态！但是，将状态设置为公开后，状态将不再具有私密性，这就会导致对状态的修改将会变的不可控。但如果将build()方法放在State中的话，构建过程不仅可以直接访问状态，而且也无需公开私有状态，这会非常方便。 继承StatefulWidget不便 例如，Flutter中有一个动画widget的基类AnimatedWidget，它继承自StatefulWidget类。AnimatedWidget中引入了一个抽象方法build(BuildContext context)，继承自AnimatedWidget的动画widget都要实现这个build方法。现在设想一下，如果StatefulWidget 类中已经有了一个build方法，正如上面所述，此时build方法需要接收一个state对象，这就意味着AnimatedWidget必须将自己的State对象(记为_animatedWidgetState)提供给其子类，因为子类需要在其build方法中调用父类的build方法，代码可能如下： class MyAnimationWidget extends AnimatedWidget{ @override Widget build(BuildContext context, State state){ //由于子类要用到AnimatedWidget的状态对象_animatedWidgetState， //所以AnimatedWidget必须通过某种方式将其状态对象_animatedWidgetState //暴露给其子类 super.build(context, _animatedWidgetState) } } 这样很显然是不合理的，因为 AnimatedWidget的状态对象是AnimatedWidget内部实现细节，不应该暴露给外部。 如果要将父类状态暴露给子类，那么必须得有一种传递机制，而做这一套传递机制是无意义的，因为父子类之间状态的传递和子类本身逻辑是无关的。 综上所述，可以发现，对于StatefulWidget，将build方法放在State中，可以给开发带来很大的灵活性。 "},"chapter2/flutter_router.html":{"url":"chapter2/flutter_router.html","title":"2.2：路由管理","keywords":"","body":"2.2 路由管理 路由(Route)在移动开发中通常指页面（Page），这跟web开发中单页应用的Route概念意义是相同的，Route在Android中通常指一个Activity，在iOS中指一个ViewController。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。Flutter中的路由管理和原生开发类似，无论是Android还是iOS，导航管理都会维护一个路由栈，路由入栈(push)操作对应打开一个新页面，路由出栈(pop)操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。 2.2.1 一个简单示例 我们在上一节“计数器”示例的基础上，做如下修改： 创建一个新路由，命名“NewRoute” class NewRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"New route\"), ), body: Center( child: Text(\"This is new route\"), ), ); } } 新路由继承自StatelessWidget，界面很简单，在页面中间显示一句\"This is new route\"。 在_MyHomePageState.build方法中的Column的子widget中添加一个按钮（FlatButton） : Column( mainAxisAlignment: MainAxisAlignment.center, children: [ ... //省略无关代码 FlatButton( child: Text(\"open new route\"), textColor: Colors.blue, onPressed: () { //导航到新路由 Navigator.push( context, MaterialPageRoute(builder: (context) { return NewRoute(); })); }, ), ], ) 我们添加了一个打开新路由的按钮，并将按钮文字颜色设置为蓝色，点击该按钮后就会打开新的路由页面，效果如图2-2和2-3所示。 2.2.2 MaterialPageRoute MaterialPageRoute继承自PageRoute类，PageRoute类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。MaterialPageRoute 是Material组件库提供的组件，它可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画： 对于Android，当打开新页面时，新的页面会从屏幕底部滑动到屏幕顶部；当关闭页面时，当前页面会从屏幕顶部滑动到屏幕底部后消失，同时上一个页面会显示到屏幕上。 对于iOS，当打开页面时，新的页面会从屏幕右侧边缘一致滑动到屏幕左边，直到新页面全部显示到屏幕上，而上一个页面则会从当前屏幕滑动到屏幕左侧而消失；当关闭页面时，正好相反，当前页面会从屏幕右侧滑出，同时上一个页面会从屏幕左侧滑入。 下面我们介绍一下MaterialPageRoute 构造函数的各个参数的意义： MaterialPageRoute({ WidgetBuilder builder, RouteSettings settings, bool maintainState = true, bool fullscreenDialog = false, }) builder 是一个WidgetBuilder类型的回调函数，它的作用是构建路由页面的具体内容，返回值是一个widget。我们通常要实现此回调，返回新路由的实例。 settings 包含路由的配置信息，如路由名称、是否初始路由（首页）。 maintainState：默认情况下，当入栈一个新路由时，原来的路由仍然会被保存在内存中，如果想在路由没用的时候释放其所占用的所有资源，可以设置maintainState为false。 fullscreenDialog表示新的路由页面是否是一个全屏的模态对话框，在iOS中，如果fullscreenDialog为true，新页面将会从屏幕底部滑入（而不是水平方向）。 如果想自定义路由切换动画，可以自己继承PageRoute来实现，我们将在后面介绍动画时，实现一个自定义的路由组件。 2.2.3 Navigator Navigator是一个路由管理的组件，它提供了打开和退出路由页方法。Navigator通过一个栈来管理活动路由集合。通常当前屏幕显示的页面就是栈顶的路由。Navigator提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法： Future push(BuildContext context, Route route) 将给定的路由入栈（即打开新的页面），返回值是一个Future对象，用以接收新路由出栈（即关闭）时的返回数据。 bool pop(BuildContext context, [ result ]) 将栈顶路由出栈，result为页面关闭时返回给上一个页面的数据。 Navigator 还有很多其它方法，如Navigator.replace、Navigator.popUntil等，详情请参考API文档或SDK源码注释，在此不再赘述。下面我们还需要介绍一下路由相关的另一个概念“命名路由”。 实例方法 Navigator类中第一个参数为context的静态方法都对应一个Navigator的实例方法， 比如Navigator.push(BuildContext context, Route route)等价于Navigator.of(context).push(Route route) ，下面命名路由相关的方法也是一样的。 2.2.4 路由传值 很多时候，在路由跳转时我们需要带一些参数，比如打开商品详情页时，我们需要带一个商品id，这样商品详情页才知道展示哪个商品信息；又比如我们在填写订单时需要选择收获地址，打开地址选择页后，可以将用户选择的地址返回到订单页等等。下面我们通过一个简单的示例来演示新旧路由如何传参。 示例 我们创建一个TipRoute路由，它接受一个提示文本参数，负责将传入它的文本显示在页面上，另外TipRoute中我们添加一个“返回”按钮，点击后在返回上一个路由的同时会带上一个返回参数，下面我们看一下实现代码。 TipRoute实现代码： class TipRoute extends StatelessWidget { TipRoute({ Key key, @required this.text, // 接收一个text参数 }) : super(key: key); final String text; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"提示\"), ), body: Padding( padding: EdgeInsets.all(18), child: Center( child: Column( children: [ Text(text), RaisedButton( onPressed: () => Navigator.pop(context, \"我是返回值\"), child: Text(\"返回\"), ) ], ), ), ), ); } } 下面是打开新路由TipRoute的代码： class RouterTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Center( child: RaisedButton( onPressed: () async { // 打开`TipRoute`，并等待返回结果 var result = await Navigator.push( context, MaterialPageRoute( builder: (context) { return TipRoute( // 路由参数 text: \"我是提示xxxx\", ); }, ), ); //输出`TipRoute`路由返回结果 print(\"路由返回值: $result\"); }, child: Text(\"打开提示页\"), ), ); } } 运行上面代码，点击RouterTestRoute页的”打开提示页“按钮，会打开TipRoute页，运行效果如图2-4所示下： 需要说明： 提示文案”我是提示xxxx“是通过TipRoute的text参数传递给新路由页的。我们可以通过等待Navigator.push(…)返回的Future来获取新路由的返回数据。 在TipRoute页中有两种方式可以返回到上一页；第一种方式时直接点击导航栏返回箭头，第二种方式是点击页面中的”返回“按钮。这两种返回方式的区别是前者不会返回数据给上一个路由，而后者会。下面是分别点击页面中的返回按钮和导航栏返回箭头后，RouterTestRoute页中print方法在控制台输出的内容： I/flutter (27896): 路由返回值: 我是返回值 I/flutter (27896): 路由返回值: null 上面介绍的是非命名路由的传值方式，命名路由的传值方式会有所不同，我们会在下面介绍命名路由时介绍。 2.2.5 命名路由 所谓”命名路由“（Named Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。 路由表 要想使用命名路由，我们必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名字与哪个路由组件相对应。其实注册路由表就是给路由起名字，路由表的定义如下： Map routes; 它是一个Map，key为路由的名字，是个字符串；value是个builder回调函数，用于生成相应的路由widget。我们在通过路由名字打开新路由时，应用会根据路由名字在路由表中查找到对应的WidgetBuilder回调函数，然后调用该回调函数生成路由widget并返回。 注册路由表 路由表的注册方式很简单，我们回到之前“计数器”的示例，然后在MyApp类的build方法中找到MaterialApp，添加routes属性，代码如下： MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), //注册路由表 routes:{ \"new_page\":(context)=>NewRoute(), ... // 省略其它路由注册信息 } , home: MyHomePage(title: 'Flutter Demo Home Page'), ); 现在我们就完成了路由表的注册。上面的代码中home路由并没有使用命名路由，如果我们也想将home注册为命名路由应该怎么做呢？其实很简单，直接看代码： MaterialApp( title: 'Flutter Demo', initialRoute:\"/\", //名为\"/\"的路由作为应用的home(首页) theme: ThemeData( primarySwatch: Colors.blue, ), //注册路由表 routes:{ \"new_page\":(context)=>NewRoute(), \"/\":(context)=> MyHomePage(title: 'Flutter Demo Home Page'), //注册首页路由 } ); 可以看到，我们只需在路由表中注册一下MyHomePage路由，然后将其名字作为MaterialApp的initialRoute属性值即可，该属性决定应用的初始路由页是哪一个命名路由。 通过路由名打开新路由页 要通过路由名称来打开新路由，可以使用Navigator 的pushNamed方法： Future pushNamed(BuildContext context, String routeName,{Object arguments}) Navigator 除了pushNamed方法，还有pushReplacementNamed等其他管理命名路由的方法，读者可以自行查看API文档。接下来我们通过路由名来打开新的路由页，修改FlatButton的onPressed回调代码，改为： onPressed: () { Navigator.pushNamed(context, \"new_page\"); //Navigator.push(context, // new MaterialPageRoute(builder: (context) { // return new NewRoute(); //})); }, 热重载应用，再次点击“open new route”按钮，依然可以打开新的路由页。 命名路由参数传递 在Flutter最初的版本中，命名路由是不能传递参数的，后来才支持了参数；下面展示命名路由如何传递并获取路由参数： 我们先注册一个路由： routes:{ \"new_page\":(context)=>EchoRoute(), } , 在路由页通过RouteSetting对象获取路由参数： class EchoRoute extends StatelessWidget { @override Widget build(BuildContext context) { //获取路由参数 var args=ModalRoute.of(context).settings.arguments //...省略无关代码 } } 在打开路由时传递参数 Navigator.of(context).pushNamed(\"new_page\", arguments: \"hi\"); 适配 假设我们也想将上面路由传参示例中的TipRoute路由页注册到路由表中，以便也可以通过路由名来打开它。但是，由于TipRoute接受一个text 参数，我们如何在不改变TipRoute源码的前提下适配这种情况？其实很简单： MaterialApp( ... //省略无关代码 routes: { \"tip2\": (context){ return TipRoute(text: ModalRoute.of(context).settings.arguments); }, }, ); 2.2.6 路由生成钩子 假设我们要开发一个电商APP，当用户没有登录时可以看店铺、商品等信息，但交易记录、购物车、用户个人信息等页面需要登录后才能看。为了实现上述功能，我们需要在打开每一个路由页前判断用户登录状态！如果每次打开路由前我们都需要去判断一下将会非常麻烦，那有什么更好的办法吗？答案是有！ MaterialApp有一个onGenerateRoute属性，它在打开命名路由时会可能会被调用，之所以说可能，是因为当调用Navigator.pushNamed(...)打开命名路由时，如果指定的路由名在路由表中已注册，则会调用路由表中的builder函数来生成路由组件；如果路由表中没有注册，才会调用onGenerateRoute来生成路由。onGenerateRoute回调签名如下： Route Function(RouteSettings settings) 有了onGenerateRoute回调，要实现上面控制页面权限的功能就非常容易：我们放弃使用路由表，取而代之的是提供一个onGenerateRoute回调，然后在该回调中进行统一的权限控制，如： MaterialApp( ... //省略无关代码 onGenerateRoute:(RouteSettings settings){ return MaterialPageRoute(builder: (context){ String routeName = settings.name; // 如果访问的路由页需要登录，但当前未登录，则直接返回登录页路由， // 引导用户登录；其它情况则正常打开路由。 } ); } ); 注意，onGenerateRoute只会对命名路由生效。 2.2.7 总结 本章先介绍了Flutter中路由管理、传参的方式，然后又着重介绍了命名路由相关内容。在此需要说明一点，由于命名路由只是一种可选的路由管理方式，在实际开发中，读者可能心中会犹豫到底使用哪种路由管理方式。在此，根据笔者经验，建议读者最好统一使用命名路由的管理方式，这将会带来如下好处： 语义化更明确。 代码更好维护；如果使用匿名路由，则必须在调用Navigator.push的地方创建新路由页，这样不仅需要import新路由页的dart文件，而且这样的代码将会非常分散。 可以通过onGenerateRoute做一些全局的路由跳转前置处理逻辑。 综上所述，笔者比较建议使用命名路由，当然这并不是什么金科玉律，读者可以根据自己偏好或实际情况来决定。 另外，还有一些关于路由管理的内容我们没有介绍，比如路由MaterialApp中还有navigatorObservers和onUnknownRoute两个回调属性，前者可以监听所有路由跳转动作，后者在打开一个不存在的命名路由时会被调用，由于这些功能并不常用，而且也比较简单，我们便不再花费篇幅来介绍了，读者可以自行查看API文档。 "},"chapter2/flutter_package_mgr.html":{"url":"chapter2/flutter_package_mgr.html","title":"2.3：包管理","keywords":"","body":"2.3 包管理 在软件开放，很多时候有一些公共的库或SDK可能会被很多项目用到，因此，将这些代码单独抽到一个独立模块，然后哪个项目需要使用时再直接集成这个模块，便可大大提高开发效率。很多编程语言或开发工具都支持这种“模块共享”机制，如Java语言中这种独立模块会被打成一个jar包，Android中的aar包，Web开发中的npm包等。为了方便表述，我们将这种可共享的独立模块统一称为“包”（ Package）。 一个APP在实际开发中往往会依赖很多包，而这些包通常都有交叉依赖关系、版本依赖等，如果由开发者手动来管理应用中的依赖包将会非常麻烦。因此，各种开发生态或编程语言官方通常都会提供一些包管理工具，比如在Android提供了Gradle来管理依赖，iOS用Cocoapods或Carthage来管理依赖，Node中通过npm等。而在Flutter开发中也有自己的包管理工具。本节我们主要介绍一下flutter如何使用配置文件pubspec.yaml（位于项目根目录）来管理第三方依赖包。 YAML是一种直观、可读性高并且容易被人类阅读的文件格式，它和xml或Json相比，它语法简单并非常容易解析，所以YAML常用于配置文件，Flutter也是用yaml文件作为其配置文件。Flutter项目默认的配置文件是pubspec.yaml，我们看一个简单的示例： name: flutter_in_action description: First Flutter application. version: 1.0.0+1 dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.2 dev_dependencies: flutter_test: sdk: flutter flutter: uses-material-design: true 下面，我们逐一解释一下各个字段的意义： name：应用或包名称。 description: 应用或包的描述、简介。 version：应用或包的版本号。 dependencies：应用或包依赖的其它包或插件。 dev_dependencies：开发环境依赖的工具包（而不是flutter应用本身依赖的包）。 flutter：flutter相关的配置选项。 如果我们的Flutter应用本身依赖某个包，我们需要将所依赖的包添加到dependencies 下，接下来我们通过一个例子来演示一下如何添加、下载并使用第三方包。 Pub仓库 Pub（https://pub.dartlang.org/ ）是Google官方的Dart Packages仓库，类似于node中的npm仓库，android中的jcenter。我们可以在Pub上面查找我们需要的包和插件，也可以向Pub发布我们的包和插件。我们将在后面的章节中介绍如何向Pub发布我们的包和插件。 示例 接下来，我们实现一个显示随机字符串的widget。有一个名为“english_words”的开源软件包，其中包含数千个常用的英文单词以及一些实用功能。我们首先在pub上找到english_words这个包（如图2-5所示），确定其最新的版本号和是否支持Flutter。 我们看到“english_words”包最新的版本是3.1.3，并且支持flutter，接下来： 将“english_words”（3.1.3版本）添加到依赖项列表，如下： dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.0 # 新添加的依赖 english_words: ^3.1.3 下载包。在Android Studio的编辑器视图中查看pubspec.yaml时（图2-6），单击右上角的 Packages get 。 这会将依赖包安装到您的项目。我们可以在控制台中看到以下内容： flutter packages get Running \"flutter packages get\" in flutter_in_action... Process finished with exit code 0 我们也可以在控制台，定位到当前工程目录，然后手动运行flutter packages get 命令来下载依赖包。另外，需要注意dependencies和dev_dependencies的区别，前者的依赖包将作为APP的源码的一部分参与编译，生成最终的安装包。而后者的依赖包只是作为开发阶段的一些工具包，主要是用于帮助我们提高开发、测试效率，比如flutter的自动化测试包等。 引入english_words包。 import 'package:english_words/english_words.dart'; 在输入时，Android Studio会自动提供有关库导入的建议选项。导入后该行代码将会显示为灰色，表示导入的库尚未使用。 使用english_words包来生成随机字符串。 class RandomWordsWidget extends StatelessWidget { @override Widget build(BuildContext context) { // 生成随机字符串 final wordPair = new WordPair.random(); return Padding( padding: const EdgeInsets.all(8.0), child: new Text(wordPair.toString()), ); } } 我们将RandomWordsWidget 添加到 _MyHomePageState.build 的Column的子widget中。 Column( mainAxisAlignment: MainAxisAlignment.center, children: [ ... //省略无关代码 RandomWordsWidget(), ], ) 如果应用程序正在运行，请使用热重载按钮（⚡️图标） 更新正在运行的应用程序。每次单击热重载或保存项目时，都会在正在运行的应用程序中随机选择不同的单词对。 这是因为单词对是在 build 方法内部生成的。每次热更新时，build方法都会被执行，运行效果如图2-7所示。 其它依赖方式 上文所述的依赖方式是依赖Pub仓库的。但我们还可以依赖本地包和git仓库。 依赖本地包 如果我们正在本地开发一个包，包名为pkg1，我们可以通过下面方式依赖： dependencies: pkg1: path: ../../code/pkg1 路径可以是相对的，也可以是绝对的。 依赖Git：你也可以依赖存储在Git仓库中的包。如果软件包位于仓库的根目录中，请使用以下语法 dependencies: pkg1: git: url: git://github.com/xxx/pkg1.git 上面假定包位于Git存储库的根目录中。如果不是这种情况，可以使用path参数指定相对位置，例如： dependencies: package1: git: url: git://github.com/flutter/packages.git path: packages/package1 上面介绍的这些依赖方式是Flutter开发中常用的，但还有一些其它依赖方式，完整的内容读者可以自行查看：https://www.dartlang.org/tools/pub/dependencies 。 总结 本节介绍了Flutter中包管理、引用、下载的整体流程，我们将在后面的章节中介绍如果开发并发布我们自己的包。 "},"chapter2/flutter_assets_mgr.html":{"url":"chapter2/flutter_assets_mgr.html","title":"2.4：资源管理","keywords":"","body":"2.4 资源管理 Flutter APP安装包中会包含代码和 assets（资源）两部分。Assets是会打包到程序安装包中的，可在运行时访问。常见类型的assets包括静态数据（例如JSON文件）、配置文件、图标和图片（JPEG，WebP，GIF，动画WebP / GIF，PNG，BMP和WBMP）等。 指定 assets 和包管理一样，Flutter也使用pubspec.yaml文件来管理应用程序所需的资源，举个例子: flutter: assets: - assets/my_icon.png - assets/background.png assets指定应包含在应用程序中的文件， 每个asset都通过相对于pubspec.yaml文件所在的文件系统路径来标识自身的路径。asset的声明顺序是无关紧要的，asset的实际目录可以是任意文件夹（在本示例中是assets文件夹）。 在构建期间，Flutter将asset放置到称为 asset bundle 的特殊存档中，应用程序可以在运行时读取它们（但不能修改）。 Asset 变体（variant） 构建过程支持“asset变体”的概念：不同版本的asset可能会显示在不同的上下文中。 在pubspec.yaml的assets部分中指定asset路径时，构建过程中，会在相邻子目录中查找具有相同名称的任何文件。这些文件随后会与指定的asset一起被包含在asset bundle中。 例如，如果应用程序目录中有以下文件: …/pubspec.yaml …/graphics/my_icon.png …/graphics/background.png …/graphics/dark/background.png …etc. 然后pubspec.yaml文件中只需包含: flutter: assets: - graphics/background.png 那么这两个graphics/background.png和graphics/dark/background.png 都将包含在您的asset bundle中。前者被认为是main asset （主资源），后者被认为是一种变体（variant）。 在选择匹配当前设备分辨率的图片时，Flutter会使用到asset变体（见下文），将来，Flutter可能会将这种机制扩展到本地化、阅读提示等方面。 加载 assets 您的应用可以通过AssetBundle对象访问其asset 。有两种主要方法允许从Asset bundle中加载字符串或图片（二进制）文件。 加载文本assets 通过rootBundle 对象加载：每个Flutter应用程序都有一个rootBundle对象， 通过它可以轻松访问主资源包，直接使用package:flutter/services.dart中全局静态的rootBundle对象来加载asset即可。 通过 DefaultAssetBundle 加载：建议使用 DefaultAssetBundle 来获取当前BuildContext的AssetBundle。 这种方法不是使用应用程序构建的默认asset bundle，而是使父级widget在运行时动态替换的不同的AssetBundle，这对于本地化或测试场景很有用。 通常，可以使用DefaultAssetBundle.of()在应用运行时来间接加载asset（例如JSON文件），而在widget上下文之外，或其它AssetBundle句柄不可用时，可以使用rootBundle直接加载这些asset，例如： import 'dart:async' show Future; import 'package:flutter/services.dart' show rootBundle; Future loadAsset() async { return await rootBundle.loadString('assets/config.json'); } 加载图片 类似于原生开发，Flutter也可以为当前设备加载适合其分辨率的图像。 声明分辨率相关的图片 assets AssetImage 可以将asset的请求逻辑映射到最接近当前设备像素比例（dpi）的asset。为了使这种映射起作用，必须根据特定的目录结构来保存asset： …/image.png …/Mx/image.png …/Nx/image.png …etc. 其中M和N是数字标识符，对应于其中包含的图像的分辨率，也就是说，它们指定不同设备像素比例的图片。 主资源默认对应于1.0倍的分辨率图片。看一个例子： …/my_icon.png …/2.0x/my_icon.png …/3.0x/my_icon.png 在设备像素比率为1.8的设备上，.../2.0x/my_icon.png 将被选择。对于2.7的设备像素比率，.../3.0x/my_icon.png将被选择。 如果未在Image widget上指定渲染图像的宽度和高度，那么Image widget将占用与主资源相同的屏幕空间大小。 也就是说，如果.../my_icon.png是72px乘72px，那么.../3.0x/my_icon.png应该是216px乘216px; 但如果未指定宽度和高度，它们都将渲染为72像素×72像素（以逻辑像素为单位）。 pubspec.yaml中asset部分中的每一项都应与实际文件相对应，但主资源项除外。当主资源缺少某个资源时，会按分辨率从低到高的顺序去选择 ，也就是说1x中没有的话会在2x中找，2x中还没有的话就在3x中找。 加载图片 要加载图片，可以使用 AssetImage类。例如，我们可以从上面的asset声明中加载背景图片： Widget build(BuildContext context) { return new DecoratedBox( decoration: new BoxDecoration( image: new DecorationImage( image: new AssetImage('graphics/background.png'), ), ), ); } 注意，AssetImage 并非是一个widget， 它实际上是一个ImageProvider，有些时候你可能期望直接得到一个显示图片的widget，那么你可以使用Image.asset()方法，如： Widget build(BuildContext context) { return Image.asset('graphics/background.png'); } 使用默认的 asset bundle 加载资源时，内部会自动处理分辨率等，这些处理对开发者来说是无感知的。 (如果使用一些更低级别的类，如 ImageStream或 ImageCache 时你会注意到有与缩放相关的参数) 依赖包中的资源图片 要加载依赖包中的图像，必须给AssetImage提供package参数。 例如，假设您的应用程序依赖于一个名为“my_icons”的包，它具有如下目录结构： …/pubspec.yaml …/icons/heart.png …/icons/1.5x/heart.png …/icons/2.0x/heart.png …etc. 然后加载图像，使用: new AssetImage('icons/heart.png', package: 'my_icons') 或 new Image.asset('icons/heart.png', package: 'my_icons') 注意：包在使用本身的资源时也应该加上package参数来获取。 打包包中的 assets 如果在pubspec.yaml文件中声明了期望的资源，它将会打包到相应的package中。特别是，包本身使用的资源必须在pubspec.yaml中指定。 包也可以选择在其lib/文件夹中包含未在其pubspec.yaml文件中声明的资源。在这种情况下，对于要打包的图片，应用程序必须在pubspec.yaml中指定包含哪些图像。 例如，一个名为“fancy_backgrounds”的包，可能包含以下文件： …/lib/backgrounds/background1.png …/lib/backgrounds/background2.png …/lib/backgrounds/background3.png 要包含第一张图像，必须在pubspec.yaml的assets部分中声明它： flutter: assets: - packages/fancy_backgrounds/backgrounds/background1.png lib/是隐含的，所以它不应该包含在资产路径中。 特定平台 assets 上面的资源都是flutter应用中的，这些资源只有在Flutter框架运行之后才能使用，如果要给我们的应用设置APP图标或者添加启动图，那我们必须使用特定平台的assets。 设置APP图标 更新Flutter应用程序启动图标的方式与在本机Android或iOS应用程序中更新启动图标的方式相同。 Android 在Flutter项目的根目录中，导航到.../android/app/src/main/res目录，里面包含了各种资源文件夹（如mipmap-hdpi已包含占位符图像”ic_launcher.png”，见图2-8）。 只需按照Android开发人员指南中的说明， 将其替换为所需的资源，并遵守每种屏幕密度（dpi）的建议图标大小标准。 注意: 如果您重命名.png文件，则还必须在您AndroidManifest.xml的标签的android:icon属性中更新名称。 iOS 在Flutter项目的根目录中，导航到.../ios/Runner。该目录中Assets.xcassets/AppIcon.appiconset已经包含占位符图片（见图2-9）， 只需将它们替换为适当大小的图片，保留原始文件名称。 更新启动页 在Flutter框架加载时，Flutter会使用本地平台机制绘制启动页。此启动页将持续到Flutter渲染应用程序的第一帧时。 注意: 这意味着如果您不在应用程序的main()方法中调用runApp 函数 （或者更具体地说，如果您不调用window.render去响应window.onDrawFrame）的话， 启动屏幕将永远持续显示。 Android 要将启动屏幕（splash screen）添加到您的Flutter应用程序， 请导航至.../android/app/src/main。在res/drawable/launch_background.xml，通过自定义drawable来实现自定义启动界面（你也可以直接换一张图片）。 iOS 要将图片添加到启动屏幕（splash screen）的中心，请导航至.../ios/Runner。在Assets.xcassets/LaunchImage.imageset， 拖入图片，并命名为LaunchImage.png、LaunchImage@2x.png、LaunchImage@3x.png。 如果你使用不同的文件名，那您还必须更新同一目录中的Contents.json文件，图片的具体尺寸可以查看苹果官方的标准。 您也可以通过打开Xcode完全自定义storyboard。在Project Navigator中导航到Runner/Runner然后通过打开Assets.xcassets拖入图片，或者通过在LaunchScreen.storyboard中使用Interface Builder进行自定义，如图2-11所示。 "},"chapter2/flutter_app_debug.html":{"url":"chapter2/flutter_app_debug.html","title":"2.5：调试Flutter APP","keywords":"","body":"2.5 调试Flutter应用 有各种各样的工具和功能来帮助调试Flutter应用程序。 Dart 分析器 在运行应用程序前，请运行flutter analyze测试你的代码。这个工具是一个静态代码检查工具，它是dartanalyzer工具的一个包装，主要用于分析代码并帮助开发者发现可能的错误，比如，Dart分析器大量使用了代码中的类型注释来帮助追踪问题，避免var、无类型的参数、无类型的列表文字等。 如果你使用IntelliJ的Flutter插件，那么分析器在打开IDE时就已经自动启用了，如果读者使用的是其它IDE，强烈建议读者启用Dart 分析器，因为在大多数时候，Dart 分析器可以在代码运行前发现大多数问题。 Dart Observatory (语句级的单步调试和分析器) 如果我们使用flutter run启动应用程序，那么当它运行时，我们可以打开Observatory工具的Web页面，例如Observatory默认监听http://127.0.0.1:8100/，可以在浏览器中直接打开该链接。直接使用语句级单步调试器连接到您的应用程序。如果您使用的是IntelliJ，则还可以使用其内置的调试器来调试您的应用程序。 Observatory 同时支持分析、检查堆等。有关Observatory的更多信息请参考Observatory 文档. 如果您使用Observatory进行分析，请确保通过--profile选项来运行flutter run命令来运行应用程序。 否则，配置文件中将出现的主要问题将是调试断言，以验证框架的各种不变量（请参阅下面的“调试模式断言”）。 debugger() 声明 当使用Dart Observatory（或另一个Dart调试器，例如IntelliJ IDE中的调试器）时，可以使用该debugger()语句插入编程式断点。要使用这个，你必须添加import 'dart:developer';到相关文件顶部。 debugger()语句采用一个可选when参数，您可以指定该参数仅在特定条件为真时中断，如下所示： void someFunction(double offset) { debugger(when: offset > 30.0); // ... } print、debugPrint、flutter logs Dart print()功能将输出到系统控制台，您可以使用flutter logs了查看它（基本上是一个包装adb logcat）。 如果你一次输出太多，那么Android有时会丢弃一些日志行。为了避免这种情况，您可以使用Flutter的foundation库中的debugPrint()。 这是一个封装print，它将输出限制在一个级别，避免被Android内核丢弃。 Flutter框架中的许多类都有toString实现。按照惯例，这些输出通常包括对象的runtimeType单行输出，通常在表单中ClassName(more information about this instance…)。 树中使用的一些类也具有toStringDeep，从该点返回整个子树的多行描述。已一些具有详细信息toString的类会实现一个toStringShort，它只返回对象的类型或其他非常简短的（一个或两个单词）描述。 调试模式断言 在Flutter应用调试过程中，Dart assert语句被启用，并且Flutter框架使用它来执行许多运行时检查来验证是否违反一些不可变的规则。 当一个不可变的规则被违反时，它被报告给控制台，并带有一些上下文信息来帮助追踪问题的根源。 要关闭调试模式并使用发布模式，请使用flutter run --release运行您的应用程序。 这也关闭了Observatory调试器。一个中间模式可以关闭除Observatory之外所有调试辅助工具的，称为“profile mode”，用--profile替代--release即可。 调试应用程序层 Flutter框架的每一层都提供了将其当前状态或事件转储(dump)到控制台（使用debugPrint）的功能。 Widget 层 要转储Widgets库的状态，请调用debugDumpApp()。 只要应用程序已经构建了至少一次（即在调用build()之后的任何时间），您可以在应用程序未处于构建阶段（即，不在build()方法内调用 ）的任何时间调用此方法（在调用runApp()之后）。 如, 这个应用程序: import 'package:flutter/material.dart'; void main() { runApp( new MaterialApp( home: new AppHome(), ), ); } class AppHome extends StatelessWidget { @override Widget build(BuildContext context) { return new Material( child: new Center( child: new FlatButton( onPressed: () { debugDumpApp(); }, child: new Text('Dump App'), ), ), ); } } …会输出这样的内容（精确的细节会根据框架的版本、设备的大小等等而变化）： I/flutter ( 6559): WidgetsFlutterBinding - CHECKED MODE I/flutter ( 6559): RenderObjectToWidgetAdapter([GlobalObjectKey RenderView(497039273)]; renderObject: RenderView) I/flutter ( 6559): └MaterialApp(state: _MaterialAppState(1009803148)) I/flutter ( 6559): └ScrollConfiguration() I/flutter ( 6559): └AnimatedTheme(duration: 200ms; state: _AnimatedThemeState(543295893; ticker inactive; ThemeDataTween(ThemeData(Brightness.light Color(0xff2196f3) etc...) → null))) I/flutter ( 6559): └Theme(ThemeData(Brightness.light Color(0xff2196f3) etc...)) I/flutter ( 6559): └WidgetsApp([GlobalObjectKey _MaterialAppState(1009803148)]; state: _WidgetsAppState(552902158)) I/flutter ( 6559): └CheckedModeBanner() I/flutter ( 6559): └Banner() I/flutter ( 6559): └CustomPaint(renderObject: RenderCustomPaint) I/flutter ( 6559): └DefaultTextStyle(inherit: true; color: Color(0xd0ff0000); family: \"monospace\"; size: 48.0; weight: 900; decoration: double Color(0xffffff00) TextDecoration.underline) I/flutter ( 6559): └MediaQuery(MediaQueryData(size: Size(411.4, 683.4), devicePixelRatio: 2.625, textScaleFactor: 1.0, padding: EdgeInsets(0.0, 24.0, 0.0, 0.0))) I/flutter ( 6559): └LocaleQuery(null) I/flutter ( 6559): └Title(color: Color(0xff2196f3)) ... #省略剩余内容 这是一个“扁平化”的树，显示了通过各种构建函数投影的所有widget（如果你在widget树的根中调用toStringDeepwidget，这是你获得的树）。 你会看到很多在你的应用源代码中没有出现的widget，因为它们是被框架中widget的build()函数插入的。例如，InkFeature是Material widget的一个实现细节 。 当按钮从被按下变为被释放时debugDumpApp()被调用，FlatButton对象同时调用setState()，并将自己标记为\"dirty\"。 这就是为什么如果你看转储，你会看到特定的对象标记为“dirty”。您还可以查看已注册了哪些手势监听器; 在这种情况下，一个单一的GestureDetector被列出，并且监听“tap”手势（“tap”是TapGestureDetector的toStringShort函数输出的） 如果您编写自己的widget，则可以通过覆盖debugFillProperties()来添加信息。 将DiagnosticsProperty对象作为方法参数，并调用父类方法。 该函数是该toString方法用来填充小部件描述信息的。 渲染层 如果您尝试调试布局问题，那么Widgets层的树可能不够详细。在这种情况下，您可以通过调用debugDumpRenderTree()转储渲染树。 正如debugDumpApp()，除布局或绘制阶段外，您可以随时调用此函数。作为一般规则，从frame 回调 或事件处理器中调用它是最佳解决方案。 要调用debugDumpRenderTree()，您需要添加import'package:flutter/rendering.dart';到您的源文件。 上面这个小例子的输出结果如下所示： I/flutter ( 6559): RenderView I/flutter ( 6559): │ debug mode enabled - android I/flutter ( 6559): │ window size: Size(1080.0, 1794.0) (in physical pixels) I/flutter ( 6559): │ device pixel ratio: 2.625 (physical pixels per logical pixel) I/flutter ( 6559): │ configuration: Size(411.4, 683.4) at 2.625x (in logical pixels) I/flutter ( 6559): │ I/flutter ( 6559): └─child: RenderCustomPaint I/flutter ( 6559): │ creator: CustomPaint ← Banner ← CheckedModeBanner ← I/flutter ( 6559): │ WidgetsApp-[GlobalObjectKey _MaterialAppState(1009803148)] ← I/flutter ( 6559): │ Theme ← AnimatedTheme ← ScrollConfiguration ← MaterialApp ← I/flutter ( 6559): │ [root] I/flutter ( 6559): │ parentData: I/flutter ( 6559): │ constraints: BoxConstraints(w=411.4, h=683.4) I/flutter ( 6559): │ size: Size(411.4, 683.4) ... # 省略 这是根RenderObject对象的toStringDeep函数的输出。 当调试布局问题时，关键要看的是size和constraints字段。约束沿着树向下传递，尺寸向上传递。 例如，在上面的转储中，您可以看到窗口大小，Size(411.4, 683.4)，它用于强制RenderPositionedBox下的所有渲染框到屏幕的大小， 约束条件为 BoxConstraints(w=411.4, h=683.4)。从RenderPositionedBox的转储中看到是由Center widget创建的（如creator字段所描述的）， 设置其孩子的约束为：BoxConstraints(0.0FlatButton定义的一部分，它在其内容上设置最小宽度为88像素，并且设置高度为36.0像素（这是Material Design设计规范中FlatButton类的尺寸标准）。 最内部RenderPositionedBox再次松开约束，这次是将按钮中的文本居中。 在RenderParagraph中基于它的内容来决定其大小。 如果您现在按照size链继续往下查看，您会看到文本的大小是如何影响其按钮的框的宽度的，它们都是根据孩子的尺寸自行调整大小。 另一种需要注意的是每个盒子描述的”relayoutSubtreeRoot”部分，它告诉你有多少祖先以某种方式依赖于这个元素的大小。 因此，RenderParagraph有一个relayoutSubtreeRoot=up8，这意味着当它RenderParagraph被标及为”dirty”时，它的八个祖先也必须被标记为”dirty”，因为它们可能受到新尺寸的影响。 如果您编写自己的渲染对象，则可以通过覆盖debugFillProperties()将信息添加到转储。 将DiagnosticsProperty对象作为方法的参数，并调用父类方法。 层 如果您尝试调试合成问题，则可以使用debugDumpLayerTree()。对于上面的例子，它会输出： I/flutter : TransformLayer I/flutter : │ creator: [root] I/flutter : │ offset: Offset(0.0, 0.0) I/flutter : │ transform: I/flutter : │ [0] 3.5,0.0,0.0,0.0 I/flutter : │ [1] 0.0,3.5,0.0,0.0 I/flutter : │ [2] 0.0,0.0,1.0,0.0 I/flutter : │ [3] 0.0,0.0,0.0,1.0 I/flutter : │ I/flutter : ├─child 1: OffsetLayer I/flutter : │ │ creator: RepaintBoundary ← _FocusScope ← Semantics ← Focus-[GlobalObjectKey MaterialPageRoute(560156430)] ← _ModalScope-[GlobalKey 328026813] ← _OverlayEntry-[GlobalKey 388965355] ← Stack ← Overlay-[GlobalKey 625702218] ← Navigator-[GlobalObjectKey _MaterialAppState(859106034)] ← Title ← ⋯ I/flutter : │ │ offset: Offset(0.0, 0.0) I/flutter : │ │ I/flutter : │ └─child 1: PictureLayer I/flutter : │ I/flutter : └─child 2: PictureLayer 这是根Layer的toStringDeep输出的。 根部的变换是应用设备像素比的变换; 在这种情况下，每个逻辑像素代表3.5个设备像素。 RepaintBoundary widget在渲染树的层中创建了一个RenderRepaintBoundary。这用于减少需要重绘的需求量。 语义 您还可以调用debugDumpSemanticsTree()获取语义树（呈现给系统可访问性API的树）的转储。 要使用此功能，必须首先启用辅助功能，例如启用系统辅助工具或SemanticsDebugger （下面讨论）。 对于上面的例子，它会输出: I/flutter : SemanticsNode(0; Rect.fromLTRB(0.0, 0.0, 411.4, 683.4)) I/flutter : ├SemanticsNode(1; Rect.fromLTRB(0.0, 0.0, 411.4, 683.4)) I/flutter : │ └SemanticsNode(2; Rect.fromLTRB(0.0, 0.0, 411.4, 683.4); canBeTapped) I/flutter : └SemanticsNode(3; Rect.fromLTRB(0.0, 0.0, 411.4, 683.4)) I/flutter : └SemanticsNode(4; Rect.fromLTRB(0.0, 0.0, 82.0, 36.0); canBeTapped; \"Dump App\") 调度 要找出相对于帧的开始/结束事件发生的位置，可以切换debugPrintBeginFrameBanner和debugPrintEndFrameBanner布尔值以将帧的开始和结束打印到控制台。 例如: I/flutter : ▄▄▄▄▄▄▄▄ Frame 12 30s 437.086ms ▄▄▄▄▄▄▄▄ I/flutter : Debug print: Am I performing this work more than once per frame? I/flutter : Debug print: Am I performing this work more than once per frame? I/flutter : ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀ debugPrintScheduleFrameStacks还可以用来打印导致当前帧被调度的调用堆栈。 可视化调试 您也可以通过设置debugPaintSizeEnabled为true以可视方式调试布局问题。 这是来自rendering库的布尔值。它可以在任何时候启用，并在为true时影响绘制。 设置它的最简单方法是在void main()的顶部设置。 当它被启用时，所有的盒子都会得到一个明亮的深青色边框，padding（来自widget如Padding）显示为浅蓝色，子widget周围有一个深蓝色框， 对齐方式（来自widget如Center和Align）显示为黄色箭头. 空白（如没有任何子节点的Container）以灰色显示。 debugPaintBaselinesEnabled做了类似的事情，但对于具有基线的对象，文字基线以绿色显示，表意(ideographic)基线以橙色显示。 debugPaintPointersEnabled标志打开一个特殊模式，任何正在点击的对象都会以深青色突出显示。 这可以帮助您确定某个对象是否以某种不正确的方式进行hit测试（Flutter检测点击的位置是否有能响应用户操作的widget）,例如，如果它实际上超出了其父项的范围，首先不会考虑通过hit测试。 如果您尝试调试合成图层，例如以确定是否以及在何处添加RepaintBoundary widget，则可以使用debugPaintLayerBordersEnabled 标志， 该标志用橙色或轮廓线标出每个层的边界，或者使用debugRepaintRainbowEnabled标志， 只要他们重绘时，这会使该层被一组旋转色所覆盖。 所有这些标志只能在调试模式下工作。通常，Flutter框架中以“debug...” 开头的任何内容都只能在调试模式下工作。 调试动画 调试动画最简单的方法是减慢它们的速度。为此，请将timeDilation变量（在scheduler库中）设置为大于1.0的数字，例如50.0。 最好在应用程序启动时只设置一次。如果您在运行中更改它，尤其是在动画运行时将其值减小，则框架的观察时可能会倒退，这可能会导致断言并且通常会干扰您的工作。 调试性能问题 要了解您的应用程序导致重新布局或重新绘制的原因，您可以分别设置debugPrintMarkNeedsLayoutStacks和 debugPrintMarkNeedsPaintStacks标志。 每当渲染盒被要求重新布局和重新绘制时，这些都会将堆栈跟踪记录到控制台。如果这种方法对您有用，您可以使用services库中的debugPrintStack()方法按需打印堆栈痕迹。 统计应用启动时间 要收集有关Flutter应用程序启动所需时间的详细信息，可以在运行flutter run时使用trace-startup和profile选项。 $ flutter run --trace-startup --profile 跟踪输出保存为start_up_info.json，在Flutter工程目录在build目录下。输出列出了从应用程序启动到这些跟踪事件（以微秒捕获）所用的时间： 进入Flutter引擎时. 展示应用第一帧时. 初始化Flutter框架时. 完成Flutter框架初始化时. 如 : { \"engineEnterTimestampMicros\": 96025565262, \"timeToFirstFrameMicros\": 2171978, \"timeToFrameworkInitMicros\": 514585, \"timeAfterFrameworkInitMicros\": 1657393 } 跟踪Dart代码性能 要执行自定义性能跟踪和测量Dart任意代码段的wall/CPU时间（类似于在Android上使用systrace）。 使用dart:developer的Timeline工具来包含你想测试的代码块，例如： Timeline.startSync('interesting function'); // iWonderHowLongThisTakes(); Timeline.finishSync(); 然后打开你应用程序的Observatory timeline页面，在”Recorded Streams”中选择’Dart’复选框，并执行你想测量的功能。 刷新页面将在Chrome的跟踪工具中显示应用按时间顺序排列的timeline记录。 请确保运行flutter run时带有--profile标志，以确保运行时性能特征与您的最终产品差异最小。 Performance Overlay 要获得应用程序性能图，请将MaterialApp构造函数的showPerformanceOverlay参数设置为true。 WidgetsApp构造函数也有类似的参数（如果你没有使用MaterialApp或者WidgetsApp，你可以通过将你的应用程序包装在一个stack中， 并将一个widget放在通过new PerformanceOverlay.allEnabled()创建的stack上来获得相同的效果）。 这将显示两个图表。第一个是GPU线程花费的时间，最后一个是CPU线程花费的时间。 图中的白线以16ms增量沿纵轴显示; 如果图中超过这三条线之一，那么您的运行频率低于60Hz。横轴代表帧。 该图仅在应用程序绘制时更新，因此如果它处于空闲状态，该图将停止移动。 这应该始终在发布模式（release mode）下测试，因为在调试模式下，故意牺牲性能来换取有助于开发调试的功能，如assert声明，这些都是非常耗时的，因此结果将会产生误导。 Material grid 在开发实现Material Design的应用程序时， 将Material Design基线网格覆盖在应用程序上可能有助于验证对齐。 为此，MaterialApp 构造函数 有一个debugShowMaterialGrid参数， 当在调试模式设置为true时，它将覆盖这样一个网格。 您也可以直接使用GridPaper组件将这种网格覆盖在非Material应用程序上 。 "},"chapter2/thread_model_and_error_report.html":{"url":"chapter2/thread_model_and_error_report.html","title":"2.6：Dart线程模型及异常捕获","keywords":"","body":"2.6 Flutter异常捕获 在介绍Flutter异常捕获之前必须先了解一下Dart单线程模型，只有了解了Dart的代码执行流程，我们才能知道该在什么地方去捕获异常。 2.6.1 Dart单线程模型 在Java和Objective-C（以下简称“OC”）中，如果程序发生异常且没有被捕获，那么程序将会终止，但是这在Dart或JavaScript中则不会！究其原因，这和它们的运行机制有关系。Java和OC都是多线程模型的编程语言，任意一个线程触发异常且该异常未被捕获时，就会导致整个进程退出。但Dart和JavaScript不会，它们都是单线程模型，运行机制很相似(但有区别)，下面我们通过Dart官方提供的一张图来看看Dart大致运行原理： Dart 在单线程中是以消息循环机制来运行的，其中包含两个任务队列，一个是“微任务队列” microtask queue，另一个叫做“事件队列” event queue。从图中可以发现，微任务队列的执行优先级高于事件队列。 现在我们来介绍一下Dart线程运行过程，如上图中所示，入口函数 main() 执行完后，消息循环机制便启动了。首先会按照先进先出的顺序逐个执行微任务队列中的任务，当所有微任务队列执行完后便开始执行事件队列中的任务，事件任务执行完毕后再去执行微任务，如此循环往复，生生不息。 在Dart中，所有的外部事件任务都在事件队列中，如IO、计时器、点击、以及绘制事件等，而微任务通常来源于Dart内部，并且微任务非常少，之所以如此，是因为微任务队列优先级高，如果微任务太多，执行时间总和就越久，事件队列任务的延迟也就越久，对于GUI应用来说最直观的表现就是比较卡，所以必须得保证微任务队列不会太长。值得注意的是，我们可以通过Future.microtask(…)方法向微任务队列插入一个任务。 在事件循环中，当某个任务发生异常并没有被捕获时，程序并不会退出，而直接导致的结果是当前任务的后续代码就不会被执行了，也就是说一个任务中的异常是不会影响其它任务执行的。 2.6.2 Flutter异常捕获 Dart中可以通过try/catch/finally来捕获代码块异常，这个和其它编程语言类似，如果读者不清楚，可以查看Dart语言文档，不再赘述，下面我们看看Flutter中的异常捕获。 Flutter框架异常捕获 Flutter 框架为我们在很多关键的方法进行了异常捕获。这里举一个例子，当我们布局发生越界或不合规范时，Flutter就会自动弹出一个错误界面，这是因为Flutter已经在执行build方法时添加了异常捕获，最终的源码如下： @override void performRebuild() { ... try { //执行build方法 built = build(); } catch (e, stack) { // 有异常时则弹出错误提示 built = ErrorWidget.builder(_debugReportException('building $this', e, stack)); } ... } 可以看到，在发生异常时，Flutter默认的处理方式是弹一个ErrorWidget，但如果我们想自己捕获异常并上报到报警平台的话应该怎么做？我们进入_debugReportException()方法看看： FlutterErrorDetails _debugReportException( String context, dynamic exception, StackTrace stack, { InformationCollector informationCollector }) { //构建错误详情对象 final FlutterErrorDetails details = FlutterErrorDetails( exception: exception, stack: stack, library: 'widgets library', context: context, informationCollector: informationCollector, ); //报告错误 FlutterError.reportError(details); return details; } 我们发现，错误是通过FlutterError.reportError方法上报的，继续跟踪： static void reportError(FlutterErrorDetails details) { ... if (onError != null) onError(details); //调用了onError回调 } 我们发现onError是FlutterError的一个静态属性，它有一个默认的处理方法 dumpErrorToConsole，到这里就清晰了，如果我们想自己上报异常，只需要提供一个自定义的错误处理回调即可，如： void main() { FlutterError.onError = (FlutterErrorDetails details) { reportError(details); }; ... } 这样我们就可以处理那些Flutter为我们捕获的异常了，接下来我们看看如何捕获其它异常。 其它异常捕获与日志收集 在Flutter中，还有一些Flutter没有为我们捕获的异常，如调用空对象方法异常、Future中的异常。在Dart中，异常分两类：同步异常和异步异常，同步异常可以通过try/catch捕获，而异步异常则比较麻烦，如下面的代码是捕获不了Future的异常的： try{ Future.delayed(Duration(seconds: 1)).then((e) => Future.error(\"xxx\")); }catch (e){ print(e) } Dart中有一个runZoned(...) 方法，可以给执行对象指定一个Zone。Zone表示一个代码执行的环境范围，为了方便理解，读者可以将Zone类比为一个代码执行沙箱，不同沙箱的之间是隔离的，沙箱可以捕获、拦截或修改一些代码行为，如Zone中可以捕获日志输出、Timer创建、微任务调度的行为，同时Zone也可以捕获所有未处理的异常。下面我们看看runZoned(...)方法定义： R runZoned(R body(), { Map zoneValues, ZoneSpecification zoneSpecification, Function onError, }) zoneValues: Zone 的私有数据，可以通过实例zone[key]获取，可以理解为每个“沙箱”的私有数据。 zoneSpecification：Zone的一些配置，可以自定义一些代码行为，比如拦截日志输出行为等，举个例子： 下面是拦截应用中所有调用print输出日志的行为。 main() { runZoned(() => runApp(MyApp()), zoneSpecification: new ZoneSpecification( print: (Zone self, ZoneDelegate parent, Zone zone, String line) { parent.print(zone, \"Intercepted: $line\"); }), ); } 这样一来，我们APP中所有调用print方法输出日志的行为都会被拦截，通过这种方式，我们也可以在应用中记录日志，等到应用触发未捕获的异常时，将异常信息和日志统一上报。ZoneSpecification还可以自定义一些其他行为，读者可以查看API文档。 onError：Zone中未捕获异常处理回调，如果开发者提供了onError回调或者通过ZoneSpecification.handleUncaughtError指定了错误处理回调，那么这个zone将会变成一个error-zone，该error-zone中发生未捕获异常(无论同步还是异步)时都会调用开发者提供的回调，如： runZoned(() { runApp(MyApp()); }, onError: (Object obj, StackTrace stack) { var details=makeDetails(obj,stack); reportError(details); }); 这样一来，结合上面的FlutterError.onError我们就可以捕获我们Flutter应用中全部错误了！需要注意的是，error-zone内部发生的错误是不会跨越当前error-zone的边界的，如果想跨越error-zone边界去捕获异常，可以通过共同的“源”zone来捕获，如： var future = new Future.value(499); runZoned(() { var future2 = future.then((_) { throw \"error in first error-zone\"; }); runZoned(() { var future3 = future2.catchError((e) { print(\"Never reached!\"); }); }, onError: (e) { print(\"unused error handler\"); }); }, onError: (e) { print(\"catches error of first error-zone.\"); }); 总结 我们最终的异常捕获和上报代码大致如下： void collectLog(String line){ ... //收集日志 } void reportErrorAndLog(FlutterErrorDetails details){ ... //上报错误和日志逻辑 } FlutterErrorDetails makeDetails(Object obj, StackTrace stack){ ...// 构建错误信息 } void main() { FlutterError.onError = (FlutterErrorDetails details) { reportErrorAndLog(details); }; runZoned( () => runApp(MyApp()), zoneSpecification: ZoneSpecification( print: (Zone self, ZoneDelegate parent, Zone zone, String line) { collectLog(line); // 收集日志 }, ), onError: (Object obj, StackTrace stack) { var details = makeDetails(obj, stack); reportErrorAndLog(details); }, ); } "},"chapter3/":{"url":"chapter3/","title":"第三章：基础组件","keywords":"","body":"基础Widget 本节介绍一下Flutter中常用的一些基础widget，由于大多数widget的属性都比较多，我们在介绍widget时会着重介绍常用的属性，而不会像API文档一样所有属性都介绍，关于属性详细的信息请参考Flutter SDK文档。 本章目录 3.1：Widget简介 3.2：状态管理 3.3：文本、字体样式 3.4：按钮 3.5：图片和Icon 3.6：单选框和复选框 3.7：输入框和表单 3.8：进度指示器 "},"chapter3/flutter_widget_intro.html":{"url":"chapter3/flutter_widget_intro.html","title":"3.1：Widget简介","keywords":"","body":"3.1 Widget简介 3.1.1 概念 在前面的介绍中，我们知道在Flutter中几乎所有的对象都是一个Widget。与原生开发中“控件”不同的是，Flutter中的Widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector widget、用于APP主题数据传递的Theme等等，而原生开发中的控件通常只是指UI元素。在后面的内容中，我们在描述UI元素时可能会用到“控件”、“组件”这样的概念，读者心里需要知道他们就是widget，只是在不同场景的不同表述而已。由于Flutter主要就是用于构建用户界面的，所以，在大多数时候，读者可以认为widget就是一个控件，不必纠结于概念。 3.1.2 Widget与Element 在Flutter中，Widget的功能是“描述一个UI元素的配置数据”，它就是说，Widget其实并不是表示最终绘制在设备屏幕上的显示元素，而它只是描述显示元素的一个配置数据。 实际上，Flutter中真正代表屏幕上显示元素的类是Element，也就是说Widget只是描述Element的配置数据！有关Element的详细介绍我们将在本书后面的高级部分深入介绍，现在，读者只需要知道：Widget只是UI元素的一个配置数据，并且一个Widget可以对应多个Element。这是因为同一个Widget对象可以被添加到UI树的不同部分，而真正渲染时，UI树的每一个Element节点都会对应一个Widget对象。总结一下： Widget实际上就是Element的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由Element构成；不过，由于Element是通过Widget生成的，所以它们之间有对应关系，在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。 一个Widget对象可以对应多个Element对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。 读者应该将这两点牢记在心中。 3.1.3 Widget主要接口 我们先来看一下Widget类的声明： @immutable abstract class Widget extends DiagnosticableTree { const Widget({ this.key }); final Key key; @protected Element createElement(); @override String toStringShort() { return key == null ? '$runtimeType' : '$runtimeType-$key'; } @override void debugFillProperties(DiagnosticPropertiesBuilder properties) { super.debugFillProperties(properties); properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense; } static bool canUpdate(Widget oldWidget, Widget newWidget) { return oldWidget.runtimeType == newWidget.runtimeType && oldWidget.key == newWidget.key; } } Widget类继承自DiagnosticableTree，DiagnosticableTree即“诊断树”，主要作用是提供调试信息。 Key: 这个key属性类似于React/Vue中的key，主要的作用是决定是否在下一次build时复用旧的widget，决定的条件在canUpdate()方法中。 createElement()：正如前文所述“一个Widget可以对应多个Element”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的Element对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。 debugFillProperties(...) 复写父类的方法，主要是设置诊断树的一些特性。 canUpdate(...)是一个静态方法，它主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；通过其源码我们可以看到，只要newWidget与oldWidget的runtimeType和key同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。 有关Key和Widget复用的细节将会在本书后面高级部分深入讨论，读者现在只需知道，为Widget显式添加key的话可能（但不一定）会使UI在重新构建时变的高效，读者目前可以先忽略此参数。本书后面的示例中，只会在构建列表项UI时会显式指定Key。 另外Widget类本身是一个抽象类，其中最核心的就是定义了createElement()接口，在Flutter开发中，我们一般都不用直接继承Widget类来实现一个新组件，相反，我们通常会通过继承StatelessWidget或StatefulWidget来间接继承Widget类来实现。StatelessWidget和StatefulWidget都是直接继承自Widget类，而这两个类也正是Flutter中非常重要的两个抽象类，它们引入了两种Widget模型，接下来我们将重点介绍一下这两个类。 3.1.4 StatelessWidget 在之前的章节中，我们已经简单介绍过StatelessWidget，StatelessWidget相对比较简单，它继承自Widget类，重写了createElement()方法： @override StatelessElement createElement() => new StatelessElement(this); StatelessElement 间接继承自Element类，与StatelessWidget相对应（作为其配置数据）。 StatelessWidget用于不需要维护状态的场景，它通常在build方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。我们看一个简单的例子： class Echo extends StatelessWidget { const Echo({ Key key, @required this.text, this.backgroundColor:Colors.grey, }):super(key:key); final String text; final Color backgroundColor; @override Widget build(BuildContext context) { return Center( child: Container( color: backgroundColor, child: Text(text), ), ); } } 上面的代码，实现了一个回显字符串的Echo widget。 按照惯例，widget的构造函数参数应使用命名参数，命名参数中的必要参数要添加@required标注，这样有利于静态代码分析器进行检查。另外，在继承widget时，第一个参数通常应该是Key，另外，如果Widget需要接收子Widget，那么child或children参数通常应被放在参数列表的最后。同样是按照惯例，Widget的属性应尽可能的被声明为final，防止被意外改变。 然后我们可以通过如下方式使用它： Widget build(BuildContext context) { return Echo(text: \"hello world\"); } 运行后效果如图3-1所示： 3.1.5 StatefulWidget 和StatelessWidget一样，StatefulWidget也是继承自Widget类，并重写了createElement()方法，不同的是返回的Element 对象并不相同；另外StatefulWidget类中添加了一个新的接口createState()。 下面我们看看StatefulWidget的类定义： abstract class StatefulWidget extends Widget { const StatefulWidget({ Key key }) : super(key: key); @override StatefulElement createElement() => new StatefulElement(this); @protected State createState(); } StatefulElement 间接继承自Element类，与StatefulWidget相对应（作为其配置数据）。StatefulElement中可能会多次调用createState()来创建状态(State)对象。 createState() 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个StatefulElement对应一个State实例。 在本书中经常会出现“树“的概念，在不同的场景可能指不同的意思，在说“widget树”时它可以指widget结构树，但由于widget与Element有对应关系（一可能对多），在有些场景（Flutter的SDK文档中）也代指“UI树”的意思。而在stateful widget中，State对象也和StatefulElement具有对应关系（一对一），所以在Flutter的SDK文档中，可以经常看到“从树中移除State对象”或“插入State对象到树中”这样的描述。其实，无论哪种描述，其意思都是在描述“一棵构成用户界面的节点元素的树”，读者不必纠结于这些概念，还是那句话“得其神，忘其形”，因此，本书中出现的各种“树”，如果没有特别说明，读者都可抽象的认为它是“一棵构成用户界面的节点元素的树”。 3.1.6 State 一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存的状态信息可以： 在widget build时可以被同步读取。 在widget生命周期中可以被改变，当State被改变时，可以手动调用其setState()方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其build方法重新构建widget树，从而达到更新UI的目的。 State中有两个常用属性： widget，它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用声明周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 context，它是BuildContext类的一个实例，表示构建widget的上下文，它是操作widget在树中位置的一个句柄，它包含了一些查找、遍历当前Widget树的一些方法。每一个widget都有一个自己的context对象。 对于BuildContext读者现在可以先作了解，随着本书后面内容的展开，也会用到Context的一些方法，读者可以通过具体的场景对其有个直观的认识。关于BuildContext更多的内容，我们也将在后面高级部分再深入介绍。 State生命周期 理解State的生命周期对flutter开发非常重要，为了加深读者印象，本节我们通过一个实例来演示一下State的生命周期。在接下来的示例中，我们实现一个计数器widget，点击它可以使计数器加1，由于要保存计数器的数值状态，所以我们应继承StatefulWidget，代码如下： class CounterWidget extends StatefulWidget { const CounterWidget({ Key key, this.initValue: 0 }); final int initValue; @override _CounterWidgetState createState() => new _CounterWidgetState(); } CounterWidget接收一个initValue整型参数，它表示计数器的初始值。下面我们看一下State的代码： class _CounterWidgetState extends State { int _counter; @override void initState() { super.initState(); //初始化状态 _counter=widget.initValue; print(\"initState\"); } @override Widget build(BuildContext context) { print(\"build\"); return Scaffold( body: Center( child: FlatButton( child: Text('$_counter'), //点击后计数器自增 onPressed:()=>setState(()=> ++_counter, ), ), ), ); } @override void didUpdateWidget(CounterWidget oldWidget) { super.didUpdateWidget(oldWidget); print(\"didUpdateWidget\"); } @override void deactivate() { super.deactivate(); print(\"deactive\"); } @override void dispose() { super.dispose(); print(\"dispose\"); } @override void reassemble() { super.reassemble(); print(\"reassemble\"); } @override void didChangeDependencies() { super.didChangeDependencies(); print(\"didChangeDependencies\"); } } 接下来，我们创建一个新路由，在新路由中，我们只显示一个CounterWidget： Widget build(BuildContext context) { return CounterWidget(); } 我们运行应用并打开该路由页面，在新路由页打开后，屏幕中央就会出现一个数字0，然后控制台日志输出： I/flutter ( 5436): initState I/flutter ( 5436): didChangeDependencies I/flutter ( 5436): build 可以看到，在StatefulWidget插入到Widget树时首先initState方法会被调用。 然后我们点击⚡️按钮热重载，控制台输出日志如下： I/flutter ( 5436): reassemble I/flutter ( 5436): didUpdateWidget I/flutter ( 5436): build 可以看到此时initState 和didChangeDependencies都没有被调用，而此时didUpdateWidget被调用。 接下来，我们在widget树中移除CounterWidget，将路由build方法改为： Widget build(BuildContext context) { //移除计数器 //return CounterWidget(); //随便返回一个Text() return Text(\"xxx\"); } 然后热重载，日志如下： I/flutter ( 5436): reassemble I/flutter ( 5436): deactive I/flutter ( 5436): dispose 我们可以看到，在CounterWidget从widget树中移除时，deactive和dispose会依次被调用。 下面我们来看看各个回调函数： initState：当Widget第一次插入到Widget树时会被调用，对于每一个State对象，Flutter framework只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用BuildContext.inheritFromWidgetOfExactType（该方法用于在Widget树上获取离当前widget最近的一个父级InheritFromWidget，关于InheritedWidget我们将在后面章节介绍），原因是在初始化完成后，Widget树中的InheritFromWidget也可能会发生变化，所以正确的做法应该在在build（）方法或didChangeDependencies()中调用它。 didChangeDependencies()：当State对象的依赖发生变化时会被调用；例如：在之前build() 中包含了一个InheritedWidget，然后在之后的build() 中InheritedWidget发生了变化，那么此时InheritedWidget的子widget的didChangeDependencies()回调都会被调用。典型的场景是当系统语言Locale或应用主题改变时，Flutter framework会通知widget调用此回调。 build()：此回调读者现在应该已经相当熟悉了，它主要是用于构建Widget子树的，会在如下场景被调用： 在调用initState()之后。 在调用didUpdateWidget()之后。 在调用setState()之后。 在调用didChangeDependencies()之后。 在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后。 reassemble()：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。 didUpdateWidget()：在widget重新构建时，Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果Widget.canUpdate返回true则会调用此回调。正如之前所述，Widget.canUpdate会在新旧widget的key和runtimeType同时相等时会返回true，也就是说在在新旧widget的key和runtimeType同时相等时didUpdateWidget()就会被调用。 deactivate()：当State对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework会将State对象重新插到树中，如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法。 dispose()：当State对象从树中被永久移除时调用；通常在此回调中释放资源。 StatefulWidget生命周期如图3-2所示： 注意：在继承StatefulWidget重写其方法时，对于包含@mustCallSuper标注的父类方法，都要在子类方法中先调用父类方法。 3.1.7 Flutter SDK内置组件库介绍 Flutter提供了一套丰富、强大的基础组件，在基础组件库之上Flutter又提供了一套Material风格（Android默认的视觉风格）和一套Cupertino风格（iOS视觉风格）的组件库。要使用基础组件库，需要先导入： import 'package:flutter/widgets.dart'; 下面我们介绍一下常用的组件。 基础组件 Text：该组件可让您创建一个带格式的文本。 Row、 Column： 这些具有弹性空间的布局类Widget可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于Web开发中的Flexbox布局模型。 Stack： 取代线性布局 (译者语：和Android中的FrameLayout相似)，Stack允许子 widget 堆叠， 你可以使用 Positioned 来定位他们相对于Stack的上下左右四条边的位置。Stacks是基于Web开发中的绝对定位（absolute positioning )布局模型设计的。 Container： Container 可让您创建矩形视觉元素。container 可以装饰一个BoxDecoration, 如 background、一个边框、或者一个阴影。 Container 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外， Container可以使用矩阵在三维空间中对其进行变换。 Material组件 Flutter提供了一套丰富的Material组件，它可以帮助我们构建遵循Material Design设计规范的应用程序。Material应用程序以MaterialApp 组件开始， 该组件在应用程序的根部创建了一些必要的组件，比如Theme组件，它用于配置应用的主题。 是否使用MaterialApp完全是可选的，但是使用它是一个很好的做法。在之前的示例中，我们已经使用过多个Material 组件了，如：Scaffold、AppBar、FlatButton等。要使用Material 组件，需要先引入它： import 'package:flutter/material.dart'; Cupertino组件 Flutter也提供了一套丰富的Cupertino风格的组件，尽管目前还没有Material 组件那么丰富，但是它仍在不断的完善中。值得一提的是在Material 组件库中有一些组件可以根据实际运行平台来切换表现风格，比如MaterialPageRoute，在路由切换时，如果是Android系统，它将会使用Android系统默认的页面切换动画(从底向上)；如果是iOS系统，它会使用iOS系统默认的页面切换动画（从右向左）。由于在前面的示例中还没有Cupertino组件的示例，下面我们实现一个简单的Cupertino组件风格的页面： //导入cupertino widget库 import 'package:flutter/cupertino.dart'; class CupertinoTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { return CupertinoPageScaffold( navigationBar: CupertinoNavigationBar( middle: Text(\"Cupertino Demo\"), ), child: Center( child: CupertinoButton( color: CupertinoColors.activeBlue, child: Text(\"Press\"), onPressed: () {} ), ), ); } } 下面（图3-3）是在iPhoneX上页面效果截图： 关于示例 本章后面章节的示例中会使用一些布局类组件，如Scaffold、Row、Column等，这些组件将在后面“布局类组件”一章中详细介绍，读者可以先不用关注。 总结 Flutter提供了丰富的组件，在实际的开发中你可以根据需要随意使用它们，而不必担心引入过多组件库会让你的应用安装包变大，这不是web开发，dart在编译时只会编译你使用了的代码。由于Material和Cupertino都是在基础组件库之上的，所以如果我们的应用中引入了这两者之一，则不需要再引入flutter/widgets.dart了，因为它们内部已经引入过了。 "},"chapter3/state_manage.html":{"url":"chapter3/state_manage.html","title":"3.2：状态管理","keywords":"","body":"3.2 状态管理 响应式的编程框架中都会有一个永恒的主题——“状态(State)管理”，无论是在React/Vue（两者都是支持响应式编程的Web开发框架）还是Flutter中，他们讨论的问题和解决的思想都是一致的。所以，如果你对React/Vue的状态管理有了解，可以跳过本节。言归正传，我们想一个问题，StatefulWidget的状态应该被谁管理？Widget本身？父Widget？都会？还是另一个对象？答案是取决于实际情况！以下是管理状态的最常见的方法： Widget管理自己的状态。 Widget管理子Widget状态。 混合管理（父Widget和子Widget都管理状态）。 如何决定使用哪种管理方法？下面是官方给出的一些原则可以帮助你做决定： 如果状态是用户数据，如复选框的选中状态、滑块的位置，则该状态最好由父Widget管理。 如果状态是有关界面外观效果的，例如颜色、动画，那么状态最好由Widget本身来管理。 如果某一个状态是不同Widget共享的则最好由它们共同的父Widget管理。 在Widget内部管理状态封装性会好一些，而在父Widget中管理会比较灵活。有些时候，如果不确定到底该怎么管理状态，那么推荐的首选是在父widget中管理（灵活会显得更重要一些）。 接下来，我们将通过创建三个简单示例TapboxA、TapboxB和TapboxC来说明管理状态的不同方式。 这些例子功能是相似的 ——创建一个盒子，当点击它时，盒子背景会在绿色与灰色之间切换。状态 _active确定颜色：绿色为true ，灰色为false，如图3-4所示。 下面的例子将使用GestureDetector来识别点击事件，关于该GestureDetector的详细内容我们将在后面“事件处理”一章中介绍。 3.2.1 Widget管理自身状态 _TapboxAState 类: 管理TapboxA的状态。 定义_active：确定盒子的当前颜色的布尔值。 定义_handleTap()函数，该函数在点击该盒子时更新_active，并调用setState()更新UI。 实现widget的所有交互式行为。 // TapboxA 管理自身状态. //------------------------- TapboxA ---------------------------------- class TapboxA extends StatefulWidget { TapboxA({Key key}) : super(key: key); @override _TapboxAState createState() => new _TapboxAState(); } class _TapboxAState extends State { bool _active = false; void _handleTap() { setState(() { _active = !_active; }); } Widget build(BuildContext context) { return new GestureDetector( onTap: _handleTap, child: new Container( child: new Center( child: new Text( _active ? 'Active' : 'Inactive', style: new TextStyle(fontSize: 32.0, color: Colors.white), ), ), width: 200.0, height: 200.0, decoration: new BoxDecoration( color: _active ? Colors.lightGreen[700] : Colors.grey[600], ), ), ); } } 3.2.2 父Widget管理子Widget的状态 对于父Widget来说，管理状态并告诉其子Widget何时更新通常是比较好的方式。 例如，IconButton是一个图标按钮，但它是一个无状态的Widget，因为我们认为父Widget需要知道该按钮是否被点击来采取相应的处理。 在以下示例中，TapboxB通过回调将其状态导出到其父组件，状态由父组件管理，因此它的父组件为StatefulWidget。但是由于TapboxB不管理任何状态，所以TapboxB为StatelessWidget。 ParentWidgetState 类: 为TapboxB 管理_active状态。 实现_handleTapboxChanged()，当盒子被点击时调用的方法。 当状态改变时，调用setState()更新UI。 TapboxB 类: 继承StatelessWidget类，因为所有状态都由其父组件处理。 当检测到点击时，它会通知父组件。 // ParentWidget 为 TapboxB 管理状态. //------------------------ ParentWidget -------------------------------- class ParentWidget extends StatefulWidget { @override _ParentWidgetState createState() => new _ParentWidgetState(); } class _ParentWidgetState extends State { bool _active = false; void _handleTapboxChanged(bool newValue) { setState(() { _active = newValue; }); } @override Widget build(BuildContext context) { return new Container( child: new TapboxB( active: _active, onChanged: _handleTapboxChanged, ), ); } } //------------------------- TapboxB ---------------------------------- class TapboxB extends StatelessWidget { TapboxB({Key key, this.active: false, @required this.onChanged}) : super(key: key); final bool active; final ValueChanged onChanged; void _handleTap() { onChanged(!active); } Widget build(BuildContext context) { return new GestureDetector( onTap: _handleTap, child: new Container( child: new Center( child: new Text( active ? 'Active' : 'Inactive', style: new TextStyle(fontSize: 32.0, color: Colors.white), ), ), width: 200.0, height: 200.0, decoration: new BoxDecoration( color: active ? Colors.lightGreen[700] : Colors.grey[600], ), ), ); } } 3.2.3 混合状态管理 对于一些组件来说，混合管理的方式会非常有用。在这种情况下，组件自身管理一些内部状态，而父组件管理一些其他外部状态。 在下面TapboxC示例中，手指按下时，盒子的周围会出现一个深绿色的边框，抬起时，边框消失。点击完成后，盒子的颜色改变。 TapboxC将其_active状态导出到其父组件中，但在内部管理其_highlight状态。这个例子有两个状态对象_ParentWidgetState和_TapboxCState。 _ParentWidgetStateC类: 管理_active 状态。 实现 _handleTapboxChanged() ，当盒子被点击时调用。 当点击盒子并且_active状态改变时调用setState()更新UI。 _TapboxCState 对象: 管理_highlight 状态。 GestureDetector监听所有tap事件。当用户点下时，它添加高亮（深绿色边框）；当用户释放时，会移除高亮。 当按下、抬起、或者取消点击时更新_highlight状态，调用setState()更新UI。 当点击时，将状态的改变传递给父组件。 //---------------------------- ParentWidget ---------------------------- class ParentWidgetC extends StatefulWidget { @override _ParentWidgetCState createState() => new _ParentWidgetCState(); } class _ParentWidgetCState extends State { bool _active = false; void _handleTapboxChanged(bool newValue) { setState(() { _active = newValue; }); } @override Widget build(BuildContext context) { return new Container( child: new TapboxC( active: _active, onChanged: _handleTapboxChanged, ), ); } } //----------------------------- TapboxC ------------------------------ class TapboxC extends StatefulWidget { TapboxC({Key key, this.active: false, @required this.onChanged}) : super(key: key); final bool active; final ValueChanged onChanged; @override _TapboxCState createState() => new _TapboxCState(); } class _TapboxCState extends State { bool _highlight = false; void _handleTapDown(TapDownDetails details) { setState(() { _highlight = true; }); } void _handleTapUp(TapUpDetails details) { setState(() { _highlight = false; }); } void _handleTapCancel() { setState(() { _highlight = false; }); } void _handleTap() { widget.onChanged(!widget.active); } @override Widget build(BuildContext context) { // 在按下时添加绿色边框，当抬起时，取消高亮 return new GestureDetector( onTapDown: _handleTapDown, // 处理按下事件 onTapUp: _handleTapUp, // 处理抬起事件 onTap: _handleTap, onTapCancel: _handleTapCancel, child: new Container( child: new Center( child: new Text(widget.active ? 'Active' : 'Inactive', style: new TextStyle(fontSize: 32.0, color: Colors.white)), ), width: 200.0, height: 200.0, decoration: new BoxDecoration( color: widget.active ? Colors.lightGreen[700] : Colors.grey[600], border: _highlight ? new Border.all( color: Colors.teal[700], width: 10.0, ) : null, ), ), ); } } 另一种实现可能会将高亮状态导出到父组件，但同时保持_active状态为内部状态，但如果你要将该TapBox给其它人使用，可能没有什么意义。 开发人员只会关心该框是否处于Active状态，而不在乎高亮显示是如何管理的，所以应该让TapBox内部处理这些细节。 3.3.4 全局状态管理 当应用中需要一些跨组件（包括跨路由）的状态需要同步时，上面介绍的方法便很难胜任了。比如，我们有一个设置页，里面可以设置应用的语言，我们为了让设置实时生效，我们期望在语言状态发生改变时，APP中依赖应用语言的组件能够重新build一下，但这些依赖应用语言的组件和设置页并不在一起，所以这种情况用上面的方法很难管理。这时，正确的做法是通过一个全局状态管理器来处理这种相距较远的组件之间的通信。目前主要有两种办法： 实现一个全局的事件总线，将语言状态改变对应为一个事件，然后在APP中依赖应用语言的组件的initState 方法中订阅语言改变的事件。当用户在设置页切换语言后，我们发布语言改变事件，而订阅了此事件的组件就会收到通知，收到通知后调用setState(...)方法重新build一下自身即可。 使用一些专门用于状态管理的包，如Provider、Redux，读者可以在pub上查看其详细信息。 本书将在\"功能型组件\"一章中介绍Provider包的实现原理及用法，同时也将会在\"事件处理与通知\"一章中实现一个全局事件总线，读者有需要可以直接翻看。 "},"chapter3/text.html":{"url":"chapter3/text.html","title":"3.3：文本、字体样式","keywords":"","body":"3.3 文本及样式 3.3.1 Text Text用于显示简单样式文本，它包含一些控制文本显示样式的一些属性，一个简单的例子如下： Text(\"Hello world\", textAlign: TextAlign.center, ); Text(\"Hello world! I'm Jack. \"*4, maxLines: 1, overflow: TextOverflow.ellipsis, ); Text(\"Hello world\", textScaleFactor: 1.5, ); 运行效果如图3-5所示： textAlign：文本的对齐方式；可以选择左对齐、右对齐还是居中。注意，对齐的参考系是Text widget本身。本例中虽然是指定了居中对齐，但因为Text文本内容宽度不足一行，Text的宽度和文本内容长度相等，那么这时指定对齐方式是没有意义的，只有Text宽度大于文本内容长度时指定此属性才有意义。下面我们指定一个较长的字符串： Text(\"Hello world \"*6, //字符串重复六次 textAlign: TextAlign.center, )； 运行效果如图3-6所示： ​ 字符串内容超过一行，Text宽度等于屏幕宽度，第二行文本便会居中显示。 maxLines、overflow：指定文本显示的最大行数，默认情况下，文本是自动折行的，如果指定此参数，则文本最多不会超过指定的行。如果有多余的文本，可以通过overflow来指定截断方式，默认是直接截断，本例中指定的截断方式TextOverflow.ellipsis，它会将多余文本截断后以省略符“...”表示；TextOverflow的其它截断方式请参考SDK文档。 textScaleFactor：代表文本相对于当前字体大小的缩放因子，相对于去设置文本的样式style属性的fontSize，它是调整字体大小的一个快捷方式。该属性的默认值可以通过MediaQueryData.textScaleFactor获得，如果没有MediaQuery，那么会默认值将为1.0。 3.3.2 TextStyle TextStyle用于指定文本显示的样式如颜色、字体、粗细、背景等。我们看一个示例： Text(\"Hello world\", style: TextStyle( color: Colors.blue, fontSize: 18.0, height: 1.2, fontFamily: \"Courier\", background: new Paint()..color=Colors.yellow, decoration:TextDecoration.underline, decorationStyle: TextDecorationStyle.dashed ), ); 效果如图3-7所示： 此示例只展示了TextStyle的部分属性，它还有一些其它属性，属性名基本都是自解释的，在此不再赘述，读者可以查阅SDK文档。值得注意的是： height：该属性用于指定行高，但它并不是一个绝对值，而是一个因子，具体的行高等于fontSize*height。 fontFamily ：由于不同平台默认支持的字体集不同，所以在手动指定字体时一定要先在不同平台测试一下。 fontSize：该属性和Text的textScaleFactor都用于控制字体大小。但是有两个主要区别： fontSize可以精确指定字体大小，而textScaleFactor只能通过缩放比例来控制。 textScaleFactor主要是用于系统字体大小设置改变时对Flutter应用字体进行全局调整，而fontSize通常用于单个文本，字体大小不会跟随系统字体大小变化。 3.3.3 TextSpan 在上面的例子中，Text的所有文本内容只能按同一种样式，如果我们需要对一个Text内容的不同部分按照不同的样式显示，这时就可以使用TextSpan，它代表文本的一个“片段”。我们看看TextSpan的定义: const TextSpan({ TextStyle style, Sting text, List children, GestureRecognizer recognizer, }); 其中style 和 text属性代表该文本片段的样式和内容。 children是一个TextSpan的数组，也就是说TextSpan可以包括其他TextSpan。而recognizer用于对该文本片段上用于手势进行识别处理。下面我们看一个效果（图3-8），然后用TextSpan实现它。 源码： Text.rich(TextSpan( children: [ TextSpan( text: \"Home: \" ), TextSpan( text: \"https://flutterchina.club\", style: TextStyle( color: Colors.blue ), recognizer: _tapRecognizer ), ] )) 上面代码中，我们通过TextSpan实现了一个基础文本片段和一个链接片段，然后通过Text.rich 方法将TextSpan 添加到Text中，之所以可以这样做，是因为Text其实就是RichText的一个包装，而RichText是可以显示多种样式(富文本)的widget。 _tapRecognizer，它是点击链接后的一个处理器（代码已省略），关于手势识别的更多内容我们将在后面单独介绍。 3.3.4 DefaultTextStyle 在Widget树中，文本的样式默认是可以被继承的（子类文本类组件未指定具体样式时可以使用Widget树中父级设置的默认样式），因此，如果在Widget树的某一个节点处设置一个默认的文本样式，那么该节点的子树中所有文本都会默认使用这个样式，而DefaultTextStyle正是用于设置默认文本样式的。下面我们看一个例子： DefaultTextStyle( //1.设置文本默认样式 style: TextStyle( color:Colors.red, fontSize: 20.0, ), textAlign: TextAlign.start, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text(\"hello world\"), Text(\"I am Jack\"), Text(\"I am Jack\", style: TextStyle( inherit: false, //2.不继承默认样式 color: Colors.grey ), ), ], ), ); 上面代码中，我们首先设置了一个默认的文本样式，即字体为20像素(逻辑像素)、颜色为红色。然后通过DefaultTextStyle 设置给了子树Column节点处，这样一来Column的所有子孙Text默认都会继承该样式，除非Text显示指定不继承样式，如代码中注释2。示例运行效果如图3-9： 3.3.5 字体 可以在Flutter应用程序中使用不同的字体。例如，我们可能会使用设计人员创建的自定义字体，或者其它第三方的字体，如Google Fonts中的字体。本节将介绍如何为Flutter应用配置字体，并在渲染文本时使用它们。 在Flutter中使用字体分两步完成。首先在pubspec.yaml中声明它们，以确保它们会打包到应用程序中。然后通过TextStyle属性使用字体。 在asset中声明 要将字体文件打包到应用中，和使用其它资源一样，要先在pubspec.yaml中声明它。然后将字体文件复制到在pubspec.yaml中指定的位置。如： flutter: fonts: - family: Raleway fonts: - asset: assets/fonts/Raleway-Regular.ttf - asset: assets/fonts/Raleway-Medium.ttf weight: 500 - asset: assets/fonts/Raleway-SemiBold.ttf weight: 600 - family: AbrilFatface fonts: - asset: assets/fonts/abrilfatface/AbrilFatface-Regular.ttf 使用字体 // 声明文本样式 const textStyle = const TextStyle( fontFamily: 'Raleway', ); // 使用文本样式 var buttonText = const Text( \"Use the font for this text\", style: textStyle, ); Package中的字体 要使用Package中定义的字体，必须提供package参数。例如，假设上面的字体声明位于my_package包中。然后创建TextStyle的过程如下： const textStyle = const TextStyle( fontFamily: 'Raleway', package: 'my_package', //指定包名 ); 如果在package包内部使用它自己定义的字体，也应该在创建文本样式时指定package参数，如上例所示。 一个包也可以只提供字体文件而不需要在pubspec.yaml中声明。 这些文件应该存放在包的lib/文件夹中。字体文件不会自动绑定到应用程序中，应用程序可以在声明字体时有选择地使用这些字体。假设一个名为my_package的包中有一个字体文件： lib/fonts/Raleway-Medium.ttf 然后，应用程序可以声明一个字体，如下面的示例所示： flutter: fonts: - family: Raleway fonts: - asset: assets/fonts/Raleway-Regular.ttf - asset: packages/my_package/fonts/Raleway-Medium.ttf weight: 500 lib/是隐含的，所以它不应该包含在asset路径中。 在这种情况下，由于应用程序本地定义了字体，所以在创建TextStyle时可以不指定package参数： const textStyle = const TextStyle( fontFamily: 'Raleway', ); "},"chapter3/buttons.html":{"url":"chapter3/buttons.html","title":"3.4：按钮","keywords":"","body":"3.4 按钮 3.4.1 Material组件库中的按钮 Material 组件库中提供了多种按钮组件如RaisedButton、FlatButton、OutlineButton等，它们都是直接或间接对RawMaterialButton组件的包装定制，所以他们大多数属性都和RawMaterialButton一样。在介绍各个按钮时我们先介绍其默认外观，而按钮的外观大都可以通过属性来自定义，我们在后面统一介绍这些属性。另外，所有Material 库中的按钮都有如下相同点： 按下时都会有“水波动画”（又称“涟漪动画”，就是点击时按钮上会出现水波荡漾的动画）。 有一个onPressed属性来设置点击回调，当按钮按下时会执行该回调，如果不提供该回调则按钮会处于禁用状态，禁用状态不响应用户点击。 RaisedButton RaisedButton 即\"漂浮\"按钮，它默认带有阴影和灰色背景。按下后，阴影会变大，如图3-10所示： 使用RaisedButton非常简单，如： RaisedButton( child: Text(\"normal\"), onPressed: () {}, ); FlatButton FlatButton即扁平按钮，默认背景透明并不带阴影。按下后，会有背景色，如图3-11所示： 使用FlatButton也很简单，代码如下： FlatButton( child: Text(\"normal\"), onPressed: () {}, ) OutlineButton OutlineButton默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱)，如图3-12所示： 使用OutlineButton也很简单，代码如下： OutlineButton( child: Text(\"normal\"), onPressed: () {}, ) IconButton IconButton是一个可点击的Icon，不包括文字，默认没有背景，点击后会出现背景，如图3-13所示： 代码如下： IconButton( icon: Icon(Icons.thumb_up), onPressed: () {}, ) 带图标的按钮 RaisedButton、FlatButton、OutlineButton都有一个icon 构造函数，通过它可以轻松创建带图标的按钮，如图3-14所示： 代码如下： RaisedButton.icon( icon: Icon(Icons.send), label: Text(\"发送\"), onPressed: _onPressed, ), OutlineButton.icon( icon: Icon(Icons.add), label: Text(\"添加\"), onPressed: _onPressed, ), FlatButton.icon( icon: Icon(Icons.info), label: Text(\"详情\"), onPressed: _onPressed, ), 3.4.2 自定义按钮外观 按钮外观可以通过其属性来定义，不同按钮属性大同小异，我们以FlatButton为例，介绍一下常见的按钮属性，详细的信息可以查看API文档。 const FlatButton({ ... @required this.onPressed, //按钮点击回调 this.textColor, //按钮文字颜色 this.disabledTextColor, //按钮禁用时的文字颜色 this.color, //按钮背景颜色 this.disabledColor,//按钮禁用时的背景颜色 this.highlightColor, //按钮按下时的背景颜色 this.splashColor, //点击时，水波动画中水波的颜色 this.colorBrightness,//按钮主题，默认是浅色主题 this.padding, //按钮的填充 this.shape, //外形 @required this.child, //按钮的内容 }) 其中大多数属性名都是自解释的，我们不赘述。下面我们通过一个示例来看看如何自定义按钮。 示例 定义一个背景蓝色，两边圆角的按钮。效果如图3-15所示： 代码如下： FlatButton( color: Colors.blue, highlightColor: Colors.blue[700], colorBrightness: Brightness.dark, splashColor: Colors.grey, child: Text(\"Submit\"), shape:RoundedRectangleBorder(borderRadius: BorderRadius.circular(20.0)), onPressed: () {}, ) 很简单吧，在上面的代码中，我们主要通过shape来指定其外形为一个圆角矩形。因为按钮背景是蓝色(深色)，我们需要指定按钮主题colorBrightness为Brightness.dark，这是为了保证按钮文字颜色为浅色。 Flutter 中没有提供去除背景的设置，假若我们需要去除背景，则可以通过将背景颜色设置为全透明来实现。对应上面的代码，便是将 color: Colors.blue 替换为 color: Color(0x000000)。 细心的读者可能会发现这个按钮没有阴影(点击之后也没有)，这样会显得没有质感。其实这也很容易，将上面的FlatButton换成RaisedButton就行，其它代码不用改（这里 color 也不做更改），换了之后的效果如图3-16所示： 是不是有质感了！之所以会这样，是因为RaisedButton默认有配置阴影： const RaisedButton({ ... this.elevation = 2.0, //正常状态下的阴影 this.highlightElevation = 8.0,//按下时的阴影 this.disabledElevation = 0.0,// 禁用时的阴影 ... } 值得注意的是，在Material 组件库中，我们会在很多组件中见到elevation相关的属性，它们都是用来控制阴影的，这是因为阴影在Material设计风格中是一种很重要的表现形式，以后在介绍其它组件时，便不再赘述。 如果我们想实现一个背景渐变的圆角按钮，按钮有没有相应的属性呢？答案是否定的，但是，我们可以通过其它方式来实现，我们将在后面\"自定义组件\"一章中实现。 "},"chapter3/img_and_icon.html":{"url":"chapter3/img_and_icon.html","title":"3.5：图片和Icon","keywords":"","body":"3.5 图片及ICON 3.5.1 图片 Flutter中，我们可以通过Image组件来加载并显示图片，Image的数据源可以是asset、文件、内存以及网络。 ImageProvider ImageProvider 是一个抽象类，主要定义了图片数据获取的接口load()，从不同的数据源获取图片需要实现不同的ImageProvider ，如AssetImage是实现了从Asset中加载图片的ImageProvider，而NetworkImage实现了从网络加载图片的ImageProvider。 Image Image widget有一个必选的image参数，它对应一个ImageProvider。下面我们分别演示一下如何从asset和网络加载图片。 从asset中加载图片 在工程根目录下创建一个images目录，并将图片avatar.png拷贝到该目录。 在pubspec.yaml中的flutter部分添加如下内容： assets: - images/avatar.png 注意: 由于 yaml 文件对缩进严格，所以必须严格按照每一层两个空格的方式进行缩进，此处assets前面应有两个空格。 加载该图片 Image( image: AssetImage(\"images/avatar.png\"), width: 100.0 ); Image也提供了一个快捷的构造函数Image.asset用于从asset中加载、显示图片： Image.asset(\"images/avatar.png\", width: 100.0, ) 从网络加载图片 Image( image: NetworkImage( \"https://avatars2.githubusercontent.com/u/20411648?s=460&v=4\"), width: 100.0, ) Image也提供了一个快捷的构造函数Image.network用于从网络加载、显示图片： Image.network( \"https://avatars2.githubusercontent.com/u/20411648?s=460&v=4\", width: 100.0, ) 运行上面两个示例，图片加载成功后如图3-17所示： 参数 Image在显示图片时定义了一系列参数，通过这些参数我们可以控制图片的显示外观、大小、混合效果等。我们看一下Image的主要参数： const Image({ ... this.width, //图片的宽 this.height, //图片高度 this.color, //图片的混合色值 this.colorBlendMode, //混合模式 this.fit,//缩放模式 this.alignment = Alignment.center, //对齐方式 this.repeat = ImageRepeat.noRepeat, //重复方式 ... }) width、height：用于设置图片的宽、高，当不指定宽高时，图片会根据当前父容器的限制，尽可能的显示其原始大小，如果只设置width、height的其中一个，那么另一个属性默认会按比例缩放，但可以通过下面介绍的fit属性来指定适应规则。 fit：该属性用于在图片的显示空间和图片本身大小不同时指定图片的适应模式。适应模式是在BoxFit中定义，它是一个枚举类型，有如下值： fill：会拉伸填充满显示空间，图片本身长宽比会发生变化，图片会变形。 cover：会按图片的长宽比放大后居中填满显示空间，图片不会变形，超出显示空间部分会被剪裁。 contain：这是图片的默认适应规则，图片会在保证图片本身长宽比不变的情况下缩放以适应当前显示空间，图片不会变形。 fitWidth：图片的宽度会缩放到显示空间的宽度，高度会按比例缩放，然后居中显示，图片不会变形，超出显示空间部分会被剪裁。 fitHeight：图片的高度会缩放到显示空间的高度，宽度会按比例缩放，然后居中显示，图片不会变形，超出显示空间部分会被剪裁。 none：图片没有适应策略，会在显示空间内显示图片，如果图片比显示空间大，则显示空间只会显示图片中间部分。 一图胜万言！ 我们队一个宽高相同的头像图片应用不同的fit值，效果如图3-18所示： color和 colorBlendMode：在图片绘制时可以对每一个像素进行颜色混合处理，color指定混合色，而colorBlendMode指定混合模式，下面是一个简单的示例： Image( image: AssetImage(\"images/avatar.png\"), width: 100.0, color: Colors.blue, colorBlendMode: BlendMode.difference, ); 运行效果如图3-19所示（彩色）: repeat：当图片本身大小小于显示空间时，指定图片的重复规则。简单示例如下： Image( image: AssetImage(\"images/avatar.png\"), width: 100.0, height: 200.0, repeat: ImageRepeat.repeatY , ) 运行后效果如图3-20所示： 完整的示例代码如下： import 'package:flutter/material.dart'; class ImageAndIconRoute extends StatelessWidget { @override Widget build(BuildContext context) { var img=AssetImage(\"imgs/avatar.png\"); return SingleChildScrollView( child: Column( children: [ Image( image: img, height: 50.0, width: 100.0, fit: BoxFit.fill, ), Image( image: img, height: 50, width: 50.0, fit: BoxFit.contain, ), Image( image: img, width: 100.0, height: 50.0, fit: BoxFit.cover, ), Image( image: img, width: 100.0, height: 50.0, fit: BoxFit.fitWidth, ), Image( image: img, width: 100.0, height: 50.0, fit: BoxFit.fitHeight, ), Image( image: img, width: 100.0, height: 50.0, fit: BoxFit.scaleDown, ), Image( image: img, height: 50.0, width: 100.0, fit: BoxFit.none, ), Image( image: img, width: 100.0, color: Colors.blue, colorBlendMode: BlendMode.difference, fit: BoxFit.fill, ), Image( image: img, width: 100.0, height: 200.0, repeat: ImageRepeat.repeatY , ) ].map((e){ return Row( children: [ Padding( padding: EdgeInsets.all(16.0), child: SizedBox( width: 100, child: e, ), ), Text(e.fit.toString()) ], ); }).toList() ), ); } } Image缓存 Flutter框架对加载过的图片是有缓存的（内存），默认最大缓存数量是1000，最大缓存空间为100M。关于Image的详细内容及原理我们将会在后面进阶部分深入介绍。 3.5.2 ICON Flutter中，可以像Web开发一样使用iconfont，iconfont即“字体图标”，它是将图标做成字体文件，然后通过指定不同的字符而显示不同的图片。 在字体文件中，每一个字符都对应一个位码，而每一个位码对应一个显示字形，不同的字体就是指字形不同，即字符对应的字形是不同的。而在iconfont中，只是将位码对应的字形做成了图标，所以不同的字符最终就会渲染成不同的图标。 在Flutter开发中，iconfont和图片相比有如下优势： 体积小：可以减小安装包大小。 矢量的：iconfont都是矢量图标，放大不会影响其清晰度。 可以应用文本样式：可以像文本一样改变字体图标的颜色、大小对齐等。 可以通过TextSpan和文本混用。 使用Material Design字体图标 Flutter默认包含了一套Material Design的字体图标，在pubspec.yaml文件中的配置如下 flutter: uses-material-design: true Material Design所有图标可以在其官网查看：https://material.io/tools/icons/ 我们看一个简单的例子： String icons = \"\"; // accessible: &#xE914; or 0xE914 or E914 icons += \"\\uE914\"; // error: &#xE000; or 0xE000 or E000 icons += \" \\uE000\"; // fingerprint: &#xE90D; or 0xE90D or E90D icons += \" \\uE90D\"; Text(icons, style: TextStyle( fontFamily: \"MaterialIcons\", fontSize: 24.0, color: Colors.green ), ); 运行效果如图3-21所示： 通过这个示例可以看到，使用图标就像使用文本一样，但是这种方式需要我们提供每个图标的码点，这并对开发者不友好，所以，Flutter封装了IconData和Icon来专门显示字体图标，上面的例子也可以用如下方式实现： Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(Icons.accessible,color: Colors.green,), Icon(Icons.error,color: Colors.green,), Icon(Icons.fingerprint,color: Colors.green,), ], ) Icons类中包含了所有Material Design图标的IconData静态变量定义。 使用自定义字体图标 我们也可以使用自定义字体图标。iconfont.cn上有很多字体图标素材，我们可以选择自己需要的图标打包下载后，会生成一些不同格式的字体文件，在Flutter中，我们使用ttf格式即可。 假设我们项目中需要使用一个书籍图标和微信图标，我们打包下载后导入： 导入字体图标文件；这一步和导入字体文件相同，假设我们的字体图标文件保存在项目根目录下，路径为\"fonts/iconfont.ttf\"： fonts: - family: myIcon #指定一个字体名 fonts: - asset: fonts/iconfont.ttf 为了使用方便，我们定义一个MyIcons类，功能和Icons类一样：将字体文件中的所有图标都定义成静态变量： class MyIcons{ // book 图标 static const IconData book = const IconData( 0xe614, fontFamily: 'myIcon', matchTextDirection: true ); // 微信图标 static const IconData wechat = const IconData( 0xec7d, fontFamily: 'myIcon', matchTextDirection: true ); } 使用 Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(MyIcons.book,color: Colors.purple,), Icon(MyIcons.wechat,color: Colors.green,), ], ) 运行后效果如图3-22所示： "},"chapter3/radio_and_checkbox.html":{"url":"chapter3/radio_and_checkbox.html","title":"3.6：单选框和复选框","keywords":"","body":"3.6 单选开关和复选框 Material 组件库中提供了Material风格的单选开关Switch和复选框Checkbox，它们都是继承自StatelessWidget，所以它们本身不会保存当前选择状态，因此它们的选中状态都是由父组件来管理的。当Switch或Checkbox被点击时，会触发它们的onChanged回调，我们可以在此回调中处理选中状态改变逻辑。下面看一个简单的例子： class SwitchAndCheckBoxTestRoute extends StatefulWidget { @override _SwitchAndCheckBoxTestRouteState createState() => new _SwitchAndCheckBoxTestRouteState(); } class _SwitchAndCheckBoxTestRouteState extends State { bool _switchSelected=true; //维护单选开关状态 bool _checkboxSelected=true;//维护复选框状态 @override Widget build(BuildContext context) { return Column( children: [ Switch( value: _switchSelected,//当前状态 onChanged:(value){ //重新构建页面 setState(() { _switchSelected=value; }); }, ), Checkbox( value: _checkboxSelected, activeColor: Colors.red, //选中时的颜色 onChanged:(value){ setState(() { _checkboxSelected=value; }); } , ) ], ); } } 上面代码中，由于需要维护Switch和Checkbox的选中状态，所以SwitchAndCheckBoxTestRoute继承自StatefulWidget 。在其build方法中分别构建了一个Switch和Checkbox，初始状态都为选中状态，当用户点击时，会将状态置反，然后回调用setState()通知Flutter framework重新构建UI。 属性及外观 Switch和Checkbox属性比较简单，读者可以查看API文档，它们都有一个activeColor属性，用于设置激活态的颜色。至于大小，到目前为止，Checkbox的大小是固定的，无法自定义，而Switch只能定义宽度，高度也是固定的。值得一提的是Checkbox有一个属性tristate ，表示是否为三态，其默认值为false ，这时Checkbox有两种状态即“选中”和“不选中”，对应的value值为true和false 。如果tristate值为true时，value的值会增加一个状态null，读者可以自行了解。 总结 通过Switch和Checkbox我们可以看到，虽然它们本身是与状态（是否选中）关联的，但它们却不是自己来维护状态，而是需要父组件来管理状态，然后当用户点击时，再通过事件通知给父组件，这样是合理的，因为Switch和Checkbox是否选中本就和用户数据关联，而这些用户数据也不可能是它们的私有状态。我们在自定义组件时也应该思考一下哪种状态的管理方式最为合理。 "},"chapter3/input_and_form.html":{"url":"chapter3/input_and_form.html","title":"3.7：输入框和表单","keywords":"","body":"3.7 输入框及表单 Material组件库中提供了输入框组件TextField和表单组件Form。下面我们分别介绍一下。 3.7.1 TextField TextField用于文本输入，它提供了很多属性，我们先简单介绍一下主要属性的作用，然后通过几个示例来演示一下关键属性的用法。 const TextField({ ... TextEditingController controller, FocusNode focusNode, InputDecoration decoration = const InputDecoration(), TextInputType keyboardType, TextInputAction textInputAction, TextStyle style, TextAlign textAlign = TextAlign.start, bool autofocus = false, bool obscureText = false, int maxLines = 1, int maxLength, bool maxLengthEnforced = true, ValueChanged onChanged, VoidCallback onEditingComplete, ValueChanged onSubmitted, List inputFormatters, bool enabled, this.cursorWidth = 2.0, this.cursorRadius, this.cursorColor, ... }) controller：编辑框的控制器，通过它可以设置/获取编辑框的内容、选择编辑内容、监听编辑文本改变事件。大多数情况下我们都需要显式提供一个controller来与文本框交互。如果没有提供controller，则TextField内部会自动创建一个。 focusNode：用于控制TextField是否占有当前键盘的输入焦点。它是我们和键盘交互的一个handle。 InputDecoration：用于控制TextField的外观显示，如提示文本、背景颜色、边框等。 keyboardType：用于设置该输入框默认的键盘输入类型，取值如下： | TextInputType枚举值 | 含义 | | ------------------- | --------------------------------------------------- | | text | 文本输入键盘 | | multiline | 多行文本，需和maxLines配合使用(设为null或大于1) | | number | 数字；会弹出数字键盘 | | phone | 优化后的电话号码输入键盘；会弹出数字键盘并显示\"* #\" | | datetime | 优化后的日期输入键盘；Android上会显示“: -” | | emailAddress | 优化后的电子邮件地址；会显示“@ .” | | url | 优化后的url输入键盘； 会显示“/ .” | textInputAction：键盘动作按钮图标(即回车键位图标)，它是一个枚举值，有多个可选值，全部的取值列表读者可以查看API文档，下面是当值为TextInputAction.search时，原生Android系统下键盘样式如图3-24所示： style：正在编辑的文本样式。 textAlign: 输入框内编辑文本在水平方向的对齐方式。 autofocus: 是否自动获取焦点。 obscureText：是否隐藏正在编辑的文本，如用于输入密码的场景等，文本内容会用“•”替换。 maxLines：输入框的最大行数，默认为1；如果为null，则无行数限制。 maxLength和maxLengthEnforced ：maxLength代表输入框文本的最大长度，设置后输入框右下角会显示输入的文本计数。maxLengthEnforced决定当输入文本长度超过maxLength时是否阻止输入，为true时会阻止输入，为false时不会阻止输入但输入框会变红。 onChange：输入框内容改变时的回调函数；注：内容改变事件也可以通过controller来监听。 onEditingComplete和onSubmitted：这两个回调都是在输入框输入完成时触发，比如按了键盘的完成键（对号图标）或搜索键（🔍图标）。不同的是两个回调签名不同，onSubmitted回调是ValueChanged类型，它接收当前输入内容做为参数，而onEditingComplete不接收参数。 inputFormatters：用于指定输入格式；当用户输入内容改变时，会根据指定的格式来校验。 enable：如果为false，则输入框会被禁用，禁用状态不接收输入和事件，同时显示禁用态样式（在其decoration中定义）。 cursorWidth、cursorRadius和cursorColor：这三个属性是用于自定义输入框光标宽度、圆角和颜色的。 示例：登录输入框 布局 Column( children: [ TextField( autofocus: true, decoration: InputDecoration( labelText: \"用户名\", hintText: \"用户名或邮箱\", prefixIcon: Icon(Icons.person) ), ), TextField( decoration: InputDecoration( labelText: \"密码\", hintText: \"您的登录密码\", prefixIcon: Icon(Icons.lock) ), obscureText: true, ), ], ); 运行后，效果如图3-25所示： 获取输入内容 获取输入内容有两种方式： 定义两个变量，用于保存用户名和密码，然后在onChange触发时，各自保存一下输入内容。 通过controller直接获取。 第一种方式比较简单，不在举例，我们来重点看一下第二种方式，我们以用户名输入框举例： 定义一个controller： //定义一个controller TextEditingController _unameController = TextEditingController(); 然后设置输入框controller： TextField( autofocus: true, controller: _unameController, //设置controller ... ) 通过controller获取输入框内容 print(_unameController.text) 监听文本变化 监听文本变化也有两种方式： 设置onChange回调，如： TextField( autofocus: true, onChanged: (v) { print(\"onChange: $v\"); } ) 通过controller监听，如： @override void initState() { //监听输入改变 _unameController.addListener((){ print(_unameController.text); }); } 两种方式相比，onChanged是专门用于监听文本变化，而controller的功能却多一些，除了能监听文本变化外，它还可以设置默认值、选择文本，下面我们看一个例子： 创建一个controller: TextEditingController _selectionController = TextEditingController(); 设置默认值，并从第三个字符开始选中后面的字符 _selectionController.text=\"hello world!\"; _selectionController.selection=TextSelection( baseOffset: 2, extentOffset: _selectionController.text.length ); 设置controller: TextField( controller: _selectionController, ) 运行效果如图3-26所示： 控制焦点 焦点可以通过FocusNode和FocusScopeNode来控制，默认情况下，焦点由FocusScope来管理，它代表焦点控制范围，可以在这个范围内可以通过FocusScopeNode在输入框之间移动焦点、设置默认焦点等。我们可以通过FocusScope.of(context) 来获取Widget树中默认的FocusScopeNode。下面看一个示例，在此示例中创建两个TextField，第一个自动获取焦点，然后创建两个按钮： 点击第一个按钮可以将焦点从第一个TextField挪到第二个TextField。 点击第二个按钮可以关闭键盘。 我们要实现的效果如图3-27所示： 代码如下： class FocusTestRoute extends StatefulWidget { @override _FocusTestRouteState createState() => new _FocusTestRouteState(); } class _FocusTestRouteState extends State { FocusNode focusNode1 = new FocusNode(); FocusNode focusNode2 = new FocusNode(); FocusScopeNode focusScopeNode; @override Widget build(BuildContext context) { return Padding( padding: EdgeInsets.all(16.0), child: Column( children: [ TextField( autofocus: true, focusNode: focusNode1,//关联focusNode1 decoration: InputDecoration( labelText: \"input1\" ), ), TextField( focusNode: focusNode2,//关联focusNode2 decoration: InputDecoration( labelText: \"input2\" ), ), Builder(builder: (ctx) { return Column( children: [ RaisedButton( child: Text(\"移动焦点\"), onPressed: () { //将焦点从第一个TextField移到第二个TextField // 这是一种写法 FocusScope.of(context).requestFocus(focusNode2); // 这是第二种写法 if(null == focusScopeNode){ focusScopeNode = FocusScope.of(context); } focusScopeNode.requestFocus(focusNode2); }, ), RaisedButton( child: Text(\"隐藏键盘\"), onPressed: () { // 当所有编辑框都失去焦点时键盘就会收起 focusNode1.unfocus(); focusNode2.unfocus(); }, ), ], ); }, ), ], ), ); } } FocusNode和FocusScopeNode还有一些其它的方法，详情可以查看API文档。 监听焦点状态改变事件 FocusNode继承自ChangeNotifier，通过FocusNode可以监听焦点的改变事件，如： ... // 创建 focusNode FocusNode focusNode = new FocusNode(); ... // focusNode绑定输入框 TextField(focusNode: focusNode); ... // 监听焦点变化 focusNode.addListener((){ print(focusNode.hasFocus); }); 获得焦点时focusNode.hasFocus值为true，失去焦点时为false。 自定义样式 虽然我们可以通过decoration属性来定义输入框样式，但是有一些样式如下划线默认颜色及宽度都是不能直接自定义的，下面的代码没有效果： TextField( ... decoration: InputDecoration( border: UnderlineInputBorder( //下面代码没有效果 borderSide: BorderSide( color: Colors.red, width: 5.0 )), prefixIcon: Icon(Icons.person) ), ), 之所以如此，是由于TextField在绘制下划线时使用的颜色是主题色里面的hintColor，但提示文本颜色也是用的hintColor， 如果我们直接修改hintColor，那么下划线和提示文本的颜色都会变。值得高兴的是decoration中可以设置hintStyle，它可以覆盖hintColor，并且主题中可以通过inputDecorationTheme来设置输入框默认的decoration。所以我们可以通过主题来自定义，代码如下： Theme( data: Theme.of(context).copyWith( hintColor: Colors.grey[200], //定义下划线颜色 inputDecorationTheme: InputDecorationTheme( labelStyle: TextStyle(color: Colors.grey),//定义label字体样式 hintStyle: TextStyle(color: Colors.grey, fontSize: 14.0)//定义提示文本样式 ) ), child: Column( children: [ TextField( decoration: InputDecoration( labelText: \"用户名\", hintText: \"用户名或邮箱\", prefixIcon: Icon(Icons.person) ), ), TextField( decoration: InputDecoration( prefixIcon: Icon(Icons.lock), labelText: \"密码\", hintText: \"您的登录密码\", hintStyle: TextStyle(color: Colors.grey, fontSize: 13.0) ), obscureText: true, ) ], ) ) 运行效果如图3-28所示： 我们成功的自定义了下划线颜色和提问文字样式，细心的读者可能已经发现，通过这种方式自定义后，输入框在获取焦点时，labelText不会高亮显示了，正如上图中的\"用户名\"本应该显示蓝色，但现在却显示为灰色，并且我们还是无法定义下划线宽度。另一种灵活的方式是直接隐藏掉TextField本身的下划线，然后通过Container去嵌套定义样式，如: Container( child: TextField( keyboardType: TextInputType.emailAddress, decoration: InputDecoration( labelText: \"Email\", hintText: \"电子邮件地址\", prefixIcon: Icon(Icons.email), border: InputBorder.none //隐藏下划线 ) ), decoration: BoxDecoration( // 下滑线浅灰色，宽度1像素 border: Border(bottom: BorderSide(color: Colors.grey[200], width: 1.0)) ), ) 运行效果： 通过这种组件组合的方式，也可以定义背景圆角等。一般来说，优先通过decoration来自定义样式，如果decoration实现不了，再用widget组合的方式。 思考题：在这个示例中，下划线颜色是固定的，所以获得焦点后颜色仍然为灰色，如何实现点击后下滑线也变色呢？ 3.7.2 表单Form 实际业务中，在正式向服务器提交数据前，都会对各个输入框数据进行合法性校验，但是对每一个TextField都分别进行校验将会是一件很麻烦的事。还有，如果用户想清除一组TextField的内容，除了一个一个清除有没有什么更好的办法呢？为此，Flutter提供了一个Form 组件，它可以对输入框进行分组，然后进行一些统一操作，如输入内容校验、输入框重置以及输入内容保存。 Form Form继承自StatefulWidget对象，它对应的状态类为FormState。我们先看看Form类的定义： Form({ @required Widget child, bool autovalidate = false, WillPopCallback onWillPop, VoidCallback onChanged, }) autovalidate：是否自动校验输入内容；当为true时，每一个子FormField内容发生变化时都会自动校验合法性，并直接显示错误信息。否则，需要通过调用FormState.validate()来手动校验。 onWillPop：决定Form所在的路由是否可以直接返回（如点击返回按钮），该回调返回一个Future对象，如果Future的最终结果是false，则当前路由不会返回；如果为true，则会返回到上一个路由。此属性通常用于拦截返回按钮。 onChanged：Form的任意一个子FormField内容发生变化时会触发此回调。 FormField Form的子孙元素必须是FormField类型，FormField是一个抽象类，定义几个属性，FormState内部通过它们来完成操作，FormField部分定义如下： const FormField({ ... FormFieldSetter onSaved, //保存回调 FormFieldValidator validator, //验证回调 T initialValue, //初始值 bool autovalidate = false, //是否自动校验。 }) 为了方便使用，Flutter提供了一个TextFormField组件，它继承自FormField类，也是TextField的一个包装类，所以除了FormField定义的属性之外，它还包括TextField的属性。 FormState FormState为Form的State类，可以通过Form.of()或GlobalKey获得。我们可以通过它来对Form的子孙FormField进行统一操作。我们看看其常用的三个方法： FormState.validate()：调用此方法后，会调用Form子孙FormField的validate回调，如果有一个校验失败，则返回false，所有校验失败项都会返回用户返回的错误提示。 FormState.save()：调用此方法后，会调用Form子孙FormField的save回调，用于保存表单内容 FormState.reset()：调用此方法后，会将子孙FormField的内容清空。 示例 我们修改一下上面用户登录的示例，在提交之前校验： 用户名不能为空，如果为空则提示“用户名不能为空”。 密码不能小于6位，如果小于6为则提示“密码不能少于6位”。 完整代码： class FormTestRoute extends StatefulWidget { @override _FormTestRouteState createState() => new _FormTestRouteState(); } class _FormTestRouteState extends State { TextEditingController _unameController = new TextEditingController(); TextEditingController _pwdController = new TextEditingController(); GlobalKey _formKey= new GlobalKey(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title:Text(\"Form Test\"), ), body: Padding( padding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 24.0), child: Form( key: _formKey, //设置globalKey，用于后面获取FormState autovalidate: true, //开启自动校验 child: Column( children: [ TextFormField( autofocus: true, controller: _unameController, decoration: InputDecoration( labelText: \"用户名\", hintText: \"用户名或邮箱\", icon: Icon(Icons.person) ), // 校验用户名 validator: (v) { return v .trim() .length > 0 ? null : \"用户名不能为空\"; } ), TextFormField( controller: _pwdController, decoration: InputDecoration( labelText: \"密码\", hintText: \"您的登录密码\", icon: Icon(Icons.lock) ), obscureText: true, //校验密码 validator: (v) { return v .trim() .length > 5 ? null : \"密码不能少于6位\"; } ), // 登录按钮 Padding( padding: const EdgeInsets.only(top: 28.0), child: Row( children: [ Expanded( child: RaisedButton( padding: EdgeInsets.all(15.0), child: Text(\"登录\"), color: Theme .of(context) .primaryColor, textColor: Colors.white, onPressed: () { //在这里不能通过此方式获取FormState，context不对 //print(Form.of(context)); // 通过_formKey.currentState 获取FormState后， // 调用validate()方法校验用户名密码是否合法，校验 // 通过后再提交数据。 if((_formKey.currentState as FormState).validate()){ //验证通过提交数据 } }, ), ), ], ), ) ], ), ), ), ); } } 运行后效果如图3-29所示： 注意，登录按钮的onPressed方法中不能通过Form.of(context)来获取，原因是，此处的context为FormTestRoute的context，而Form.of(context)是根据所指定context向根去查找，而FormState是在FormTestRoute的子树中，所以不行。正确的做法是通过Builder来构建登录按钮，Builder会将widget节点的context作为回调参数： Expanded( // 通过Builder来获取RaisedButton所在widget树的真正context(Element) child:Builder(builder: (context){ return RaisedButton( ... onPressed: () { //由于本widget也是Form的子代widget，所以可以通过下面方式获取FormState if(Form.of(context).validate()){ //验证通过提交数据 } }, ); }) ) 其实context正是操作Widget所对应的Element的一个接口，由于Widget树对应的Element都是不同的，所以context也都是不同的，有关context的更多内容会在后面高级部分详细讨论。Flutter中有很多“of(context)”这种方法，读者在使用时一定要注意context是否正确。 "},"chapter3/progress.html":{"url":"chapter3/progress.html","title":"3.8：进度指示器","keywords":"","body":"3.8 进度指示器 Material 组件库中提供了两种进度指示器：LinearProgressIndicator和CircularProgressIndicator，它们都可以同时用于精确的进度指示和模糊的进度指示。精确进度通常用于任务进度可以计算和预估的情况，比如文件下载；而模糊进度则用户任务进度无法准确获得的情况，如下拉刷新，数据提交等。 LinearProgressIndicator LinearProgressIndicator是一个线性、条状的进度条，定义如下： LinearProgressIndicator({ double value, Color backgroundColor, Animation valueColor, ... }) value：value表示当前的进度，取值范围为[0,1]；如果value为null时则指示器会执行一个循环动画（模糊进度）；当value不为null时，指示器为一个具体进度的进度条。 backgroundColor：指示器的背景色。 valueColor: 指示器的进度条颜色；值得注意的是，该值类型是Animation，这允许我们对进度条的颜色也可以指定动画。如果我们不需要对进度条颜色执行动画，换言之，我们想对进度条应用一种固定的颜色，此时我们可以通过AlwaysStoppedAnimation来指定。 示例 // 模糊进度条(会执行一个动画) LinearProgressIndicator( backgroundColor: Colors.grey[200], valueColor: AlwaysStoppedAnimation(Colors.blue), ), //进度条显示50% LinearProgressIndicator( backgroundColor: Colors.grey[200], valueColor: AlwaysStoppedAnimation(Colors.blue), value: .5, ) 运行效果如图3-30所示： 第一个进度条在执行循环动画：蓝色条一直在移动，而第二个进度条是静止的，停在50%的位置。 CircularProgressIndicator CircularProgressIndicator是一个圆形进度条，定义如下： CircularProgressIndicator({ double value, Color backgroundColor, Animation valueColor, this.strokeWidth = 4.0, ... }) 前三个参数和LinearProgressIndicator相同，不再赘述。strokeWidth 表示圆形进度条的粗细。示例如下： // 模糊进度条(会执行一个旋转动画) CircularProgressIndicator( backgroundColor: Colors.grey[200], valueColor: AlwaysStoppedAnimation(Colors.blue), ), //进度条显示50%，会显示一个半圆 CircularProgressIndicator( backgroundColor: Colors.grey[200], valueColor: AlwaysStoppedAnimation(Colors.blue), value: .5, ), 运行效果如图3-31所示： 第一个进度条会执行旋转动画，而第二个进度条是静止的，它停在50%的位置。 自定义尺寸 我们可以发现LinearProgressIndicator和CircularProgressIndicator，并没有提供设置圆形进度条尺寸的参数；如果我们希望LinearProgressIndicator的现细一些，或者希望CircularProgressIndicator的圆大一些该怎么做？ 其实LinearProgressIndicator和CircularProgressIndicator都是取父容器的尺寸作为绘制的边界的。知道了这点，我们便可以通过尺寸限制类Widget，如ConstrainedBox、SizedBox （我们将在后面容器类组件一章中介绍）来指定尺寸，如： // 线性进度条高度指定为3 SizedBox( height: 3, child: LinearProgressIndicator( backgroundColor: Colors.grey[200], valueColor: AlwaysStoppedAnimation(Colors.blue), value: .5, ), ), // 圆形进度条直径指定为100 SizedBox( height: 100, width: 100, child: CircularProgressIndicator( backgroundColor: Colors.grey[200], valueColor: AlwaysStoppedAnimation(Colors.blue), value: .7, ), ), 运行效果如图3-32所示： 注意，如果CircularProgressIndicator显示空间的宽高不同，则会显示为椭圆。如： // 宽高不等 SizedBox( height: 100, width: 130, child: CircularProgressIndicator( backgroundColor: Colors.grey[200], valueColor: AlwaysStoppedAnimation(Colors.blue), value: .7, ), ), 运行效果如图3-33所示： 进度色动画 前面说过可以通过valueColor对进度条颜色做动画，关于动画我们将在后面专门的章节详细介绍，这里先给出一个例子，读者在了解了Flutter动画一章后再回过头来看。 我们实现一个进度条在3秒内从灰色变成蓝色的动画： import 'package:flutter/material.dart'; class ProgressRoute extends StatefulWidget { @override _ProgressRouteState createState() => _ProgressRouteState(); } class _ProgressRouteState extends State with SingleTickerProviderStateMixin { AnimationController _animationController; @override void initState() { //动画执行时间3秒 _animationController = new AnimationController(vsync: this, duration: Duration(seconds: 3)); _animationController.forward(); _animationController.addListener(() => setState(() => {})); super.initState(); } @override void dispose() { _animationController.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return SingleChildScrollView( child: Column( children: [ Padding( padding: EdgeInsets.all(16), child: LinearProgressIndicator( backgroundColor: Colors.grey[200], valueColor: ColorTween(begin: Colors.grey, end: Colors.blue) .animate(_animationController), // 从灰色变成蓝色 value: _animationController.value, ), ); ], ), ); } } 自定义进度指示器样式 定制进度指示器风格样式，可以通过CustomPainter Widget 来自定义绘制逻辑，实际上LinearProgressIndicator和CircularProgressIndicator也正是通过CustomPainter来实现外观绘制的。关于CustomPainter，我们将在后面“自定义Widget”一章中详细介绍。 flutter_spinkit 包提供了多种风格的模糊进度指示器，读者若是感兴趣，可以参考。 "},"chapter4/":{"url":"chapter4/","title":"第四章：布局类组件","keywords":"","body":"本章目录 4.1：布局类组件简介 4.2：线性布局（Row、Column） 4.3：弹性布局（Flex） 4.4：流式布局（Wrap、Flow） 4.5：层叠布局（Stack、Positioned） 4.6：对齐与相对定位（Align） "},"chapter4/intro.html":{"url":"chapter4/intro.html","title":"4.1：布局类组件简介","keywords":"","body":"4.1 布局类组件简介 布局类组件都会包含一个或多个子组件，不同的布局类组件对子组件排版(layout)方式不同。我们在前面说过Element树才是最终的绘制树，Element树是通过Widget树来创建的（通过Widget.createElement()），嗯Widget其实就是Element的配置数据。在Flutter中，根据Widget是否需要包含子节点将Widget分为了三类，分别对应三种Element，如下表： Widget 对应的Element 用途 LeafRenderObjectWidget LeafRenderObjectElement Widget树的叶子节点，用于没有子节点的widget，通常基础组件都属于这一类，如Text、Image。 SingleChildRenderObjectWidget SingleChildRenderObjectElement 包含一个子Widget，如：ConstrainedBox、DecoratedBox等 MultiChildRenderObjectWidget MultiChildRenderObjectElement 包含多个子Widget，一般都有一个children参数，接受一个Widget数组。如Row、Column、Stack等 注意，Flutter中的很多Widget是直接继承自StatelessWidget或StatefulWidget，然后在build()方法中构建真正的RenderObjectWidget，如Text，它其实是继承自StatelessWidget，然后在build()方法中通过RichText来构建其子树，而RichText才是继承自LeafRenderObjectWidget。所以为了方便叙述，我们也可以直接说Text属于LeafRenderObjectWidget（其它widget也可以这么描述），这才是本质。读到这里我们也会发现，其实StatelessWidget和StatefulWidget就是两个用于组合Widget的基类，它们本身并不关联最终的渲染对象（RenderObjectWidget）。 布局类组件就是指直接或间接继承(包含)MultiChildRenderObjectWidget的Widget，它们一般都会有一个children属性用于接收子Widget。我们看一下继承关系 Widget > RenderObjectWidget > (Leaf/SingleChild/MultiChild)RenderObjectWidget 。 RenderObjectWidget类中定义了创建、更新RenderObject的方法，子类必须实现他们，关于RenderObject我们现在只需要知道它是最终布局、渲染UI界面的对象即可，也就是说，对于布局类组件来说，其布局算法都是通过对应的RenderObject对象来实现的，所以读者如果对接下来介绍的某个布局类组件的原理感兴趣，可以查看其对应的RenderObject的实现，比如Stack（层叠布局）对应的RenderObject对象就是RenderStack，而层叠布局的实现就在RenderStack中。 在本章中，为了让读者对布局类Widget有个快速的认识，所以我们并不会深入到RenderObject的细节中去。在学习本章时，读者的重点是掌握不同布局组件的布局特点，具体原理和细节等我们对Flutter整体入门后，感兴趣的话再去研究。 "},"chapter4/row_and_column.html":{"url":"chapter4/row_and_column.html","title":"4.2：线性布局（Row、Column）","keywords":"","body":"4.2 线性布局（Row和Column） 所谓线性布局，即指沿水平或垂直方向排布子组件。Flutter中通过Row和Column来实现线性布局，类似于Android中的LinearLayout控件。Row和Column都继承自Flex，我们将在弹性布局一节中详细介绍Flex。 主轴和纵轴 对于线性布局，有主轴和纵轴之分，如果布局是沿水平方向，那么主轴就是指水平方向，而纵轴即垂直方向；如果布局沿垂直方向，那么主轴就是指垂直方向，而纵轴就是水平方向。在线性布局中，有两个定义对齐方式的枚举类MainAxisAlignment和CrossAxisAlignment，分别代表主轴对齐和纵轴对齐。 Row Row可以在水平方向排列其子widget。定义如下： Row({ ... TextDirection textDirection, MainAxisSize mainAxisSize = MainAxisSize.max, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, VerticalDirection verticalDirection = VerticalDirection.down, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, List children = const [], }) textDirection：表示水平方向子组件的布局顺序(是从左往右还是从右往左)，默认为系统当前Locale环境的文本方向(如中文、英语都是从左往右，而阿拉伯语是从右往左)。 mainAxisSize：表示Row在主轴(水平)方向占用的空间，默认是MainAxisSize.max，表示尽可能多的占用水平方向的空间，此时无论子widgets实际占用多少水平空间，Row的宽度始终等于水平方向的最大宽度；而MainAxisSize.min表示尽可能少的占用水平空间，当子组件没有占满水平剩余空间，则Row的实际宽度等于所有子组件占用的的水平空间； mainAxisAlignment：表示子组件在Row所占用的水平空间内对齐方式，如果mainAxisSize值为MainAxisSize.min，则此属性无意义，因为子组件的宽度等于Row的宽度。只有当mainAxisSize的值为MainAxisSize.max时，此属性才有意义，MainAxisAlignment.start表示沿textDirection的初始方向对齐，如textDirection取值为TextDirection.ltr时，则MainAxisAlignment.start表示左对齐，textDirection取值为TextDirection.rtl时表示从右对齐。而MainAxisAlignment.end和MainAxisAlignment.start正好相反；MainAxisAlignment.center表示居中对齐。读者可以这么理解：textDirection是mainAxisAlignment的参考系。 verticalDirection：表示Row纵轴（垂直）的对齐方向，默认是VerticalDirection.down，表示从上到下。 crossAxisAlignment：表示子组件在纵轴方向的对齐方式，Row的高度等于子组件中最高的子元素高度，它的取值和MainAxisAlignment一样(包含start、end、 center三个值)，不同的是crossAxisAlignment的参考系是verticalDirection，即verticalDirection值为VerticalDirection.down时crossAxisAlignment.start指顶部对齐，verticalDirection值为VerticalDirection.up时，crossAxisAlignment.start指底部对齐；而crossAxisAlignment.end和crossAxisAlignment.start正好相反； children ：子组件数组。 示例 请阅读下面代码，先想象一下运行的结果： Column( //测试Row对齐方式，排除Column默认居中对齐的干扰 crossAxisAlignment: CrossAxisAlignment.start, children: [ Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Text(\" hello world \"), Text(\" I am Jack \"), ], ), Row( mainAxisSize: MainAxisSize.min, mainAxisAlignment: MainAxisAlignment.center, children: [ Text(\" hello world \"), Text(\" I am Jack \"), ], ), Row( mainAxisAlignment: MainAxisAlignment.end, textDirection: TextDirection.rtl, children: [ Text(\" hello world \"), Text(\" I am Jack \"), ], ), Row( crossAxisAlignment: CrossAxisAlignment.start, verticalDirection: VerticalDirection.up, children: [ Text(\" hello world \", style: TextStyle(fontSize: 30.0),), Text(\" I am Jack \"), ], ), ], ); 实际运行结果如图4-1所示： 解释：第一个Row很简单，默认为居中对齐；第二个Row，由于mainAxisSize值为MainAxisSize.min，Row的宽度等于两个Text的宽度和，所以对齐是无意义的，所以会从左往右显示；第三个Row设置textDirection值为TextDirection.rtl，所以子组件会从右向左的顺序排列，而此时MainAxisAlignment.end表示左对齐，所以最终显示结果就是图中第三行的样子；第四个Row测试的是纵轴的对齐方式，由于两个子Text字体不一样，所以其高度也不同，我们指定了verticalDirection值为VerticalDirection.up，即从低向顶排列，而此时crossAxisAlignment值为CrossAxisAlignment.start表示底对齐。 Column Column可以在垂直方向排列其子组件。参数和Row一样，不同的是布局方向为垂直，主轴纵轴正好相反，读者可类比Row来理解，下面看一个例子： import 'package:flutter/material.dart'; class CenterColumnRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Column( crossAxisAlignment: CrossAxisAlignment.center, children: [ Text(\"hi\"), Text(\"world\"), ], ); } } 运行效果如图4-2所示： 解释： 由于我们没有指定Column的mainAxisSize，所以使用默认值MainAxisSize.max，则Column会在垂直方向占用尽可能多的空间，此例中为屏幕高度。 由于我们指定了 crossAxisAlignment 属性为CrossAxisAlignment.center，那么子项在Column纵轴方向（此时为水平方向）会居中对齐。注意，在水平方向对齐是有边界的，总宽度为Column占用空间的实际宽度，而实际的宽度取决于子项中宽度最大的Widget。在本例中，Column有两个子Widget，而显示“world”的Text宽度最大，所以Column的实际宽度则为Text(\"world\") 的宽度，所以居中对齐后Text(\"hi\")会显示在Text(\"world\")的中间部分。 实际上，Row和Column都只会在主轴方向占用尽可能大的空间，而纵轴的长度则取决于他们最大子元素的长度。如果我们想让本例中的两个文本控件在整个手机屏幕中间对齐，我们有两种方法： 将Column的宽度指定为屏幕宽度；这很简单，我们可以通过ConstrainedBox或SizedBox（我们将在后面章节中专门介绍着两个Widget）来强制更改宽度限制，例如： ConstrainedBox( constraints: BoxConstraints(minWidth: double.infinity), child: Column( crossAxisAlignment: CrossAxisAlignment.center, children: [ Text(\"hi\"), Text(\"world\"), ], ), ); 将minWidth设为double.infinity，可以使宽度占用尽可能多的空间。 使用Center Widget；我们将在后面章节中介绍。 特殊情况 如果Row里面嵌套Row，或者Column里面再嵌套Column，那么只有对最外面的Row或Column会占用尽可能大的空间，里面Row或Column所占用的空间为实际大小，下面以Column为例说明： Container( color: Colors.green, child: Padding( padding: const EdgeInsets.all(16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisSize: MainAxisSize.max, //有效，外层Colum高度为整个屏幕 children: [ Container( color: Colors.red, child: Column( mainAxisSize: MainAxisSize.max,//无效，内层Colum高度为实际高度 children: [ Text(\"hello world \"), Text(\"I am Jack \"), ], ), ) ], ), ), ); 运行效果如图4-3所示： 如果要让里面的Column占满外部Column，可以使用Expanded 组件： Expanded( child: Container( color: Colors.red, child: Column( mainAxisAlignment: MainAxisAlignment.center, //垂直方向居中对齐 children: [ Text(\"hello world \"), Text(\"I am Jack \"), ], ), ), ) 运行效果如图4-4所示： 我们将在介绍弹性布局时详细介绍Expanded。 "},"chapter4/flex.html":{"url":"chapter4/flex.html","title":"4.3：弹性布局（Flex）","keywords":"","body":"4.3 弹性布局（Flex） 弹性布局允许子组件按照一定比例来分配父容器空间。弹性布局的概念在其它UI系统中也都存在，如H5中的弹性盒子布局，Android中的FlexboxLayout等。Flutter中的弹性布局主要通过Flex和Expanded来配合实现。 Flex Flex组件可以沿着水平或垂直方向排列子组件，如果你知道主轴方向，使用Row或Column会方便一些，因为Row和Column都继承自Flex，参数基本相同，所以能使用Flex的地方基本上都可以使用Row或Column。Flex本身功能是很强大的，它也可以和Expanded组件配合实现弹性布局。接下来我们只讨论Flex和弹性布局相关的属性(其它属性已经在介绍Row和Column时介绍过了)。 Flex({ ... @required this.direction, //弹性布局的方向, Row默认为水平方向，Column默认为垂直方向 List children = const [], }) Flex继承自MultiChildRenderObjectWidget，对应的RenderObject为RenderFlex，RenderFlex中实现了其布局算法。 Expanded 可以按比例“扩伸” Row、Column和Flex子组件所占用的空间。 const Expanded({ int flex = 1, @required Widget child, }) flex参数为弹性系数，如果为0或null，则child是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的Expanded按照其flex的比例来分割主轴的全部空闲空间。下面我们看一个例子： class FlexLayoutTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Column( children: [ //Flex的两个子widget按1：2来占据水平空间 Flex( direction: Axis.horizontal, children: [ Expanded( flex: 1, child: Container( height: 30.0, color: Colors.red, ), ), Expanded( flex: 2, child: Container( height: 30.0, color: Colors.green, ), ), ], ), Padding( padding: const EdgeInsets.only(top: 20.0), child: SizedBox( height: 100.0, //Flex的三个子widget，在垂直方向按2：1：1来占用100像素的空间 child: Flex( direction: Axis.vertical, children: [ Expanded( flex: 2, child: Container( height: 30.0, color: Colors.red, ), ), Spacer( flex: 1, ), Expanded( flex: 1, child: Container( height: 30.0, color: Colors.green, ), ), ], ), ), ), ], ); } } 运行效果如图4-5所示： 示例中的Spacer的功能是占用指定比例的空间，实际上它只是Expanded的一个包装类，Spacer的源码如下： class Spacer extends StatelessWidget { const Spacer({Key key, this.flex = 1}) : assert(flex != null), assert(flex > 0), super(key: key); final int flex; @override Widget build(BuildContext context) { return Expanded( flex: flex, child: const SizedBox.shrink(), ); } } 小结 弹性布局比较简单，唯一需要注意的就是Row、Column以及Flex的关系。 "},"chapter4/wrap_and_flow.html":{"url":"chapter4/wrap_and_flow.html","title":"4.4：流式布局（Wrap、Flow）","keywords":"","body":"4.4 流式布局 在介绍Row和Colum时，如果子widget超出屏幕范围，则会报溢出错误，如： Row( children: [ Text(\"xxx\"*100) ], ); 运行效果如图4-6所示： 可以看到，右边溢出部分报错。这是因为Row默认只有一行，如果超出屏幕不会折行。我们把超出屏幕显示范围会自动折行的布局称为流式布局。Flutter中通过Wrap和Flow来支持流式布局，将上例中的Row换成Wrap后溢出部分则会自动折行，下面我们分别介绍Wrap和Flow. 4.4.1 Wrap 下面是Wrap的定义: Wrap({ ... this.direction = Axis.horizontal, this.alignment = WrapAlignment.start, this.spacing = 0.0, this.runAlignment = WrapAlignment.start, this.runSpacing = 0.0, this.crossAxisAlignment = WrapCrossAlignment.start, this.textDirection, this.verticalDirection = VerticalDirection.down, List children = const [], }) 我们可以看到Wrap的很多属性在Row（包括Flex和Column）中也有，如direction、crossAxisAlignment、textDirection、verticalDirection等，这些参数意义是相同的，我们不再重复介绍，读者可以查阅前面介绍Row的部分。读者可以认为Wrap和Flex（包括Row和Column）除了超出显示范围后Wrap会折行外，其它行为基本相同。下面我们看一下Wrap特有的几个属性： spacing：主轴方向子widget的间距 runSpacing：纵轴方向的间距 runAlignment：纵轴方向的对齐方式 下面看一个示例子： Wrap( spacing: 8.0, // 主轴(水平)方向间距 runSpacing: 4.0, // 纵轴（垂直）方向间距 alignment: WrapAlignment.center, //沿主轴方向居中 children: [ new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('A')), label: new Text('Hamilton'), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('M')), label: new Text('Lafayette'), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('H')), label: new Text('Mulligan'), ), new Chip( avatar: new CircleAvatar(backgroundColor: Colors.blue, child: Text('J')), label: new Text('Laurens'), ), ], ) 运行效果如图4-7所示： 4.4.2 Flow 我们一般很少会使用Flow，因为其过于复杂，需要自己实现子widget的位置转换，在很多场景下首先要考虑的是Wrap是否满足需求。Flow主要用于一些需要自定义布局策略或性能要求较高(如动画中)的场景。Flow有如下优点： 性能好；Flow是一个对子组件尺寸以及位置调整非常高效的控件，Flow用转换矩阵在对子组件进行位置调整的时候进行了优化：在Flow定位过后，如果子组件的尺寸或者位置发生了变化，在FlowDelegate中的paintChildren()方法中调用context.paintChild 进行重绘，而context.paintChild在重绘时使用了转换矩阵，并没有实际调整组件位置。 灵活；由于我们需要自己实现FlowDelegate的paintChildren()方法，所以我们需要自己计算每一个组件的位置，因此，可以自定义布局策略。 缺点： 使用复杂。 不能自适应子组件大小，必须通过指定父容器大小或实现TestFlowDelegate的getSize返回固定大小。 示例： 我们对六个色块进行自定义流式布局： Flow( delegate: TestFlowDelegate(margin: EdgeInsets.all(10.0)), children: [ new Container(width: 80.0, height:80.0, color: Colors.red,), new Container(width: 80.0, height:80.0, color: Colors.green,), new Container(width: 80.0, height:80.0, color: Colors.blue,), new Container(width: 80.0, height:80.0, color: Colors.yellow,), new Container(width: 80.0, height:80.0, color: Colors.brown,), new Container(width: 80.0, height:80.0, color: Colors.purple,), ], ) 实现TestFlowDelegate: class TestFlowDelegate extends FlowDelegate { EdgeInsets margin = EdgeInsets.zero; TestFlowDelegate({this.margin}); @override void paintChildren(FlowPaintingContext context) { var x = margin.left; var y = margin.top; //计算每一个子widget的位置 for (int i = 0; i 运行效果见图4-8： 可以看到我们主要的任务就是实现paintChildren，它的主要任务是确定每个子widget位置。由于Flow不能自适应子widget的大小，我们通过在getSize返回一个固定大小来指定Flow的大小。 "},"chapter4/stack.html":{"url":"chapter4/stack.html","title":"4.5：层叠布局（Stack、Positioned）","keywords":"","body":"4.5 层叠布局 Stack、Positioned 层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子组件可以根据距父容器四个角的位置来确定自身的位置。绝对定位允许子组件堆叠起来（按照代码中声明的顺序）。Flutter中使用Stack和Positioned这两个组件来配合实现绝对定位。Stack允许子组件堆叠，而Positioned用于根据Stack的四个角来确定子组件的位置。 Stack Stack({ this.alignment = AlignmentDirectional.topStart, this.textDirection, this.fit = StackFit.loose, this.overflow = Overflow.clip, List children = const [], }) alignment：此参数决定如何去对齐没有定位（没有使用Positioned）或部分定位的子组件。所谓部分定位，在这里特指没有在某一个轴上定位：left、right为横轴，top、bottom为纵轴，只要包含某个轴上的一个定位属性就算在该轴上有定位。 textDirection：和Row、Wrap的textDirection功能一样，都用于确定alignment对齐的参考系，即：textDirection的值为TextDirection.ltr，则alignment的start代表左，end代表右，即从左往右的顺序；textDirection的值为TextDirection.rtl，则alignment的start代表右，end代表左，即从右往左的顺序。 fit：此参数用于确定没有定位的子组件如何去适应Stack的大小。StackFit.loose表示使用子组件的大小，StackFit.expand表示扩伸到Stack的大小。 overflow：此属性决定如何显示超出Stack显示空间的子组件；值为Overflow.clip时，超出部分会被剪裁（隐藏），值为Overflow.visible 时则不会。 Positioned const Positioned({ Key key, this.left, this.top, this.right, this.bottom, this.width, this.height, @required Widget child, }) left、top 、right、 bottom分别代表离Stack左、上、右、底四边的距离。width和height用于指定需要定位元素的宽度和高度。注意，Positioned的width、height 和其它地方的意义稍微有点区别，此处用于配合left、top 、right、 bottom来定位组件，举个例子，在水平方向时，你只能指定left、right、width三个属性中的两个，如指定left和width后，right会自动算出(left+width)，如果同时指定三个属性则会报错，垂直方向同理。 示例 在下面的例子中，我们通过对几个Text组件的定位来演示Stack和Positioned的特性： //通过ConstrainedBox来确保Stack占满屏幕 ConstrainedBox( constraints: BoxConstraints.expand(), child: Stack( alignment:Alignment.center , //指定未定位或部分定位widget的对齐方式 children: [ Container(child: Text(\"Hello world\",style: TextStyle(color: Colors.white)), color: Colors.red, ), Positioned( left: 18.0, child: Text(\"I am Jack\"), ), Positioned( top: 18.0, child: Text(\"Your friend\"), ) ], ), ); 运行效果见图4-9： 由于第一个子文本组件Text(\"Hello world\")没有指定定位，并且alignment值为Alignment.center，所以它会居中显示。第二个子文本组件Text(\"I am Jack\")只指定了水平方向的定位(left)，所以属于部分定位，即垂直方向上没有定位，那么它在垂直方向的对齐方式则会按照alignment指定的对齐方式对齐，即垂直方向居中。对于第三个子文本组件Text(\"Your friend\")，和第二个Text原理一样，只不过是水平方向没有定位，则水平方向居中。 我们给上例中的Stack指定一个fit属性，然后将三个子文本组件的顺序调整一下： Stack( alignment:Alignment.center , fit: StackFit.expand, //未定位widget占满Stack整个空间 children: [ Positioned( left: 18.0, child: Text(\"I am Jack\"), ), Container(child: Text(\"Hello world\",style: TextStyle(color: Colors.white)), color: Colors.red, ), Positioned( top: 18.0, child: Text(\"Your friend\"), ) ], ), 显示效果如图4-10所示： 可以看到，由于第二个子文本组件没有定位，所以fit属性会对它起作用，就会占满Stack。由于Stack子元素是堆叠的，所以第一个子文本组件被第二个遮住了，而第三个在最上层，所以可以正常显示。 "},"chapter4/alignment.html":{"url":"chapter4/alignment.html","title":"4.6：对齐与相对定位（Align）","keywords":"","body":"4.6 对齐与相对定位（Align） 在上一节中我们讲过通过Stack和Positioned，我们可以指定一个或多个子元素相对于父元素各个边的精确偏移，并且可以重叠。但如果我们只想简单的调整一个子元素在父元素中的位置的话，使用Align组件会更简单一些。 4.6.1 Align Align 组件可以调整子组件的位置，并且可以根据子组件的宽高来确定自身的的宽高，定义如下： Align({ Key key, this.alignment = Alignment.center, this.widthFactor, this.heightFactor, Widget child, }) alignment : 需要一个AlignmentGeometry类型的值，表示子组件在父组件中的起始位置。AlignmentGeometry 是一个抽象类，它有两个常用的子类：Alignment和 FractionalOffset，我们将在下面的示例中详细介绍。 widthFactor和heightFactor是用于确定Align 组件本身宽高的属性；它们是两个缩放因子，会分别乘以子元素的宽、高，最终的结果就是Align 组件的宽高。如果值为null，则组件的宽高将会占用尽可能多的空间。 示例 我们先来看一个简单的例子： Container( height: 120.0, width: 120.0, color: Colors.blue[50], child: Align( alignment: Alignment.topRight, child: FlutterLogo( size: 60, ), ), ) 运行效果如图4-11所示： FlutterLogo 是Flutter SDK提供的一个组件，内容就是Flutter的商标。在上面的例子中，我们显式指定了Container的宽、高都为120。如果我们不显式指定宽高，而通过同时指定widthFactor和heightFactor 为2也是可以达到同样的效果： Align( widthFactor: 2, heightFactor: 2, alignment: Alignment.topRight, child: FlutterLogo( size: 60, ), ), 因为FlutterLogo的宽高为60，则Align的最终宽高都为2*60=120。 另外，我们通过Alignment.topRight将FlutterLogo定位在Container的右上角。那Alignment.topRight是什么呢？通过源码我们可以看到其定义如下： //右上角 static const Alignment topRight = Alignment(1.0, -1.0); 可以看到它只是Alignment的一个实例，下面我们介绍一下Alignment。 Alignment Alignment继承自AlignmentGeometry，表示矩形内的一个点，他有两个属性x、y，分别表示在水平和垂直方向的偏移，Alignment定义如下： Alignment(this.x, this.y) Alignment Widget会以矩形的中心点作为坐标原点，即Alignment(0.0, 0.0) 。x、y的值从-1到1分别代表矩形左边到右边的距离和顶部到底边的距离，因此2个水平（或垂直）单位则等于矩形的宽（或高），如Alignment(-1.0, -1.0) 代表矩形的左侧顶点，而Alignment(1.0, 1.0)代表右侧底部终点，而Alignment(1.0, -1.0) 则正是右侧顶点，即Alignment.topRight。为了使用方便，矩形的原点、四个顶点，以及四条边的终点在Alignment类中都已经定义为了静态常量。 Alignment可以通过其坐标转换公式将其坐标转为子元素的具体偏移坐标： (Alignment.x*childWidth/2+childWidth/2, Alignment.x*childHeight+childHeight/2) 其中childWidth为子元素的宽度，childHeight为子元素高度。 现在我们再看看上面的示例，我们将Alignment(1.0, -1.0)带入上面公式，可得FlutterLogo的实际偏移坐标正是（60，0）。下面再看一个例子： Align( widthFactor: 2, heightFactor: 2, alignment: Alignment(2,0.0), child: FlutterLogo( size: 60, ), ) 我们可以先想象一下运行效果：将Alignment(2,0.0)带入上述坐标转换公式，可以得到FlutterLogo的实际偏移坐标为（90，30）。实际运行如图4-12所示： FractionalOffset FractionalOffset 继承自 Alignment，它和 Alignment唯一的区别就是坐标原点不同！FractionalOffset 的坐标原点为矩形的左侧顶点，这和布局系统的一致，所以理解起来会比较容易。FractionalOffset的坐标转换公式为： 实际偏移 = (FractionalOffse.x * childWidth, FractionalOffse.y * childHeight) 下面看一个例子： Container( height: 120.0, width: 120.0, color: Colors.blue[50], child: Align( alignment: FractionalOffset(0.2, 0.6), child: FlutterLogo( size: 60, ), ), ) 实际运行效果如图4-13所示下： 我们将FractionalOffset(0.2, 0.6)带入坐标转换公式得FlutterLogo实际偏移为（12，36），和实际运行效果吻合。 4.6.2 Align和Stack对比 可以看到，Align和Stack/Positioned都可以用于指定子元素相对于父元素的偏移，但它们还是有两个主要区别： 定位参考系统不同；Stack/Positioned定位的的参考系可以是父容器矩形的四个顶点；而Align则需要先通过alignment 参数来确定坐标原点，不同的alignment会对应不同原点，最终的偏移是需要通过alignment的转换公式来计算出。 Stack可以有多个子元素，并且子元素可以堆叠，而Align只能有一个子元素，不存在堆叠。 4.6.3 Center组件 我们在前面章节的例子中已经使用过Center组件来居中子元素了，现在我们正式来介绍一下它。通过查找SDK源码，我们看到Center组件定义如下： class Center extends Align { const Center({ Key key, double widthFactor, double heightFactor, Widget child }) : super(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child); } 可以看到Center继承自Align，它比Align只少了一个alignment 参数；由于Align的构造函数中alignment 值为Alignment.center，所以，我们可以认为Center组件其实是对齐方式确定（Alignment.center）了的Align。 上面我们讲过当widthFactor或heightFactor为null时组件的宽高将会占用尽可能多的空间，这一点需要特别注意，我们通过一个示例说明： ...//省略无关代码 DecoratedBox( decoration: BoxDecoration(color: Colors.red), child: Center( child: Text(\"xxx\"), ), ), DecoratedBox( decoration: BoxDecoration(color: Colors.red), child: Center( widthFactor: 1, heightFactor: 1, child: Text(\"xxx\"), ), ) 运行效果如图4-14所示： 总结 本节重点介绍了Align组件及两种偏移类Alignment 和FractionalOffset，读者需要理解这两种偏移类的区别及各自的坐标转化公式。另外，在此建议读者在需要制定一些精确的偏移时应优先使用FractionalOffset，因为它的坐标原点和布局系统相同，能更容易算出实际偏移。 在后面，我们又介绍了Align组件和Stack/Positioned、Center的关系，读者可以对比理解。 还有，熟悉Web开发的同学可能会发现Align组件的特性和Web开发中相对定位（position: relative）非常像，是的！在大多数时候，我们可以直接使用Align组件来实现Web中相对定位的效果，读者可以类比记忆。 "},"chapter5/":{"url":"chapter5/","title":"第五章：容器类组件","keywords":"","body":"容器类Widget 容器类Widget和布局类Widget都作用于其子Widget，不同的是： 布局类Widget一般都需要接收一个widget数组（children），他们直接或间接继承自（或包含）MultiChildRenderObjectWidget ；而容器类Widget一般只需要接收一个子Widget（child），他们直接或间接继承自（或包含）SingleChildRenderObjectWidget。 布局类Widget是按照一定的排列方式来对其子Widget进行排列；而容器类Widget一般只是包装其子Widget，对其添加一些修饰（补白或背景色等）、变换(旋转或剪裁等)、或限制(大小等)。 注意，Flutter官方并没有对Widget进行官方分类，我们对其分类主要是为了方便讨论和对Widget功能区分的记忆。 本章目录 5.1：填充（Padding） 5.2：尺寸限制类容器（ConstrainedBox等） 5.3：装饰容器（DecoratedBox） 5.4：变换（Transform） 5.5：Container容器 5.6：Scaffold、TabBar、底部导航 5.7：剪裁（Clip） "},"chapter5/padding.html":{"url":"chapter5/padding.html","title":"5.1：填充（Padding）","keywords":"","body":"5.1 填充（Padding） Padding可以给其子节点添加填充（留白），和边距效果类似。我们在前面很多示例中都已经使用过它了，现在来看看它的定义： Padding({ ... EdgeInsetsGeometry padding, Widget child, }) EdgeInsetsGeometry是一个抽象类，开发中，我们一般都使用EdgeInsets类，它是EdgeInsetsGeometry的一个子类，定义了一些设置填充的便捷方法。 EdgeInsets 我们看看EdgeInsets提供的便捷方法： fromLTRB(double left, double top, double right, double bottom)：分别指定四个方向的填充。 all(double value) : 所有方向均使用相同数值的填充。 only({left, top, right ,bottom })：可以设置具体某个方向的填充(可以同时指定多个方向)。 symmetric({ vertical, horizontal })：用于设置对称方向的填充，vertical指top和bottom，horizontal指left和right。 示例 下面的示例主要展示了EdgeInsets的不同用法，比较简单，源码如下： class PaddingTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Padding( //上下左右各添加16像素补白 padding: EdgeInsets.all(16.0), child: Column( //显式指定对齐方式为左对齐，排除对齐干扰 crossAxisAlignment: CrossAxisAlignment.start, children: [ Padding( //左边添加8像素补白 padding: const EdgeInsets.only(left: 8.0), child: Text(\"Hello world\"), ), Padding( //上下各添加8像素补白 padding: const EdgeInsets.symmetric(vertical: 8.0), child: Text(\"I am Jack\"), ), Padding( // 分别指定四个方向的补白 padding: const EdgeInsets.fromLTRB(20.0,.0,20.0,20.0), child: Text(\"Your friend\"), ) ], ), ); } } 运行效果如图5-1所示： "},"chapter5/constrainedbox_and_sizebox.html":{"url":"chapter5/constrainedbox_and_sizebox.html","title":"5.2：尺寸限制类容器（ConstrainedBox等）","keywords":"","body":"5.2 尺寸限制类容器 尺寸限制类容器用于限制容器大小，Flutter中提供了多种这样的容器，如ConstrainedBox、SizedBox、UnconstrainedBox、AspectRatio等，本节将介绍一些常用的。 5.2.1 ConstrainedBox ConstrainedBox用于对子组件添加额外的约束。例如，如果你想让子组件的最小高度是80像素，你可以使用const BoxConstraints(minHeight: 80.0)作为子组件的约束。 示例 我们先定义一个redBox，它是一个背景颜色为红色的盒子，不指定它的宽度和高度： Widget redBox=DecoratedBox( decoration: BoxDecoration(color: Colors.red), ); 我们实现一个最小高度为50，宽度尽可能大的红色容器。 ConstrainedBox( constraints: BoxConstraints( minWidth: double.infinity, //宽度尽可能大 minHeight: 50.0 //最小高度为50像素 ), child: Container( height: 5.0, child: redBox ), ) 运行效果如图5-2所示： 可以看到，我们虽然将Container的高度设置为5像素，但是最终却是50像素，这正是ConstrainedBox的最小高度限制生效了。如果将Container的高度设置为80像素，那么最终红色区域的高度也会是80像素，因为在此示例中，ConstrainedBox只限制了最小高度，并未限制最大高度。 BoxConstraints BoxConstraints用于设置限制条件，它的定义如下： const BoxConstraints({ this.minWidth = 0.0, //最小宽度 this.maxWidth = double.infinity, //最大宽度 this.minHeight = 0.0, //最小高度 this.maxHeight = double.infinity //最大高度 }) BoxConstraints还定义了一些便捷的构造函数，用于快速生成特定限制规则的BoxConstraints，如BoxConstraints.tight(Size size)，它可以生成给定大小的限制；const BoxConstraints.expand()可以生成一个尽可能大的用以填充另一个容器的BoxConstraints。除此之外还有一些其它的便捷函数，读者可以查看API文档。 5.2.2 SizedBox SizedBox用于给子元素指定固定的宽高，如： SizedBox( width: 80.0, height: 80.0, child: redBox ) 运行效果如图5-3所示： 实际上SizedBox只是ConstrainedBox的一个定制，上面代码等价于： ConstrainedBox( constraints: BoxConstraints.tightFor(width: 80.0,height: 80.0), child: redBox, ) 而BoxConstraints.tightFor(width: 80.0,height: 80.0)等价于： BoxConstraints(minHeight: 80.0,maxHeight: 80.0,minWidth: 80.0,maxWidth: 80.0) 而实际上ConstrainedBox和SizedBox都是通过RenderConstrainedBox来渲染的，我们可以看到ConstrainedBox和SizedBox的createRenderObject()方法都返回的是一个RenderConstrainedBox对象： @override RenderConstrainedBox createRenderObject(BuildContext context) { return new RenderConstrainedBox( additionalConstraints: ..., ); } 5.2.3 多重限制 如果某一个组件有多个父级ConstrainedBox限制，那么最终会是哪个生效？我们看一个例子： ConstrainedBox( constraints: BoxConstraints(minWidth: 60.0, minHeight: 60.0), //父 child: ConstrainedBox( constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),//子 child: redBox, ) ) 上面我们有父子两个ConstrainedBox，他们的限制条件不同，运行后效果如图5-4所示： 最终显示效果是宽90，高60，也就是说是子ConstrainedBox的minWidth生效，而minHeight是父ConstrainedBox生效。单凭这个例子，我们还总结不出什么规律，我们将上例中父子限制条件换一下： ConstrainedBox( constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0), child: ConstrainedBox( constraints: BoxConstraints(minWidth: 60.0, minHeight: 60.0), child: redBox, ) ) 运行效果如图5-5所示： 最终的显示效果仍然是90，高60，效果相同，但意义不同，因为此时minWidth生效的是父ConstrainedBox，而minHeight是子ConstrainedBox生效。 通过上面示例，我们发现有多重限制时，对于minWidth和minHeight来说，是取父子中相应数值较大的。实际上，只有这样才能保证父限制与子限制不冲突。 思考题：对于maxWidth和maxHeight，多重限制的策略是什么样的呢？ 5.2.4 UnconstrainedBox UnconstrainedBox不会对子组件产生任何限制，它允许其子组件按照其本身大小绘制。一般情况下，我们会很少直接使用此组件，但在\"去除\"多重限制的时候也许会有帮助，我们看下下面的代码： ConstrainedBox( constraints: BoxConstraints(minWidth: 60.0, minHeight: 100.0), //父 child: UnconstrainedBox( //“去除”父级限制 child: ConstrainedBox( constraints: BoxConstraints(minWidth: 90.0, minHeight: 20.0),//子 child: redBox, ), ) ) 上面代码中，如果没有中间的UnconstrainedBox，那么根据上面所述的多重限制规则，那么最终将显示一个90×100的红色框。但是由于UnconstrainedBox “去除”了父ConstrainedBox的限制，则最终会按照子ConstrainedBox的限制来绘制redBox，即90×20： 但是，读者请注意，UnconstrainedBox对父组件限制的“去除”并非是真正的去除：上面例子中虽然红色区域大小是90×20，但上方仍然有80的空白空间。也就是说父限制的minHeight(100.0)仍然是生效的，只不过它不影响最终子元素redBox的大小，但仍然还是占有相应的空间，可以认为此时的父ConstrainedBox是作用于子UnconstrainedBox上，而redBox只受子ConstrainedBox限制，这一点请读者务必注意。 那么有什么方法可以彻底去除父ConstrainedBox的限制吗？答案是否定的！所以在此提示读者，在定义一个通用的组件时，如果要对子组件指定限制，那么一定要注意，因为一旦指定限制条件，子组件如果要进行相关自定义大小时将可能非常困难，因为子组件在不更改父组件的代码的情况下无法彻底去除其限制条件。 在实际开发中，当我们发现已经使用SizedBox或ConstrainedBox给子元素指定了宽高，但是仍然没有效果时，几乎可以断定：已经有父元素已经设置了限制！举个例子，如Material组件库中的AppBar（导航栏）的右侧菜单中，我们使用SizedBox指定了loading按钮的大小，代码如下： AppBar( title: Text(title), actions: [ SizedBox( width: 20, height: 20, child: CircularProgressIndicator( strokeWidth: 3, valueColor: AlwaysStoppedAnimation(Colors.white70), ), ) ], ) 上面代码运行后，效果如图5-7所示： 我们会发现右侧loading按钮大小并没有发生变化！这正是因为AppBar中已经指定了actions按钮的限制条件，所以我们要自定义loading按钮大小，就必须通过UnconstrainedBox来“去除”父元素的限制，代码如下： AppBar( title: Text(title), actions: [ UnconstrainedBox( child: SizedBox( width: 20, height: 20, child: CircularProgressIndicator( strokeWidth: 3, valueColor: AlwaysStoppedAnimation(Colors.white70), ), ), ) ], ) 运行后效果如图5-8所示： 生效了！ 5.2.4 其它尺寸限制类容器 除了上面介绍的这些常用的尺寸限制类容器外，还有一些其他的尺寸限制类容器，比如AspectRatio，它可以指定子组件的长宽比、LimitedBox 用于指定最大宽高、FractionallySizedBox 可以根据父容器宽高的百分比来设置子组件宽高等，由于这些容器使用起来都比较简单，我们便不再赘述，读者可以自行了解。 "},"chapter5/decoratedbox.html":{"url":"chapter5/decoratedbox.html","title":"5.3：装饰容器（DecoratedBox）","keywords":"","body":"5.3 装饰容器DecoratedBox DecoratedBox可以在其子组件绘制前(或后)绘制一些装饰（Decoration），如背景、边框、渐变等。DecoratedBox定义如下： const DecoratedBox({ Decoration decoration, DecorationPosition position = DecorationPosition.background, Widget child }) decoration：代表将要绘制的装饰，它的类型为Decoration。Decoration是一个抽象类，它定义了一个接口 createBoxPainter()，子类的主要职责是需要通过实现它来创建一个画笔，该画笔用于绘制装饰。 position：此属性决定在哪里绘制Decoration，它接收DecorationPosition的枚举类型，该枚举类有两个值： background：在子组件之后绘制，即背景装饰。 foreground：在子组件之上绘制，即前景。 BoxDecoration 我们通常会直接使用BoxDecoration类，它是一个Decoration的子类，实现了常用的装饰元素的绘制。 BoxDecoration({ Color color, //颜色 DecorationImage image,//图片 BoxBorder border, //边框 BorderRadiusGeometry borderRadius, //圆角 List boxShadow, //阴影,可以指定多个 Gradient gradient, //渐变 BlendMode backgroundBlendMode, //背景混合模式 BoxShape shape = BoxShape.rectangle, //形状 }) 各个属性名都是自解释的，详情读者可以查看API文档。下面我们实现一个带阴影的背景色渐变的按钮： DecoratedBox( decoration: BoxDecoration( gradient: LinearGradient(colors:[Colors.red,Colors.orange[700]]), //背景渐变 borderRadius: BorderRadius.circular(3.0), //3像素圆角 boxShadow: [ //阴影 BoxShadow( color:Colors.black54, offset: Offset(2.0,2.0), blurRadius: 4.0 ) ] ), child: Padding(padding: EdgeInsets.symmetric(horizontal: 80.0, vertical: 18.0), child: Text(\"Login\", style: TextStyle(color: Colors.white),), ) ) 运行后效果如图5-9所示： 怎么样，通过BoxDecoration我们实现了一个渐变按钮的外观，但此示例还不是一个标准的按钮，因为它还不能响应点击事件，我们将在后面“自定义组件”一章中实现一个完整功能的GradientButton。另外，上面的例子中使用了LinearGradient类，它用于定义线性渐变的类，Flutter中还提供了其它渐变配置类，如RadialGradient、SweepGradient，读者若有需要可以自行查看API文档。 "},"chapter5/transform.html":{"url":"chapter5/transform.html","title":"5.4：变换（Transform）","keywords":"","body":"5.4 变换（Transform） Transform可以在其子组件绘制时对其应用一些矩阵变换来实现一些特效。Matrix4是一个4D矩阵，通过它我们可以实现各种矩阵操作，下面是一个例子： Container( color: Colors.black, child: new Transform( alignment: Alignment.topRight, //相对于坐标系原点的对齐方式 transform: new Matrix4.skewY(0.3), //沿Y轴倾斜0.3弧度 child: new Container( padding: const EdgeInsets.all(8.0), color: Colors.deepOrange, child: const Text('Apartment for rent!'), ), ), ); 运行效果如图5-10所示： 关于矩阵变换的相关内容属于线性代数范畴，本书不做讨论，读者有兴趣可以自行了解。本书中，我们把焦点放在Flutter中一些常见的变换效果上。另外，由于矩阵变化时发生在绘制时，而无需重新布局和构建等过程，所以性能很好。 平移 Transform.translate接收一个offset参数，可以在绘制时沿x、y轴对子组件平移指定的距离。 DecoratedBox( decoration:BoxDecoration(color: Colors.red), //默认原点为左上角，左移20像素，向上平移5像素 child: Transform.translate( offset: Offset(-20.0, -5.0), child: Text(\"Hello world\"), ), ) 效果如图5-11所示： 旋转 Transform.rotate可以对子组件进行旋转变换，如： DecoratedBox( decoration:BoxDecoration(color: Colors.red), child: Transform.rotate( //旋转90度 angle:math.pi/2 , child: Text(\"Hello world\"), ), )； 注意：要使用math.pi需先进行如下导包。 import 'dart:math' as math; 效果如图5-12所示： 缩放 Transform.scale可以对子组件进行缩小或放大，如： DecoratedBox( decoration:BoxDecoration(color: Colors.red), child: Transform.scale( scale: 1.5, //放大到1.5倍 child: Text(\"Hello world\") ) ); 效果如图5-13所示： 注意 Transform的变换是应用在绘制阶段，而并不是应用在布局(layout)阶段，所以无论对子组件应用何种变化，其占用空间的大小和在屏幕上的位置都是固定不变的，因为这些是在布局阶段就确定的。下面我们具体说明： Row( mainAxisAlignment: MainAxisAlignment.center, children: [ DecoratedBox( decoration:BoxDecoration(color: Colors.red), child: Transform.scale(scale: 1.5, child: Text(\"Hello world\") ) ), Text(\"你好\", style: TextStyle(color: Colors.green, fontSize: 18.0),) ], ) 运行效果如图5-14所示： 由于第一个Text应用变换(放大)后，其在绘制时会放大，但其占用的空间依然为红色部分，所以第二个Text会紧挨着红色部分，最终就会出现文字重合。 由于矩阵变化只会作用在绘制阶段，所以在某些场景下，在UI需要变化时，可以直接通过矩阵变化来达到视觉上的UI改变，而不需要去重新触发build流程，这样会节省layout的开销，所以性能会比较好。如之前介绍的Flow组件，它内部就是用矩阵变换来更新UI，除此之外，Flutter的动画组件中也大量使用了Transform以提高性能。 思考题：使用Transform对其子组件先进行平移然后再旋转和先旋转再平移，两者最终的效果一样吗？为什么？ RotatedBox RotatedBox和Transform.rotate功能相似，它们都可以对子组件进行旋转变换，但是有一点不同：RotatedBox的变换是在layout阶段，会影响在子组件的位置和大小。我们将上面介绍Transform.rotate时的示例改一下： Row( mainAxisAlignment: MainAxisAlignment.center, children: [ DecoratedBox( decoration: BoxDecoration(color: Colors.red), //将Transform.rotate换成RotatedBox child: RotatedBox( quarterTurns: 1, //旋转90度(1/4圈) child: Text(\"Hello world\"), ), ), Text(\"你好\", style: TextStyle(color: Colors.green, fontSize: 18.0),) ], ), 效果如图5-15所示： 由于RotatedBox是作用于layout阶段，所以子组件会旋转90度（而不只是绘制的内容），decoration会作用到子组件所占用的实际空间上，所以最终就是上图的效果，读者可以和前面Transform.rotate示例对比理解。 "},"chapter5/container.html":{"url":"chapter5/container.html","title":"5.5：Container容器","keywords":"","body":"5.5 Container 我们在前面的章节示例中多次用到过Container组件，本节我们就详细介绍一下Container组件。Container是一个组合类容器，它本身不对应具体的RenderObject，它是DecoratedBox、ConstrainedBox、Transform、Padding、Align等组件组合的一个多功能容器，所以我们只需通过一个Container组件可以实现同时需要装饰、变换、限制的场景。下面是Container的定义： Container({ this.alignment, this.padding, //容器内补白，属于decoration的装饰范围 Color color, // 背景色 Decoration decoration, // 背景装饰 Decoration foregroundDecoration, //前景装饰 double width,//容器的宽度 double height, //容器的高度 BoxConstraints constraints, //容器大小的限制条件 this.margin,//容器外补白，不属于decoration的装饰范围 this.transform, //变换 this.child, }) Container的大多数属性在介绍其它容器时都已经介绍过了，不再赘述，但有两点需要说明： 容器的大小可以通过width、height属性来指定，也可以通过constraints来指定；如果它们同时存在时，width、height优先。实际上Container内部会根据width、height来生成一个constraints。 color和decoration是互斥的，如果同时设置它们则会报错！实际上，当指定color时，Container内会自动创建一个decoration。 实例 我们通过Container来实现如图5-16所示的卡片： 实现代码如下： Container( margin: EdgeInsets.only(top: 50.0, left: 120.0), //容器外填充 constraints: BoxConstraints.tightFor(width: 200.0, height: 150.0), //卡片大小 decoration: BoxDecoration(//背景装饰 gradient: RadialGradient( //背景径向渐变 colors: [Colors.red, Colors.orange], center: Alignment.topLeft, radius: .98 ), boxShadow: [ //卡片阴影 BoxShadow( color: Colors.black54, offset: Offset(2.0, 2.0), blurRadius: 4.0 ) ] ), transform: Matrix4.rotationZ(.2), //卡片倾斜变换 alignment: Alignment.center, //卡片内文字居中 child: Text( //卡片文字 \"5.20\", style: TextStyle(color: Colors.white, fontSize: 40.0), ), ); 可以看到Container具备多种组件的功能，通过查看Container源码，我们会很容易发现它正是前面我们介绍过的多种组件组合而成。在Flutter中，Container组件也正是组合优先于继承的实例。 Padding和Margin 接下来我们来研究一下Container组件margin和padding属性的区别: ... Container( margin: EdgeInsets.all(20.0), //容器外补白 color: Colors.orange, child: Text(\"Hello world!\"), ), Container( padding: EdgeInsets.all(20.0), //容器内补白 color: Colors.orange, child: Text(\"Hello world!\"), ), ... 可以发现，直观的感觉就是margin的留白是在容器外部，而padding的留白是在容器内部，读者需要记住这个差异。事实上，Container内margin和padding都是通过Padding 组件来实现的，上面的示例代码实际上等价于： ... Padding( padding: EdgeInsets.all(20.0), child: DecoratedBox( decoration: BoxDecoration(color: Colors.orange), child: Text(\"Hello world!\"), ), ), DecoratedBox( decoration: BoxDecoration(color: Colors.orange), child: Padding( padding: const EdgeInsets.all(20.0), child: Text(\"Hello world!\"), ), ), ... "},"chapter5/material_scaffold.html":{"url":"chapter5/material_scaffold.html","title":"5.6：Scaffold、TabBar、底部导航","keywords":"","body":"5.6 Scaffold、TabBar、底部导航 Material组件库提供了丰富多样的组件，本节介绍一些常用的组件，其余的读者可以自行查看文档或Flutter Gallery中Material组件部分的示例。 Flutter Gallery是Flutter官方提供的Flutter Demo，源码位于flutter源码中的examples目录下，笔者强烈建议用户将Flutter Gallery示例跑起来，它是一个很全面的Flutter示例应用，是非常好的参考Demo，也是笔者学习Flutter的第一手资料。 5.6.1 Scaffold 一个完整的数路由页可能会包含导航栏、抽屉菜单(Drawer)以及底部Tab导航菜单等。如果每个路由页面都需要开发者自己手动去实现这些，这会是一件非常麻烦且无聊的事。幸运的是，Flutter Material组件库提供了一些现成的组件来减少我们的开发任务。Scaffold是一个路由页的骨架，我们使用它可以很容易地拼装出一个完整的页面。 示例 我们实现一个页面，它包含： 一个导航栏 导航栏右边有一个分享按钮 有一个抽屉菜单 有一个底部导航 右下角有一个悬浮的动作按钮 最终效果如图5-18、图5-19所示： 实现代码如下： class ScaffoldRoute extends StatefulWidget { @override _ScaffoldRouteState createState() => _ScaffoldRouteState(); } class _ScaffoldRouteState extends State { int _selectedIndex = 1; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( //导航栏 title: Text(\"App Name\"), actions: [ //导航栏右侧菜单 IconButton(icon: Icon(Icons.share), onPressed: () {}), ], ), drawer: new MyDrawer(), //抽屉 bottomNavigationBar: BottomNavigationBar( // 底部导航 items: [ BottomNavigationBarItem(icon: Icon(Icons.home), title: Text('Home')), BottomNavigationBarItem(icon: Icon(Icons.business), title: Text('Business')), BottomNavigationBarItem(icon: Icon(Icons.school), title: Text('School')), ], currentIndex: _selectedIndex, fixedColor: Colors.blue, onTap: _onItemTapped, ), floatingActionButton: FloatingActionButton( //悬浮按钮 child: Icon(Icons.add), onPressed:_onAdd ), ); } void _onItemTapped(int index) { setState(() { _selectedIndex = index; }); } void _onAdd(){ } } 上面代码中我们用到了如下组件： 组件名称 解释 AppBar 一个导航栏骨架 MyDrawer 抽屉菜单 BottomNavigationBar 底部导航栏 FloatingActionButton 漂浮按钮 下面我们来分别介绍一下它们。 5.6.2 AppBar AppBar是一个Material风格的导航栏，通过它可以设置导航栏标题、导航栏菜单、导航栏底部的Tab标题等。下面我们看看AppBar的定义： AppBar({ Key key, this.leading, //导航栏最左侧Widget，常见为抽屉菜单按钮或返回按钮。 this.automaticallyImplyLeading = true, //如果leading为null，是否自动实现默认的leading按钮 this.title,// 页面标题 this.actions, // 导航栏右侧菜单 this.bottom, // 导航栏底部菜单，通常为Tab按钮组 this.elevation = 4.0, // 导航栏阴影 this.centerTitle, //标题是否居中 this.backgroundColor, ... //其它属性见源码注释 }) 如果给Scaffold添加了抽屉菜单，默认情况下Scaffold会自动将AppBar的leading设置为菜单按钮（如上面截图所示），点击它便可打开抽屉菜单。如果我们想自定义菜单图标，可以手动来设置leading，如： Scaffold( appBar: AppBar( title: Text(\"App Name\"), leading: Builder(builder: (context) { return IconButton( icon: Icon(Icons.dashboard, color: Colors.white), //自定义图标 onPressed: () { // 打开抽屉菜单 Scaffold.of(context).openDrawer(); }, ); }), ... ) 代码运行效果如图5-20所示： 可以看到左侧菜单已经替换成功。 代码中打开抽屉菜单的方法在ScaffoldState中，通过Scaffold.of(context)可以获取父级最近的Scaffold 组件的State对象，原理可以参考本书后面“Element与BuildContext” 一章。Flutter还有一种通用的获取State对象的方法——通过GlobalKey来获取！ 步骤分两步： 给目标StatefulWidget添加GlobalKey。 //定义一个globalKey, 由于GlobalKey要保持全局唯一性，我们使用静态变量存储 static GlobalKey _globalKey= new GlobalKey(); ... Scaffold( key: _globalKey , //设置key ... ) 通过GlobalKey来获取State对象 _globalKey.currentState.openDrawer() TabBar 下面我们通过“bottom”属性来添加一个导航栏底部Tab按钮组，将要实现的效果如图5-21所示： Material组件库中提供了一个TabBar组件，它可以快速生成Tab菜单，下面是上图对应的源码： class _ScaffoldRouteState extends State with SingleTickerProviderStateMixin { TabController _tabController; //需要定义一个Controller List tabs = [\"新闻\", \"历史\", \"图片\"]; @override void initState() { super.initState(); // 创建Controller _tabController = TabController(length: tabs.length, vsync: this); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( ... //省略无关代码 bottom: TabBar( //生成Tab菜单 controller: _tabController, tabs: tabs.map((e) => Tab(text: e)).toList() ), ), ... //省略无关代码 } 上面代码首先创建了一个TabController ，它是用于控制/监听Tab菜单切换的。接下来通过TabBar生成了一个底部菜单栏，TabBar的tabs属性接受一个Widget数组，表示每一个Tab子菜单，我们可以自定义，也可以像示例中一样直接使用Tab 组件，它是Material组件库提供的Material风格的Tab菜单。 Tab组件有三个可选参数，除了可以指定文字外，还可以指定Tab菜单图标，或者直接自定义组件样式。Tab组件定义如下： Tab({ Key key, this.text, // 菜单文本 this.icon, // 菜单图标 this.child, // 自定义组件样式 }) 开发者可以根据实际需求来定制。 TabBarView 通过TabBar我们只能生成一个静态的菜单，真正的Tab页还没有实现。由于Tab菜单和Tab页的切换需要同步，我们需要通过TabController去监听Tab菜单的切换去切换Tab页，代码如： _tabController.addListener((){ switch(_tabController.index){ case 1: ...; case 2: ... ; } }); 如果我们Tab页可以滑动切换的话，还需要在滑动过程中更新TabBar指示器的偏移！显然，要手动处理这些是很麻烦的，为此，Material库提供了一个TabBarView组件，通过它不仅可以轻松的实现Tab页，而且可以非常容易的配合TabBar来实现同步切换和滑动状态同步，示例如下： Scaffold( appBar: AppBar( ... //省略无关代码 bottom: TabBar( controller: _tabController, tabs: tabs.map((e) => Tab(text: e)).toList()), ), drawer: new MyDrawer(), body: TabBarView( controller: _tabController, children: tabs.map((e) { //创建3个Tab页 return Container( alignment: Alignment.center, child: Text(e, textScaleFactor: 5), ); }).toList(), ), ... // 省略无关代码 ) 运行后效果如图5-22所示： 现在，无论是点击导航栏Tab菜单还是在页面上左右滑动，Tab页面都会切换，并且Tab菜单的状态和Tab页面始终保持同步！那它们是如何实现同步的呢？细心的读者可能已经发现，上例中TabBar和TabBarView的controller是同一个！正是如此，TabBar和TabBarView正是通过同一个controller来实现菜单切换和滑动状态同步的，有关TabController的详细信息，我们不再本书做过多介绍，使用时读者直接查看SDK即可。 另外，Material组件库也提供了一个PageView 组件，它和TabBarView功能相似，读者可以自行了解一下。 5.6.3 抽屉菜单Drawer Scaffold的drawer和endDrawer属性可以分别接受一个Widget来作为页面的左、右抽屉菜单。如果开发者提供了抽屉菜单，那么当用户手指从屏幕左（或右）侧向里滑动时便可打开抽屉菜单。本节开始部分的示例中实现了一个左抽屉菜单MyDrawer，它的源码如下： class MyDrawer extends StatelessWidget { const MyDrawer({ Key key, }) : super(key: key); @override Widget build(BuildContext context) { return Drawer( child: MediaQuery.removePadding( context: context, //移除抽屉菜单顶部默认留白 removeTop: true, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Padding( padding: const EdgeInsets.only(top: 38.0), child: Row( children: [ Padding( padding: const EdgeInsets.symmetric(horizontal: 16.0), child: ClipOval( child: Image.asset( \"imgs/avatar.png\", width: 80, ), ), ), Text( \"Wendux\", style: TextStyle(fontWeight: FontWeight.bold), ) ], ), ), Expanded( child: ListView( children: [ ListTile( leading: const Icon(Icons.add), title: const Text('Add account'), ), ListTile( leading: const Icon(Icons.settings), title: const Text('Manage accounts'), ), ], ), ), ], ), ), ); } } 抽屉菜单通常将Drawer组件作为根节点，它实现了Material风格的菜单面板，MediaQuery.removePadding可以移除Drawer默认的一些留白（比如Drawer默认顶部会留和手机状态栏等高的留白），读者可以尝试传递不同的参数来看看实际效果。抽屉菜单页由顶部和底部组成，顶部由用户头像和昵称组成，底部是一个菜单列表，用ListView实现，关于ListView我们将在后面“可滚动组件”一节详细介绍。 5.6.4 FloatingActionButton FloatingActionButton是Material设计规范中的一种特殊Button，通常悬浮在页面的某一个位置作为某种常用动作的快捷入口，如本节示例中页面右下角的\"➕\"号按钮。我们可以通过Scaffold的floatingActionButton属性来设置一个FloatingActionButton，同时通过floatingActionButtonLocation属性来指定其在页面中悬浮的位置，这个比较简单，不再赘述。 5.6.5 底部Tab导航栏 我们可以通过Scaffold的bottomNavigationBar属性来设置底部导航，如本节开始示例所示，我们通过Material组件库提供的BottomNavigationBar和BottomNavigationBarItem两种组件来实现Material风格的底部导航栏。可以看到上面的实现代码非常简单，所以不再赘述，但是如果我们想实现如图5-23所示效果的底部导航栏应该怎么做呢？ Material组件库中提供了一个BottomAppBar 组件，它可以和FloatingActionButton配合实现这种“打洞”效果，源码如下： bottomNavigationBar: BottomAppBar( color: Colors.white, shape: CircularNotchedRectangle(), // 底部导航栏打一个圆形的洞 child: Row( children: [ IconButton(icon: Icon(Icons.home)), SizedBox(), //中间位置空出 IconButton(icon: Icon(Icons.business)), ], mainAxisAlignment: MainAxisAlignment.spaceAround, //均分底部导航栏横向空间 ), ) 可以看到，上面代码中没有控制打洞位置的属性，实际上，打洞的位置取决于FloatingActionButton的位置，上面FloatingActionButton的位置为： floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked, 所以打洞位置在底部导航栏的正中间。 BottomAppBar的shape属性决定洞的外形，CircularNotchedRectangle实现了一个圆形的外形，我们也可以自定义外形，比如，Flutter Gallery示例中就有一个”钻石“形状的示例，读者感兴趣可以自行查看。 "},"chapter5/clip.html":{"url":"chapter5/clip.html","title":"5.7：剪裁（Clip）","keywords":"","body":"5.7 剪裁（Clip） Flutter中提供了一些剪裁函数，用于对组件进行剪裁。 剪裁Widget 作用 ClipOval 子组件为正方形时剪裁为内贴圆形，为矩形时，剪裁为内贴椭圆 ClipRRect 将子组件剪裁为圆角矩形 ClipRect 剪裁子组件到实际占用的矩形大小（溢出部分剪裁） 下面看一个例子： import 'package:flutter/material.dart'; class ClipTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { // 头像 Widget avatar = Image.asset(\"imgs/avatar.png\", width: 60.0); return Center( child: Column( children: [ avatar, //不剪裁 ClipOval(child: avatar), //剪裁为圆形 ClipRRect( //剪裁为圆角矩形 borderRadius: BorderRadius.circular(5.0), child: avatar, ), Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Align( alignment: Alignment.topLeft, widthFactor: .5,//宽度设为原来宽度一半，另一半会溢出 child: avatar, ), Text(\"你好世界\", style: TextStyle(color: Colors.green),) ], ), Row( mainAxisAlignment: MainAxisAlignment.center, children: [ ClipRect(//将溢出部分剪裁 child: Align( alignment: Alignment.topLeft, widthFactor: .5,//宽度设为原来宽度一半 child: avatar, ), ), Text(\"你好世界\",style: TextStyle(color: Colors.green)) ], ), ], ), ); } } 运行效果如图5-24所示： 上面示例代码注释比较详细，在此不再赘述。但值得一提的是最后的两个Row！它们通过Align设置widthFactor为0.5后，图片的实际宽度等于60×0.5，即原宽度一半，但此时图片溢出部分依然会显示，所以第一个“你好世界”会和图片的另一部分重合，为了剪裁掉溢出部分，我们在第二个Row中通过ClipRect将溢出部分剪裁掉了。 CustomClipper 如果我们想剪裁子组件的特定区域，比如，在上面示例的图片中，如果我们只想截取图片中部40×30像素的范围应该怎么做？这时我们可以使用CustomClipper来自定义剪裁区域，实现代码如下： 首先，自定义一个CustomClipper： class MyClipper extends CustomClipper { @override Rect getClip(Size size) => Rect.fromLTWH(10.0, 15.0, 40.0, 30.0); @override bool shouldReclip(CustomClipper oldClipper) => false; } getClip()是用于获取剪裁区域的接口，由于图片大小是60×60，我们返回剪裁区域为Rect.fromLTWH(10.0, 15.0, 40.0, 30.0)，及图片中部40×30像素的范围。 shouldReclip() 接口决定是否重新剪裁。如果在应用中，剪裁区域始终不会发生变化时应该返回false，这样就不会触发重新剪裁，避免不必要的性能开销。如果剪裁区域会发生变化（比如在对剪裁区域执行一个动画），那么变化后应该返回true来重新执行剪裁。 然后，我们通过ClipRect来执行剪裁，为了看清图片实际所占用的位置，我们设置一个红色背景： DecoratedBox( decoration: BoxDecoration( color: Colors.red ), child: ClipRect( clipper: MyClipper(), //使用自定义的clipper child: avatar ), ) 运行效果如图5-25所示： 可以看到我们的剪裁成功了，但是图片所占用的空间大小仍然是60×60（红色区域），这是因为剪裁是在layout完成后的绘制阶段进行的，所以不会影响组件的大小，这和Transform原理是相似的。 "},"chapter6/":{"url":"chapter6/","title":"第六章：可滚动组件","keywords":"","body":"本章目录 6.1：可滚动组件简介 6.2：SingleChildScrollView 6.3：ListView 6.4：GridView 6.5：CustomScrollView 6.6：滚动监听及控制（ScrollController） "},"chapter6/intro.html":{"url":"chapter6/intro.html","title":"6.1：可滚动组件简介","keywords":"","body":"6.1 可滚动组件简介 当组件内容超过当前显示视口(ViewPort)时，如果没有特殊处理，Flutter则会提示Overflow错误。为此，Flutter提供了多种可滚动组件（Scrollable Widget）用于显示列表和长布局。在本章中，我们先介绍一下常用的可滚动组件（如ListView、GridView等），然后介绍一下ScrollController。可滚动组件都直接或间接包含一个Scrollable组件，因此它们包括一些共同的属性，为了避免重复介绍，我们在此统一介绍一下： Scrollable({ ... this.axisDirection = AxisDirection.down, this.controller, this.physics, @required this.viewportBuilder, //后面介绍 }) axisDirection滚动方向。 physics：此属性接受一个ScrollPhysics类型的对象，它决定可滚动组件如何响应用户操作，比如用户滑动完抬起手指后，继续执行动画；或者滑动到边界时，如何显示。默认情况下，Flutter会根据具体平台分别使用不同的ScrollPhysics对象，应用不同的显示效果，如当滑动到边界时，继续拖动的话，在iOS上会出现弹性效果，而在Android上会出现微光效果。如果你想在所有平台下使用同一种效果，可以显式指定一个固定的ScrollPhysics，Flutter SDK中包含了两个ScrollPhysics的子类，他们可以直接使用： ClampingScrollPhysics：Android下微光效果。 BouncingScrollPhysics：iOS下弹性效果。 controller：此属性接受一个ScrollController对象。ScrollController的主要作用是控制滚动位置和监听滚动事件。默认情况下，Widget树中会有一个默认的PrimaryScrollController，如果子树中的可滚动组件没有显式的指定controller，并且primary属性值为true时（默认就为true），可滚动组件会使用这个默认的PrimaryScrollController。这种机制带来的好处是父组件可以控制子树中可滚动组件的滚动行为，例如，Scaffold正是使用这种机制在iOS中实现了点击导航栏回到顶部的功能。我们将在本章后面“滚动控制”一节详细介绍ScrollController。 Scrollbar Scrollbar是一个Material风格的滚动指示器（滚动条），如果要给可滚动组件添加滚动条，只需将Scrollbar作为可滚动组件的任意一个父级组件即可，如： Scrollbar( child: SingleChildScrollView( ... ), ); Scrollbar和CupertinoScrollbar都是通过ScrollController来监听滚动事件来确定滚动条位置的。关于ScrollController的详细内容我们将在本章最后一节中专门介绍。 CupertinoScrollbar CupertinoScrollbar是iOS风格的滚动条，如果你使用的是Scrollbar，那么在iOS平台它会自动切换为CupertinoScrollbar。 ViewPort视口 在很多布局系统中都有ViewPort的概念，在Flutter中，术语ViewPort（视口），如无特别说明，则是指一个Widget的实际显示区域。例如，一个ListView的显示区域高度是800像素，虽然其列表项总高度可能远远超过800像素，但是其ViewPort仍然是800像素。 基于Sliver的延迟构建 通常可滚动组件的子组件可能会非常多、占用的总高度也会非常大；如果要一次性将子组件全部构建出将会非常昂贵！为此，Flutter中提出一个Sliver（中文为”薄片“的意思）概念，如果一个可滚动组件支持Sliver模型，那么该滚动可以将子组件分成好多个”薄片“（Sliver），只有当Sliver出现在视口中时才会去构建它，这种模型也称为”基于Sliver的延迟构建模型“。可滚动组件中有很多都支持基于Sliver的延迟构建模型，如ListView、GridView，但是也有不支持该模型的，如SingleChildScrollView。 主轴和纵轴 在可滚动组件的坐标描述中，通常将滚动方向称为主轴，非滚动方向称为纵轴。由于可滚动组件的默认方向一般都是沿垂直方向，所以默认情况下主轴就是指垂直方向，水平方向同理。 "},"chapter6/single_child_scrollview.html":{"url":"chapter6/single_child_scrollview.html","title":"6.2：SingleChildScrollView","keywords":"","body":"6.2 SingleChildScrollView SingleChildScrollView类似于Android中的ScrollView，它只能接收一个子组件。定义如下： SingleChildScrollView({ this.scrollDirection = Axis.vertical, //滚动方向，默认是垂直方向 this.reverse = false, this.padding, bool primary, this.physics, this.controller, this.child, }) 除了上一节我们介绍过的可滚动组件的通用属性外，我们重点看一下reverse和primary两个属性： reverse：该属性API文档解释是：是否按照阅读方向相反的方向滑动，如：scrollDirection值为Axis.horizontal，如果阅读方向是从左到右(取决于语言环境，阿拉伯语就是从右到左)。reverse为true时，那么滑动方向就是从右往左。其实此属性本质上是决定可滚动组件的初始滚动位置是在“头”还是“尾”，取false时，初始滚动位置在“头”，反之则在“尾”，读者可以自己试验。 primary：指是否使用widget树中默认的PrimaryScrollController；当滑动方向为垂直方向（scrollDirection值为Axis.vertical）并且没有指定controller时，primary默认为true. 需要注意的是，通常SingleChildScrollView只应在期望的内容不会超过屏幕太多时使用，这是因为SingleChildScrollView不支持基于Sliver的延迟实例化模型，所以如果预计视口可能包含超出屏幕尺寸太多的内容时，那么使用SingleChildScrollView将会非常昂贵（性能差），此时应该使用一些支持Sliver延迟加载的可滚动组件，如ListView。 示例 下面是一个将大写字母A-Z沿垂直方向显示的例子，由于垂直方向空间会超过屏幕视口高度，所以我们使用SingleChildScrollView： class SingleChildScrollViewTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; return Scrollbar( // 显示进度条 child: SingleChildScrollView( padding: EdgeInsets.all(16.0), child: Center( child: Column( //动态创建一个List children: str.split(\"\") //每一个字母都用一个Text显示,字体为原来的两倍 .map((c) => Text(c, textScaleFactor: 2.0,)) .toList(), ), ), ), ); } } 运行效果如图6-1所示： "},"chapter6/listview.html":{"url":"chapter6/listview.html","title":"6.3：ListView","keywords":"","body":"6.3 ListView ListView是最常用的可滚动组件之一，它可以沿一个方向线性排布所有子组件，并且它也支持基于Sliver的延迟构建模型。我们看看ListView的默认构造函数定义： ListView({ ... //可滚动widget公共参数 Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController controller, bool primary, ScrollPhysics physics, EdgeInsetsGeometry padding, //ListView各个构造函数的共同参数 double itemExtent, bool shrinkWrap = false, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, double cacheExtent, //子widget列表 List children = const [], }) 上面参数分为两组：第一组是可滚动组件的公共参数，本章第一节中已经介绍过，不再赘述；第二组是ListView各个构造函数（ListView有多个构造函数）的共同参数，我们重点来看看这些参数，： itemExtent：该参数如果不为null，则会强制children的”长度“为itemExtent的值；这里的”长度“是指滚动方向上子组件的长度，也就是说如果滚动方向是垂直方向，则itemExtent代表子组件的高度；如果滚动方向为水平方向，则itemExtent就代表子组件的宽度。在ListView中，指定itemExtent比让子组件自己决定自身长度会更高效，这是因为指定itemExtent后，滚动系统可以提前知道列表的长度，而无需每次构建子组件时都去再计算一下，尤其是在滚动位置频繁变化时（滚动系统需要频繁去计算列表高度）。 shrinkWrap：该属性表示是否根据子组件的总长度来设置ListView的长度，默认值为false 。默认情况下，ListView的会在滚动方向尽可能多的占用空间。当ListView在一个无边界(滚动方向上)的容器中时，shrinkWrap必须为true。 addAutomaticKeepAlives：该属性表示是否将列表项（子组件）包裹在AutomaticKeepAlive 组件中；典型地，在一个懒加载列表中，如果将列表项包裹在AutomaticKeepAlive中，在该列表项滑出视口时它也不会被GC（垃圾回收），它会使用KeepAliveNotification来保存其状态。如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。 addRepaintBoundaries：该属性表示是否将列表项（子组件）包裹在RepaintBoundary组件中。当可滚动组件滚动时，将列表项包裹在RepaintBoundary中可以避免列表项重绘，但是当列表项重绘的开销非常小（如一个颜色块，或者一个较短的文本）时，不添加RepaintBoundary反而会更高效。和addAutomaticKeepAlive一样，如果列表项自己维护其KeepAlive状态，那么此参数必须置为false。 注意：上面这些参数并非ListView特有，在本章后面介绍的其它可滚动组件也可能会拥有这些参数，它们的含义是相同的。 默认构造函数 默认构造函数有一个children参数，它接受一个Widget列表（List）。这种方式适合只有少量的子组件的情况，因为这种方式需要将所有children都提前创建好（这需要做大量工作），而不是等到子widget真正显示的时候再创建，也就是说通过默认构造函数构建的ListView没有应用基于Sliver的懒加载模型。实际上通过此方式创建的ListView和使用SingleChildScrollView+Column的方式没有本质的区别。下面是一个例子： ListView( shrinkWrap: true, padding: const EdgeInsets.all(20.0), children: [ const Text('I\\'m dedicating every day to you'), const Text('Domestic life was never quite my style'), const Text('When you smile, you knock me out, I fall apart'), const Text('And I thought I was so smart'), ], ); 再次强调，可滚动组件通过一个List来作为其children属性时，只适用于子组件较少的情况，这是一个通用规律，并非ListView自己的特性，像GridView也是如此。 ListView.builder ListView.builder适合列表项比较多（或者无限）的情况，因为只有当子组件真正显示的时候才会被创建，也就说通过该构造函数创建的ListView是支持基于Sliver的懒加载模型的。下面看一下ListView.builder的核心参数列表： ListView.builder({ // ListView公共参数已省略 ... @required IndexedWidgetBuilder itemBuilder, int itemCount, ... }) itemBuilder：它是列表项的构建器，类型为IndexedWidgetBuilder，返回值为一个widget。当列表滚动到具体的index位置时，会调用该构建器构建列表项。 itemCount：列表项的数量，如果为null，则为无限列表。 可滚动组件的构造函数如果需要一个列表项Builder，那么通过该构造函数构建的可滚动组件通常就是支持基于Sliver的懒加载模型的，反之则不支持，这是个一般规律。我们在后面在介绍可滚动组件的构造函数时将不再专门说明其是否支持基于Sliver的懒加载模型了。 下面看一个例子： ListView.builder( itemCount: 100, itemExtent: 50.0, //强制高度为50.0 itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); } ); 运行效果如图6-2所示： ListView.separated ListView.separated可以在生成的列表项之间添加一个分割组件，它比ListView.builder多了一个separatorBuilder参数，该参数是一个分割组件生成器。 下面我们看一个例子：奇数行添加一条蓝色下划线，偶数行添加一条绿色下划线。 class ListView3 extends StatelessWidget { @override Widget build(BuildContext context) { //下划线widget预定义以供复用。 Widget divider1=Divider(color: Colors.blue,); Widget divider2=Divider(color: Colors.green); return ListView.separated( itemCount: 100, //列表项构造器 itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); }, //分割器构造器 separatorBuilder: (BuildContext context, int index) { return index%2==0?divider1:divider2; }, ); } } 实例：无限加载列表 假设我们要从数据源异步分批拉取一些数据，然后用ListView展示，当我们滑动到列表末尾时，判断是否需要再去拉取数据，如果是，则去拉取，拉取过程中在表尾显示一个loading，拉取成功后将数据插入列表；如果不需要再去拉取，则在表尾提示\"没有更多\"。代码如下： class InfiniteListView extends StatefulWidget { @override _InfiniteListViewState createState() => new _InfiniteListViewState(); } class _InfiniteListViewState extends State { static const loadingTag = \"##loading##\"; //表尾标记 var _words = [loadingTag]; @override void initState() { super.initState(); _retrieveData(); } @override Widget build(BuildContext context) { return ListView.separated( itemCount: _words.length, itemBuilder: (context, index) { //如果到了表尾 if (_words[index] == loadingTag) { //不足100条，继续获取数据 if (_words.length - 1 Divider(height: .0), ); } void _retrieveData() { Future.delayed(Duration(seconds: 2)).then((e) { _words.insertAll(_words.length - 1, //每次生成20个单词 generateWordPairs().take(20).map((e) => e.asPascalCase).toList() ); setState(() { //重新构建列表 }); }); } } 运行后效果如图6-4、6-5所示： 代码比较简单，读者可以参照代码中的注释理解，故不再赘述。需要说明的是，_retrieveData()的功能是模拟从数据源异步获取数据，我们使用english_words包的generateWordPairs()方法每次生成20个单词。 添加固定列表头 很多时候我们需要给列表添加一个固定表头，比如我们想实现一个商品列表，需要在列表顶部添加一个“商品列表”标题，期望的效果如图6-6所示： 我们按照之前经验，写出如下代码： @override Widget build(BuildContext context) { return Column(children: [ ListTile(title:Text(\"商品列表\")), ListView.builder(itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); }), ]); } 然后运行，发现并没有出现我们期望的效果，相反触发了一个异常； Error caught by rendering library, thrown during performResize()。 Vertical viewport was given unbounded height ... 从异常信息中我们可以看到是因为ListView高度边界无法确定引起，所以解决的办法也很明显，我们需要给ListView指定边界，我们通过SizedBox指定一个列表高度看看是否生效： ... //省略无关代码 SizedBox( height: 400, //指定列表高度为400 child: ListView.builder(itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); }), ), ... 运行效果如图6-7所示： 可以看到，现在没有触发异常并且列表已经显示出来了，但是我们的手机屏幕高度要大于400，所以底部会有一些空白。那如果我们要实现列表铺满除表头以外的屏幕空间应该怎么做？直观的方法是我们去动态计算，用屏幕高度减去状态栏、导航栏、表头的高度即为剩余屏幕高度，代码如下： ... //省略无关代码 SizedBox( //Material设计规范中状态栏、导航栏、ListTile高度分别为24、56、56 height: MediaQuery.of(context).size.height-24-56-56, child: ListView.builder(itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); }), ) ... 运行效果如下图6-8所示： 可以看到，我们期望的效果实现了，但是这种方法并不优雅，如果页面布局发生变化，比如表头布局调整导致表头高度改变，那么剩余空间的高度就得重新计算。那么有什么方法可以自动拉伸ListView以填充屏幕剩余空间的方法吗？当然有！答案就是Flex。前面已经介绍过在弹性布局中，可以使用Expanded自动拉伸组件大小，并且我们也说过Column是继承自Flex的，所以我们可以直接使用Column+Expanded来实现，代码如下： @override Widget build(BuildContext context) { return Column(children: [ ListTile(title:Text(\"商品列表\")), Expanded( child: ListView.builder(itemBuilder: (BuildContext context, int index) { return ListTile(title: Text(\"$index\")); }), ), ]); } 运行后，和上图一样，完美实现了！ 总结 本节主要介绍了ListView的一些公共参数以及常用的构造函数。不同的构造函数对应了不同的列表项生成模型，如果需要自定义列表项生成模型，可以通过ListView.custom来自定义，它需要实现一个SliverChildDelegate用来给ListView生成列表项组件，更多详情请参考API文档。 "},"chapter6/gridview.html":{"url":"chapter6/gridview.html","title":"6.4：GridView","keywords":"","body":"6.4 GridView GridView可以构建一个二维网格列表，其默认构造函数定义如下： GridView({ Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController controller, bool primary, ScrollPhysics physics, bool shrinkWrap = false, EdgeInsetsGeometry padding, @required SliverGridDelegate gridDelegate, //控制子widget layout的委托 bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, double cacheExtent, List children = const [], }) 我们可以看到，GridView和ListView的大多数参数都是相同的，它们的含义也都相同的，如有疑惑读者可以翻阅ListView一节，在此不再赘述。我们唯一需要关注的是gridDelegate参数，类型是SliverGridDelegate，它的作用是控制GridView子组件如何排列(layout)。 SliverGridDelegate是一个抽象类，定义了GridView Layout相关接口，子类需要通过实现它们来实现具体的布局算法。Flutter中提供了两个SliverGridDelegate的子类SliverGridDelegateWithFixedCrossAxisCount和SliverGridDelegateWithMaxCrossAxisExtent，我们可以直接使用。下面我们分别来它们。 SliverGridDelegateWithFixedCrossAxisCount 该子类实现了一个横轴为固定数量子元素的layout算法，其构造函数为： SliverGridDelegateWithFixedCrossAxisCount({ @required double crossAxisCount, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, }) crossAxisCount：横轴子元素的数量。此属性值确定后子元素在横轴的长度就确定了，即ViewPort横轴长度除以crossAxisCount的商。 mainAxisSpacing：主轴方向的间距。 crossAxisSpacing：横轴方向子元素的间距。 childAspectRatio：子元素在横轴长度和主轴长度的比例。由于crossAxisCount指定后，子元素横轴长度就确定了，然后通过此参数值就可以确定子元素在主轴的长度。 可以发现，子元素的大小是通过crossAxisCount和childAspectRatio两个参数共同决定的。注意，这里的子元素指的是子组件的最大显示空间，注意确保子组件的实际大小不要超出子元素的空间。 下面看一个例子： GridView( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 3, //横轴三个子widget childAspectRatio: 1.0 //宽高比为1时，子widget ), children:[ Icon(Icons.ac_unit), Icon(Icons.airport_shuttle), Icon(Icons.all_inclusive), Icon(Icons.beach_access), Icon(Icons.cake), Icon(Icons.free_breakfast) ] ); GridView.count GridView.count构造函数内部使用了SliverGridDelegateWithFixedCrossAxisCount，我们通过它可以快速的创建横轴固定数量子元素的GridView，上面的示例代码等价于： GridView.count( crossAxisCount: 3, childAspectRatio: 1.0, children: [ Icon(Icons.ac_unit), Icon(Icons.airport_shuttle), Icon(Icons.all_inclusive), Icon(Icons.beach_access), Icon(Icons.cake), Icon(Icons.free_breakfast), ], ); SliverGridDelegateWithMaxCrossAxisExtent 该子类实现了一个横轴子元素为固定最大长度的layout算法，其构造函数为： SliverGridDelegateWithMaxCrossAxisExtent({ double maxCrossAxisExtent, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, }) maxCrossAxisExtent为子元素在横轴上的最大长度，之所以是“最大”长度，是因为横轴方向每个子元素的长度仍然是等分的，举个例子，如果ViewPort的横轴长度是450，那么当maxCrossAxisExtent的值在区间[450/4，450/3)内的话，子元素最终实际长度都为112.5，而childAspectRatio所指的子元素横轴和主轴的长度比为最终的长度比。其它参数和SliverGridDelegateWithFixedCrossAxisCount相同。 下面我们看一个例子： GridView( padding: EdgeInsets.zero, gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent( maxCrossAxisExtent: 120.0, childAspectRatio: 2.0 //宽高比为2 ), children: [ Icon(Icons.ac_unit), Icon(Icons.airport_shuttle), Icon(Icons.all_inclusive), Icon(Icons.beach_access), Icon(Icons.cake), Icon(Icons.free_breakfast), ], ); GridView.extent GridView.extent构造函数内部使用了SliverGridDelegateWithMaxCrossAxisExtent，我们通过它可以快速的创建纵轴子元素为固定最大长度的的GridView，上面的示例代码等价于： GridView.extent( maxCrossAxisExtent: 120.0, childAspectRatio: 2.0, children: [ Icon(Icons.ac_unit), Icon(Icons.airport_shuttle), Icon(Icons.all_inclusive), Icon(Icons.beach_access), Icon(Icons.cake), Icon(Icons.free_breakfast), ], ); GridView.builder 上面我们介绍的GridView都需要一个widget数组作为其子元素，这些方式都会提前将所有子widget都构建好，所以只适用于子widget数量比较少时，当子widget比较多时，我们可以通过GridView.builder来动态创建子widget。GridView.builder 必须指定的参数有两个： GridView.builder( ... @required SliverGridDelegate gridDelegate, @required IndexedWidgetBuilder itemBuilder, ) 其中itemBuilder为子widget构建器。 示例 假设我们需要从一个异步数据源（如网络）分批获取一些Icon，然后用GridView来展示： class InfiniteGridView extends StatefulWidget { @override _InfiniteGridViewState createState() => new _InfiniteGridViewState(); } class _InfiniteGridViewState extends State { List _icons = []; //保存Icon数据 @override void initState() { // 初始化数据 _retrieveIcons(); } @override Widget build(BuildContext context) { return GridView.builder( gridDelegate: SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 3, //每行三列 childAspectRatio: 1.0 //显示区域宽高相等 ), itemCount: _icons.length, itemBuilder: (context, index) { //如果显示到最后一个并且Icon总数小于200时继续获取数据 if (index == _icons.length - 1 && _icons.length _retrieveIcons()：在此方法中我们通过Future.delayed来模拟从异步数据源获取数据，每次获取数据需要200毫秒，获取成功后将新数据添加到_icons，然后调用setState重新构建。 在itemBuilder中，如果显示到最后一个时，判断是否需要继续获取数据，然后返回一个Icon。 更多 Flutter的GridView默认子元素显示空间是相等的，但在实际开发中，你可能会遇到子元素大小不等的情况，如下面这样的布局： Pub上有一个包“flutter_staggered_grid_view” ，它实现了一个交错GridView的布局模型，可以很轻松的实现这种布局，详情读者可以自行了解。 "},"chapter6/custom_scrollview.html":{"url":"chapter6/custom_scrollview.html","title":"6.5：CustomScrollView","keywords":"","body":"6.5 CustomScrollView CustomScrollView是可以使用Sliver来自定义滚动模型（效果）的组件。它可以包含多种滚动模型，举个例子，假设有一个页面，顶部需要一个GridView，底部需要一个ListView，而要求整个页面的滑动效果是统一的，即它们看起来是一个整体。如果使用GridView+ListView来实现的话，就不能保证一致的滑动效果，因为它们的滚动效果是分离的，所以这时就需要一个\"胶水\"，把这些彼此独立的可滚动组件\"粘\"起来，而CustomScrollView的功能就相当于“胶水”。 可滚动组件的Sliver版 Sliver在前面讲过，有细片、薄片之意，在Flutter中，Sliver通常指可滚动组件子元素（就像一个个薄片一样）。但是在CustomScrollView中，需要粘起来的可滚动组件就是CustomScrollView的Sliver了，如果直接将ListView、GridView作为CustomScrollView是不行的，因为它们本身是可滚动组件而并不是Sliver！因此，为了能让可滚动组件能和CustomScrollView配合使用，Flutter提供了一些可滚动组件的Sliver版，如SliverList、SliverGrid等。实际上Sliver版的可滚动组件和非Sliver版的可滚动组件最大的区别就是前者不包含滚动模型（子身不能再滚动），而后者包含滚动模型 ，也正因如此，CustomScrollView才可以将多个Sliver\"粘\"在一起，这些Sliver共用CustomScrollView的Scrollable，所以最终才实现了统一的滑动效果。 Sliver系列Widget比较多，我们不会一一介绍，读者只需记住它的特点，需要时再去查看文档即可。上面之所以说“大多数“Sliver都和可滚动组件对应，是由于还有一些如SliverPadding、SliverAppBar等是和可滚动组件无关的，它们主要是为了结合CustomScrollView一起使用，这是因为CustomScrollView的子组件必须都是Sliver。 示例 import 'package:flutter/material.dart'; class CustomScrollViewTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { //因为本路由没有使用Scaffold，为了让子级Widget(如Text)使用 //Material Design 默认的样式风格,我们使用Material作为本路由的根。 return Material( child: CustomScrollView( slivers: [ //AppBar，包含一个导航栏 SliverAppBar( pinned: true, expandedHeight: 250.0, flexibleSpace: FlexibleSpaceBar( title: const Text('Demo'), background: Image.asset( \"./images/avatar.png\", fit: BoxFit.cover,), ), ), SliverPadding( padding: const EdgeInsets.all(8.0), sliver: new SliverGrid( //Grid gridDelegate: new SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 2, //Grid按两列显示 mainAxisSpacing: 10.0, crossAxisSpacing: 10.0, childAspectRatio: 4.0, ), delegate: new SliverChildBuilderDelegate( (BuildContext context, int index) { //创建子widget return new Container( alignment: Alignment.center, color: Colors.cyan[100 * (index % 9)], child: new Text('grid item $index'), ); }, childCount: 20, ), ), ), //List new SliverFixedExtentList( itemExtent: 50.0, delegate: new SliverChildBuilderDelegate( (BuildContext context, int index) { //创建列表项 return new Container( alignment: Alignment.center, color: Colors.lightBlue[100 * (index % 9)], child: new Text('list item $index'), ); }, childCount: 50 //50个列表项 ), ), ], ), ); } } 代码分为三部分： 头部SliverAppBar：SliverAppBar对应AppBar，两者不同之处在于SliverAppBar可以集成到CustomScrollView。SliverAppBar可以结合FlexibleSpaceBar实`Material Design中头部伸缩的模型，具体效果，读者可以运行该示例查看。 中间的SliverGrid：它用SliverPadding包裹以给SliverGrid添加补白。SliverGrid是一个两列，宽高比为4的网格，它有20个子组件。 底部SliverFixedExtentList：它是一个所有子元素高度都为50像素的列表。 运行效果如图： "},"chapter6/scroll_controller.html":{"url":"chapter6/scroll_controller.html","title":"6.6：滚动监听及控制（ScrollController）","keywords":"","body":"6.6 滚动监听及控制 在前几节中，我们介绍了Flutter中常用的可滚动组件，也说过可以用ScrollController来控制可滚动组件的滚动位置，本节先介绍一下ScrollController，然后以ListView为例，展示一下ScrollController的具体用法。最后，再介绍一下路由切换时如何来保存滚动位置。 6.6.1 ScrollController ScrollController构造函数如下： ScrollController({ double initialScrollOffset = 0.0, //初始滚动位置 this.keepScrollOffset = true,//是否保存滚动位置 ... }) 我们介绍一下ScrollController常用的属性和方法： offset：可滚动组件当前的滚动位置。 jumpTo(double offset)、animateTo(double offset,...)：这两个方法用于跳转到指定的位置，它们不同之处在于，后者在跳转时会执行一个动画，而前者不会。 ScrollController还有一些属性和方法，我们将在后面原理部分解释。 滚动监听 ScrollController间接继承自Listenable，我们可以根据ScrollController来监听滚动事件，如： controller.addListener(()=>print(controller.offset)) 示例 我们创建一个ListView，当滚动位置发生变化时，我们先打印出当前滚动位置，然后判断当前位置是否超过1000像素，如果超过则在屏幕右下角显示一个“返回顶部”的按钮，该按钮点击后可以使ListView恢复到初始位置；如果没有超过1000像素，则隐藏“返回顶部”按钮。代码如下： class ScrollControllerTestRoute extends StatefulWidget { @override ScrollControllerTestRouteState createState() { return new ScrollControllerTestRouteState(); } } class ScrollControllerTestRouteState extends State { ScrollController _controller = new ScrollController(); bool showToTopBtn = false; //是否显示“返回到顶部”按钮 @override void initState() { //监听滚动事件，打印滚动位置 _controller.addListener(() { print(_controller.offset); //打印滚动位置 if (_controller.offset = 1000 && showToTopBtn == false) { setState(() { showToTopBtn = true; }); } }); } @override void dispose() { //为了避免内存泄露，需要调用_controller.dispose _controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(\"滚动控制\")), body: Scrollbar( child: ListView.builder( itemCount: 100, itemExtent: 50.0, //列表项高度固定时，显式指定高度是一个好习惯(性能消耗小) controller: _controller, itemBuilder: (context, index) { return ListTile(title: Text(\"$index\"),); } ), ), floatingActionButton: !showToTopBtn ? null : FloatingActionButton( child: Icon(Icons.arrow_upward), onPressed: () { //返回到顶部时执行动画 _controller.animateTo(.0, duration: Duration(milliseconds: 200), curve: Curves.ease ); } ), ); } } 代码说明已经包含在注释里，下面我们看看运行效果： 由于列表项高度为50像素，当滑动到第20个列表项后，右下角“返回顶部”按钮会显示，点击该按钮，ListView会在返回顶部的过程中执行一个滚动动画，动画时间是200毫秒，动画曲线是Curves.ease，关于动画的详细内容我们将在后面“动画”一章中详细介绍。 滚动位置恢复 PageStorage是一个用于保存页面(路由)相关数据的组件，它并不会影响子树的UI外观，其实，PageStorage是一个功能型组件，它拥有一个存储桶（bucket），子树中的Widget可以通过指定不同的PageStorageKey来存储各自的数据或状态。 每次滚动结束，可滚动组件都会将滚动位置offset存储到PageStorage中，当可滚动组件重新创建时再恢复。如果ScrollController.keepScrollOffset为false，则滚动位置将不会被存储，可滚动组件重新创建时会使用ScrollController.initialScrollOffset；ScrollController.keepScrollOffset为true时，可滚动组件在第一次创建时，会滚动到initialScrollOffset处，因为这时还没有存储过滚动位置。在接下来的滚动中就会存储、恢复滚动位置，而initialScrollOffset会被忽略。 当一个路由中包含多个可滚动组件时，如果你发现在进行一些跳转或切换操作后，滚动位置不能正确恢复，这时你可以通过显式指定PageStorageKey来分别跟踪不同的可滚动组件的位置，如： ListView(key: PageStorageKey(1), ... ); ... ListView(key: PageStorageKey(2), ... ); 不同的PageStorageKey，需要不同的值，这样才可以为不同可滚动组件保存其滚动位置。 注意：一个路由中包含多个可滚动组件时，如果要分别跟踪它们的滚动位置，并非一定就得给他们分别提供PageStorageKey。这是因为Scrollable本身是一个StatefulWidget，它的状态中也会保存当前滚动位置，所以，只要可滚动组件本身没有被从树上detach掉，那么其State就不会销毁(dispose)，滚动位置就不会丢失。只有当Widget发生结构变化，导致可滚动组件的State销毁或重新构建时才会丢失状态，这种情况就需要显式指定PageStorageKey，通过PageStorage来存储滚动位置，一个典型的场景是在使用TabBarView时，在Tab发生切换时，Tab页中的可滚动组件的State就会销毁，这时如果想恢复滚动位置就需要指定PageStorageKey。 ScrollPosition ScrollPosition是用来保存可滚动组件的滚动位置的。一个ScrollController对象可以同时被多个可滚动组件使用，ScrollController会为每一个可滚动组件创建一个ScrollPosition对象，这些ScrollPosition保存在ScrollController的positions属性中（List）。ScrollPosition是真正保存滑动位置信息的对象，offset只是一个便捷属性： double get offset => position.pixels; 一个ScrollController虽然可以对应多个可滚动组件，但是有一些操作，如读取滚动位置offset，则需要一对一！但是我们仍然可以在一对多的情况下，通过其它方法读取滚动位置，举个例子，假设一个ScrollController同时被两个可滚动组件使用，那么我们可以通过如下方式分别读取他们的滚动位置： ... controller.positions.elementAt(0).pixels controller.positions.elementAt(1).pixels ... 我们可以通过controller.positions.length来确定controller被几个可滚动组件使用。 ScrollPosition的方法 ScrollPosition有两个常用方法：animateTo() 和 jumpTo()，它们是真正来控制跳转滚动位置的方法，ScrollController的这两个同名方法，内部最终都会调用ScrollPosition的。 ScrollController控制原理 我们来介绍一下ScrollController的另外三个方法： ScrollPosition createScrollPosition( ScrollPhysics physics, ScrollContext context, ScrollPosition oldPosition); void attach(ScrollPosition position) ; void detach(ScrollPosition position) ; 当ScrollController和可滚动组件关联时，可滚动组件首先会调用ScrollController的createScrollPosition()方法来创建一个ScrollPosition来存储滚动位置信息，接着，可滚动组件会调用attach()方法，将创建的ScrollPosition添加到ScrollController的positions属性中，这一步称为“注册位置”，只有注册后animateTo() 和 jumpTo()才可以被调用。 当可滚动组件销毁时，会调用ScrollController的detach()方法，将其ScrollPosition对象从ScrollController的positions属性中移除，这一步称为“注销位置”，注销后animateTo() 和 jumpTo() 将不能再被调用。 需要注意的是，ScrollController的animateTo() 和 jumpTo()内部会调用所有ScrollPosition的animateTo() 和 jumpTo()，以实现所有和该ScrollController关联的可滚动组件都滚动到指定的位置。 6.6.2 滚动监听 Flutter Widget树中子Widget可以通过发送通知（Notification）与父(包括祖先)Widget通信。父级组件可以通过NotificationListener组件来监听自己关注的通知，这种通信方式类似于Web开发中浏览器的事件冒泡，我们在Flutter中沿用“冒泡”这个术语，关于通知冒泡我们将在后面”事件处理与通知“一章中详细介绍。 可滚动组件在滚动时会发送ScrollNotification类型的通知，ScrollBar正是通过监听滚动通知来实现的。通过NotificationListener监听滚动事件和通过ScrollController有两个主要的不同： 通过NotificationListener可以在从可滚动组件到widget树根之间任意位置都能监听。而ScrollController只能和具体的可滚动组件关联后才可以。 收到滚动事件后获得的信息不同；NotificationListener在收到滚动事件时，通知中会携带当前滚动位置和ViewPort的一些信息，而ScrollController只能获取当前滚动位置。 示例 下面，我们监听ListView的滚动通知，然后显示当前滚动进度百分比： import 'package:flutter/material.dart'; class ScrollNotificationTestRoute extends StatefulWidget { @override _ScrollNotificationTestRouteState createState() => new _ScrollNotificationTestRouteState(); } class _ScrollNotificationTestRouteState extends State { String _progress = \"0%\"; //保存进度百分比 @override Widget build(BuildContext context) { return Scrollbar( //进度条 // 监听滚动通知 child: NotificationListener( onNotification: (ScrollNotification notification) { double progress = notification.metrics.pixels / notification.metrics.maxScrollExtent; //重新构建 setState(() { _progress = \"${(progress * 100).toInt()}%\"; }); print(\"BottomEdge: ${notification.metrics.extentAfter == 0}\"); //return true; //放开此行注释后，进度条将失效 }, child: Stack( alignment: Alignment.center, children: [ ListView.builder( itemCount: 100, itemExtent: 50.0, itemBuilder: (context, index) { return ListTile(title: Text(\"$index\")); } ), CircleAvatar( //显示进度百分比 radius: 30.0, child: Text(_progress), backgroundColor: Colors.black54, ) ], ), ), ); } } 运行结果如图6-16所示： 在接收到滚动事件时，参数类型为ScrollNotification，它包括一个metrics属性，它的类型是ScrollMetrics，该属性包含当前ViewPort及滚动位置等信息： pixels：当前滚动位置。 maxScrollExtent：最大可滚动长度。 extentBefore：滑出ViewPort顶部的长度；此示例中相当于顶部滑出屏幕上方的列表长度。 extentInside：ViewPort内部长度；此示例中屏幕显示的列表部分的长度。 extentAfter：列表中未滑入ViewPort部分的长度；此示例中列表底部未显示到屏幕范围部分的长度。 atEdge：是否滑到了可滚动组件的边界（此示例中相当于列表顶或底部）。 ScrollMetrics还有一些其它属性，读者可以自行查阅API文档。 "},"chapter7/":{"url":"chapter7/","title":"第七章：功能型组件","keywords":"","body":"功能型Widget简介 功能型Widget指的是不会影响UI布局及外观的Widget，它们通常具有一定的功能，如事件监听、数据存储等，我们之前介绍过的FocusScope（焦点控制）、PageStorage（数据存储）、NotificationListener（事件监听）都属于功能型Widget。由于Widget是Flutter的一等公民，功能型Widget非常多，我们不会去一一介绍，本章中主要介绍几种常用的功能型Widget。 本章目录 7.1：导航返回拦截（WillPopScope） 7.2：数据共享（InheritedWidget） 7.3： 跨组件状态共享（Provider） 7.4：颜色和主题（Theme） 7.5：异步UI更新（FutureBuilder、StreamBuilder） 7.6：对话框详解 "},"chapter7/willpopscope.html":{"url":"chapter7/willpopscope.html","title":"7.1：导航返回拦截（WillPopScope）","keywords":"","body":"7.1 导航返回拦截（WillPopScope） 为了避免用户误触返回按钮而导致APP退出，在很多APP中都拦截了用户点击返回键的按钮，然后进行一些防误触判断，比如当用户在某一个时间段内点击两次时，才会认为用户是要退出（而非误触）。Flutter中可以通过WillPopScope来实现返回按钮拦截，我们看看WillPopScope的默认构造函数： const WillPopScope({ ... @required WillPopCallback onWillPop, @required Widget child }) onWillPop是一个回调函数，当用户点击返回按钮时被调用（包括导航返回按钮及Android物理返回按钮）。该回调需要返回一个Future对象，如果返回的Future最终值为false时，则当前路由不出栈(不会返回)；最终值为true时，当前路由出栈退出。我们需要提供这个回调来决定是否退出。 示例 为了防止用户误触返回键退出，我们拦截返回事件。当用户在1秒内点击两次返回按钮时，则退出；如果间隔超过1秒则不退出，并重新记时。代码如下： import 'package:flutter/material.dart'; class WillPopScopeTestRoute extends StatefulWidget { @override WillPopScopeTestRouteState createState() { return new WillPopScopeTestRouteState(); } } class WillPopScopeTestRouteState extends State { DateTime _lastPressedAt; //上次点击时间 @override Widget build(BuildContext context) { return new WillPopScope( onWillPop: () async { if (_lastPressedAt == null || DateTime.now().difference(_lastPressedAt) > Duration(seconds: 1)) { //两次点击间隔超过1秒则重新计时 _lastPressedAt = DateTime.now(); return false; } return true; }, child: Container( alignment: Alignment.center, child: Text(\"1秒内连续按两次返回键退出\"), ) ); } } 读者可以运行示例看看效果。 "},"chapter7/inherited_widget.html":{"url":"chapter7/inherited_widget.html","title":"7.2：数据共享（InheritedWidget）","keywords":"","body":"7.2 数据共享（InheritedWidget） InheritedWidget是Flutter中非常重要的一个功能型组件，它提供了一种数据在widget树种从上到下的传递、共享方式，比如我们在应用的根widget中通过InheritedWidget共享了一个数据，那么我们便可以在任意子widget中来获取该共享的数据！这个特性在一些需要在widget树中共享数据的场景中非常方便！如Flutter SDK中正是通过InheritedWidget来共享应用主题（Theme）和Locale (当前语言环境)信息的。 InheritedWidget和React中的context功能类似，和逐级传递数据相比，它们能实现组件跨级传递数据。InheritedWidget的在widget树中数据传递方向是从上到下的，这和通知Notification（将在下一章中介绍）的传递方向正好相反。 didChangeDependencies 在之前介绍StatefulWidget时，我们提到State对象有一个didChangeDependencies回调，它会在“依赖”发生变化时被Flutter Framework调用。而这个“依赖”指的就是子widget是否使用了父widget中InheritedWidget的数据！如果使用了，则代表子widget依赖有依赖InheritedWidget；如果没有使用则代表没有依赖。这种机制可以使子组件在所依赖的InheritedWidget变化时来更新自身！比如当主题、locale(语言)等发生变化时，依赖其的子widget的didChangeDependencies方法将会被调用。 下面我们看一下之前“计数器”示例应用程序的InheritedWidget版本。需要说明的是，本示例主要是为了演示InheritedWidget的功能特性，并不是计数器的推荐实现方式。 首先，我们通过继承InheritedWidget，将当前计数器点击次数保存在ShareDataWidget的data属性中： class ShareDataWidget extends InheritedWidget { ShareDataWidget({ @required this.data, Widget child }) :super(child: child); final int data; //需要在子树中共享的数据，保存点击次数 //定义一个便捷方法，方便子树中的widget获取共享数据 static ShareDataWidget of(BuildContext context) { return context.inheritFromWidgetOfExactType(ShareDataWidget); } //该回调决定当data发生变化时，是否通知子树中依赖data的Widget @override bool updateShouldNotify(ShareDataWidget old) { //如果返回true，则子树中依赖(build函数中有调用)本widget //的子widget的`state.didChangeDependencies`会被调用 return old.data != data; } } 然后我们实现一个子组件_TestWidget，在其build方法中引用ShareDataWidget中的数据。同时，在其didChangeDependencies() 回调中打印日志： class _TestWidget extends StatefulWidget { @override __TestWidgetState createState() => new __TestWidgetState(); } class __TestWidgetState extends State { @override Widget build(BuildContext context) { //使用InheritedWidget中的共享数据 return Text(ShareDataWidget .of(context) .data .toString()); } @override void didChangeDependencies() { super.didChangeDependencies(); //父或祖先widget中的InheritedWidget改变(updateShouldNotify返回true)时会被调用。 //如果build中没有依赖InheritedWidget，则此回调不会被调用。 print(\"Dependencies change\"); } } 最后，我们创建一个按钮，每点击一次，就将ShareDataWidget的值自增： class InheritedWidgetTestRoute extends StatefulWidget { @override _InheritedWidgetTestRouteState createState() => new _InheritedWidgetTestRouteState(); } class _InheritedWidgetTestRouteState extends State { int count = 0; @override Widget build(BuildContext context) { return Center( child: ShareDataWidget( //使用ShareDataWidget data: count, child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Padding( padding: const EdgeInsets.only(bottom: 20.0), child: _TestWidget(),//子widget中依赖ShareDataWidget ), RaisedButton( child: Text(\"Increment\"), //每点击一次，将count自增，然后重新build,ShareDataWidget的data将被更新 onPressed: () => setState(() => ++count), ) ], ), ), ); } } 运行后界面如图7-1所示： 每点击一次按钮，计数器就会自增，控制台就会打印一句日志： I/flutter ( 8513): Dependencies change 可见依赖发生变化后，其didChangeDependencies()会被调用。但是读者要注意，如果_TestWidget的build方法中没有使用ShareDataWidget的数据，那么它的didChangeDependencies()将不会被调用，因为它并没有依赖ShareDataWidget。例如，我们将__TestWidgetState代码该为下面这样，didChangeDependencies()将不会被调用: class __TestWidgetState extends State { @override Widget build(BuildContext context) { // 使用InheritedWidget中的共享数据 // return Text(ShareDataWidget // .of(context) // .data // .toString()); return Text(\"text\"); } @override void didChangeDependencies() { super.didChangeDependencies(); // build方法中没有依赖InheritedWidget，此回调不会被调用。 print(\"Dependencies change\"); } } 上面的代码中，我们将build()方法中依赖ShareDataWidget的代码注释掉了，然后返回一个固定Text，这样一来，当点击Increment按钮后，ShareDataWidget的data虽然发生变化，但由于__TestWidgetState并未依赖ShareDataWidget，所以__TestWidgetState的didChangeDependencies方法不会被调用。其实，这个机制很好理解，因为在数据发生变化时只对使用该数据的Widget更新是合理并且性能友好的。 思考题：Flutter framework是怎么知道子widget有没有依赖InheritedWidget的？ 应该在didChangeDependencies()中做什么？ 一般来说，子widget很少会重写此方法，因为在依赖改变后framework也都会调用build()方法。但是，如果你需要在依赖改变后执行一些昂贵的操作，比如网络请求，这时最好的方式就是在此方法中执行，这样可以避免每次build()都执行这些昂贵操作。 深入了解InheritedWidget 现在来思考一下，如果我们只想在__TestWidgetState中引用ShareDataWidget数据，但却不希望在ShareDataWidget发生变化时调用__TestWidgetState的didChangeDependencies()方法应该怎么办？其实答案很简单，我们只需要将ShareDataWidget.of()的实现改一下即可： //定义一个便捷方法，方便子树中的widget获取共享数据 static ShareDataWidget of(BuildContext context) { //return context.inheritFromWidgetOfExactType(ShareDataWidget); return context.ancestorInheritedElementForWidgetOfExactType(ShareDataWidget).widget; } 唯一的改动就是获取ShareDataWidget对象的方式，把inheritFromWidgetOfExactType()方法换成了context.ancestorInheritedElementForWidgetOfExactType(ShareDataWidget).widget，那么他们到底有什么区别呢，我们看一下这两个方法的源码（实现代码在Element类中，Context和Element的关系我们将在后面专门介绍）： @override InheritedElement ancestorInheritedElementForWidgetOfExactType(Type targetType) { final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[targetType]; return ancestor; } @override InheritedWidget inheritFromWidgetOfExactType(Type targetType, { Object aspect }) { final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[targetType]; //多出的部分 if (ancestor != null) { assert(ancestor is InheritedElement); return inheritFromElement(ancestor, aspect: aspect); } _hadUnsatisfiedDependencies = true; return null; } 我们可以看到，inheritFromWidgetOfExactType() 比 ancestorInheritedElementForWidgetOfExactType()多调了inheritFromElement方法，inheritFromElement源码如下： @override InheritedWidget inheritFromElement(InheritedElement ancestor, { Object aspect }) { //注册依赖关系 _dependencies ??= HashSet(); _dependencies.add(ancestor); ancestor.updateDependencies(this, aspect); return ancestor.widget; } 可以看到inheritFromElement方法中主要是注册了依赖关系！看到这里也就清晰了，调用inheritFromWidgetOfExactType() 和 ancestorInheritedElementForWidgetOfExactType()的区别就是前者会注册依赖关系，而后者不会，所以在调用inheritFromWidgetOfExactType()时，InheritedWidget和依赖它的子孙组件关系变完成了注册，之后当InheritedWidget发生变化时，就会更新依赖它的孙组件，也就是会调用依赖它的孙组件的didChangeDependencies()方法和build()方法。而当调用的是 ancestorInheritedElementForWidgetOfExactType()时，由于没有注册依赖关系，所以之后当InheritedWidget发生变化时，就不会更新相应的子孙Widget。 注意，如果将上面示例中ShareDataWidget.of()方法实现改成调用ancestorInheritedElementForWidgetOfExactType()，运行示例后，点击\"Increment\"按钮，会发现__TestWidgetState的didChangeDependencies()方法确实不会再被调用，但是其build()仍然会被调用！造成这个的原因其实是，点击\"Increment\"按钮后，会调用_InheritedWidgetTestRouteState的setState()方法，此时会重新构建整个页面，由于示例中，__TestWidget 并没有任何缓存，所以它也都会被重新构建，所以也会调用build()方法。 那么，现在就带来了一个问题：实际上，我们只想更新子树中依赖了ShareDataWidget的组件，而现在只要调用_InheritedWidgetTestRouteState的setState()方法，所有子节点都会被重新build，这很没必要，那么有什么办法可以避免呢？答案是缓存！一个简单的作法就是通过封装一个StatefulWidget，将子Widget树缓存起来，具体作法下一节我们将通过实现一个Provider Widget 来演示如何缓存，以及如何利用InheritedWidget 来实现Flutter全局状态共享。 "},"chapter7/provider.html":{"url":"chapter7/provider.html","title":"7.3： 跨组件状态共享（Provider）","keywords":"","body":"7.3 跨组件状态共享（Provider） 在Flutter开发中，状态管理是一个永恒的话题。一般的原则是：如果状态是组件私有的，则应该由组件自己管理；如果状态要跨组件共享，则该状态应该由各个组件共同的父元素来管理。对于组件私有的状态管理很好理解，但对于跨组件共享的状态，管理的方式就比较多了，如使用全局事件总线EventBus（将在下一章中介绍），它是一个观察者模式的实现，通过它就可以实现跨组件状态同步：状态持有方（发布者）负责更新、发布状态，状态使用方（观察者）监听状态改变事件来执行一些操作。下面我们看一个登陆状态同步的简单示例： 定义事件： enum Event{ login, ... //省略其它事件 } 登录页代码大致如下： // 登录状态改变后发布状态改变事件 bus.emit(Event.login); 依赖登录状态的页面： void onLoginChanged(e){ //登录状态变化处理逻辑 } @override void initState() { //订阅登录状态改变事件 bus.on(Event.login,onLogin); super.initState(); } @override void dispose() { //取消订阅 bus.off(Event.login,onLogin); super.dispose(); } 我们可以发现，通过观察者模式来实现跨组件状态共享有一些明显的缺点： 必须显式定义各种事件，不好管理 订阅者必须需显式注册状态改变回调，也必须在组件销毁时手动去解绑回调以避免内存泄露。 在Flutter当中有没有更好的跨组件状态管理方式了呢？答案是肯定的，那怎么做的？我们想想前面介绍的InheritedWidget，它的天生特性就是能绑定InheritedWidget与依赖它的子孙组件的依赖关系，并且当InheritedWidget数据发生变化时，可以自动更新依赖的子孙组件！利用这个特性，我们可以将需要跨组件共享的状态保存在InheritedWidget中，然后在子组件中引用InheritedWidget即可，Flutter社区著名的Provider包正是基于这个思想实现的一套跨组件状态共享解决方案，接下来我们便详细介绍一下Provider的用法及原理。 Provider 为了加强读者的理解，我们不直接去看Provider包的源代码，相反，我会带着你根据上面描述的通过InheritedWidget实现的思路来一步一步地实现一个最小功能的Provider。 首先，我们需要一个保存需要共享的数据InheritedWidget，由于具体业务数据类型不可预期，为了通用性，我们使用泛型，定义一个通用的InheritedProvider类，它继承自InheritedWidget： // 一个通用的InheritedWidget，保存任需要跨组件共享的状态 class InheritedProvider extends InheritedWidget { InheritedProvider({@required this.data, Widget child}) : super(child: child); //共享状态使用泛型 final T data; @override bool updateShouldNotify(InheritedProvider old) { //在此简单返回true，则每次更新都会调用依赖其的子孙节点的`didChangeDependencies`。 return true; } } 数据保存的地方有了，那么接下来我们需要做的就是在数据发生变化的时候来重新构建InheritedProvider，那么现在就面临两个问题： 数据发生变化怎么通知？ 谁来重新构建InheritedProvider？ 第一个问题其实很好解决，我们当然可以使用之前介绍的eventBus来进行事件通知，但是为了更贴近Flutter开发，我们使用Flutter中SDK中提供的ChangeNotifier类 ，它继承自Listenable，也实现了一个Flutter风格的发布者-订阅者模式，ChangeNotifier定义大致如下： class ChangeNotifier implements Listenable { @override void addListener(VoidCallback listener) { //添加监听器 } @override void removeListener(VoidCallback listener) { //移除监听器 } void notifyListeners() { //通知所有监听器，触发监听器回调 } ... //省略无关代码 } 我们可以通过调用addListener()和removeListener()来添加、移除监听器（订阅者）；通过调用notifyListeners() 可以触发所有监听器回调。 现在，我们将要共享的状态放到一个Model类中，然后让它继承自ChangeNotifier，这样当共享的状态改变时，我们只需要调用notifyListeners() 来通知订阅者，然后由订阅者来重新构建InheritedProvider，这也是第二个问题的答案！接下来我们便实现这个订阅者类： // 该方法用于在Dart中获取模板类型 Type _typeOf() => T; class ChangeNotifierProvider extends StatefulWidget { ChangeNotifierProvider({ Key key, this.data, this.child, }); final Widget child; final T data; //定义一个便捷方法，方便子树中的widget获取共享数据 static T of(BuildContext context) { final type = _typeOf>(); final provider = context.inheritFromWidgetOfExactType(type) as InheritedProvider； return provider.data; } @override _ChangeNotifierProviderState createState() => _ChangeNotifierProviderState(); } 该类继承StatefulWidget，然后定义了一个of()静态方法供子类方便获取Widget树中的InheritedProvider中保存的共享状态(model)，下面我们实现该类对应的_ChangeNotifierProviderState类： class _ChangeNotifierProviderState extends State> { void update() { //如果数据发生变化（model类调用了notifyListeners），重新构建InheritedProvider setState(() => {}); } @override void didUpdateWidget(ChangeNotifierProvider oldWidget) { //当Provider更新时，如果新旧数据不\"==\"，则解绑旧数据监听，同时添加新数据监听 if (widget.data != oldWidget.data) { oldWidget.data.removeListener(update); widget.data.addListener(update); } super.didUpdateWidget(oldWidget); } @override void initState() { // 给model添加监听器 widget.data.addListener(update); super.initState(); } @override void dispose() { // 移除model的监听器 widget.data.removeListener(update); super.dispose(); } @override Widget build(BuildContext context) { return InheritedProvider( data: widget.data, child: widget.child, ); } } 可以看到_ChangeNotifierProviderState类的主要作用就是监听到共享状态（model）改变时重新构建Widget树。注意，在_ChangeNotifierProviderState类中调用setState()方法，widget.child始终是同一个，所以执行build时，InheritedProvider的child引用的始终是同一个子widget，所以widget.child并不会重新build，这也就相当于对child进行了缓存！当然如果ChangeNotifierProvider父级Widget重新build时，则其传入的child便有可能会发生变化。 现在我们所需要的各个工具类都已完成，下面我们通过一个购物车的例子来看看怎么使用上面的这些类。 购物车示例 我们需要实现一个显示购物车中所有商品总价的功能： 向购物车中添加新商品时总价更新 定义一个Item类，用于表示商品信息： class Item { Item(this.price, this.count); double price; //商品单价 int count; // 商品份数 //... 省略其它属性 } 定义一个保存购物车内商品数据的CartModel类: class CartModel extends ChangeNotifier { // 用于保存购物车中商品列表 final List _items = []; // 禁止改变购物车里的商品信息 UnmodifiableListView get items => UnmodifiableListView(_items); // 购物车中商品的总价 double get totalPrice => _items.fold(0, (value, item) => value + item.count * item.price); // 将 [item] 添加到购物车。这是唯一一种能从外部改变购物车的方法。 void add(Item item) { _items.add(item); // 通知监听器（订阅者），重新构建InheritedProvider， 更新状态。 notifyListeners(); } } CartModel即要跨组件共享的model类。最后我们构建示例页面： class ProviderRoute extends StatefulWidget { @override _ProviderRouteState createState() => _ProviderRouteState(); } class _ProviderRouteState extends State { @override Widget build(BuildContext context) { return Center( child: ChangeNotifierProvider( data: CartModel(), child: Builder(builder: (context) { return Column( children: [ Builder(builder: (context){ var cart=ChangeNotifierProvider.of(context); return Text(\"总价: ${cart.totalPrice}\"); }), Builder(builder: (context){ print(\"RaisedButton build\"); //在后面优化部分会用到 return RaisedButton( child: Text(\"添加商品\"), onPressed: () { //给购物车中添加商品，添加后总价会更新 ChangeNotifierProvider.of(context).add(Item(20.0, 1)); }, ); }), ], ); }), ), ); } } 运行示例后效果如图7-2所示： 每次点击”添加商品“按钮，总价就会增加20，我们期望的功能实现了！可能有些读者会疑惑，我们饶了一大圈实现这么简单的功能有意义么？其实，就这个例子来看，只是更新同一个路由页中的一个状态，我们使用ChangeNotifierProvider的优势并不明显，但是如果我们是做一个购物APP呢？由于购物车数据是通常回事整个APP共享的数据，会跨路由共享，如果我们将ChangeNotifierProvider放在整个应用的Widget树的根上，那么整个APP就可以共享购物车的数据了，这时ChangeNotifierProvider的优势将会非常明显。 虽然上面的例子比较简单，但它却将Provider的原理和流程体现的很清楚，图7-3是Provider的原理图： Model变化后会自动通知ChangeNotifierProvider（订阅者），ChangeNotifierProvider内部会重新构建InheritedWidget，而依赖该InheritedWidget的子孙Widget就会更新。 我们可以发现使用Provider，将会带来如下收益： 我们的业务代码更关注数据了，只要更新Model，则UI会自动更新，而不用在状态改变后再去手动调用setState()来显式更新页面。 数据改变的消息传递被屏蔽了，我们无需手动去处理状态改变事件的发布和订阅了，这一切都被封装在Provider中了。这真的很棒，帮我们省掉了大量的工作！ 在大型复杂应用中，尤其是需要全局共享的状态非常多时，使用Provider将会大大简化我们的代码逻辑，降低出错的概率，提高开发效率。 优化 我们上面实现的ChangeNotifierProvider是有两个明显缺点：代码组织为题和性能问题，下面我们一一讨论。 代码组织问题 我们先看一下构建显示总价Text的代码： Builder(builder: (context){ var cart=ChangeNotifierProvider.of(context); return Text(\"总价: ${cart.totalPrice}\"); }) 这段代码有两点可以优化： 需要显式调用ChangeNotifierProvider.of，当APP内部依赖CartModel很多时，这样的代码将很冗余。 语义化不明确；由于ChangeNotifierProvider是订阅者，那么依赖CartModel的Widget自然就是订阅者，其实也就是状态的消费者，如果我们用Builder Widget来构建，语义话就不是很明确；如果我们能使用一个具有明确语义的Widget，比如就叫Consumer，这样最终的代码语义将会很明确，只要看到Consumer，我们就知道它是依赖某个跨组件或全局的状态。 为了优化这两个问题，我们可以封装一个Consumer Widget，实现如下： // 这是一个便捷类，会获得当前context和指定数据类型的Provider class Consumer extends StatelessWidget { Consumer({ Key key, @required this.builder, this.child, }) : assert(builder != null), super(key: key); final Widget child; final Widget Function(BuildContext context, T value) builder; @override Widget build(BuildContext context) { return builder( context, ChangeNotifierProvider.of(context), //自动获取Model ); } } Consumer实现非常简单，它通过指定模板参数，然后再内部自动调用ChangeNotifierProvider.of获取相应的Model，并且Consumer这个名字本身也是具有确切语义（消费者）。现在上面的代码块可以优化为如下这样： Consumer( builder: (context, cart)=> Text(\"总价: ${cart.totalPrice}\"); ) 是不是很优雅！ 性能问题 上面的代码还有一个性能问题，就在构建”添加按钮“的代码处： Builder(builder: (context) { print(\"RaisedButton build\"); // 构建时输出日志 return RaisedButton( child: Text(\"添加商品\"), onPressed: () { ChangeNotifierProvider.of(context).add(Item(20.0, 1)); }, ); } 我们点击”添加商品“按钮后，由于购物车商品总价会变化，所以显示总价的Text更新是符合预期的，但是”添加商品“按钮本身没有变化，是不应该被重新build的。但是我们运行示例，每次点击”添加商品“按钮，控制台都会输出\"RaisedButton build\"日志，也就是说”添加商品“按钮在每次点击时其自身都会重新build！这是为什么呢？如果你已经理解了InheritedWidget的更新机制，那么答案一眼就能看出：这是因为构建RaisedButton的Builder中调用了ChangeNotifierProvider.of，也就是说依赖了Widget树上面的InheritedWidget（即InheritedProvider ）Widget，所以当添加完商品后，CartModel发生变化，会通知ChangeNotifierProvider, 而ChangeNotifierProvider则会重新构建子树，所以InheritedProvider将会更新，此时依赖它的子孙Widget就会被重新构建。 问题的原因搞清楚了，那么我们如何避免这不必要重构呢？既然按钮重新被build是因为按钮和InheritedWidget建立了依赖关系，那么我们只要打破或解除这种依赖关系就可以了。那么如何解除按钮和InheritedWidget的依赖关系呢？我们上一节介绍InheritedWidget时已经讲过了：调用inheritFromWidgetOfExactType() 和 ancestorInheritedElementForWidgetOfExactType()的却别就是前者会注册依赖关系，而后者不会。所以我们只需要将ChangeNotifierProvider.of的实现改为下面这样既可： //添加一个listen参数，表示是否建立依赖关系 static T of(BuildContext context, {bool listen = true}) { final type = _typeOf>(); final provider = listen ? context.inheritFromWidgetOfExactType(type) as InheritedProvider : context.ancestorInheritedElementForWidgetOfExactType(type)?.widget as InheritedProvider; return provider.data; } 然后我们将调用部分代码改为： Column( children: [ Consumer( builder: (BuildContext context, cart) =>Text(\"总价: ${cart.totalPrice}\"), ), Builder(builder: (context) { print(\"RaisedButton build\"); return RaisedButton( child: Text(\"添加商品\"), onPressed: () { // listen 设为false，不建立依赖关系 ChangeNotifierProvider.of(context, listen: false) .add(Item(20.0, 1)); }, ); }) ], ) 修改后在此运行上面的示例，我们会发现点击”添加商品“按钮后，控制台不会再输出\"RaisedButton build\"了，即按钮不会被重新构建了。而总价仍然会更新，这是因为Consumer中调用ChangeNotifierProvider.of时listen值为默认值true，所以还是会建立依赖关系。 至此我们便实现了一个迷你的Provider，它具备Pub上Provider Package中的核心功能；但是我们的迷你版功能并不全面，如只实现了一个可监听的ChangeNotifierProvider，并没有实现只用于数据共享的Provider；还有就是我们的实现还有些边界没有考虑的到，比如如何保证在Widget树重新build时Model始终是单例等。所以建议读者在实战中还是使用Provider Package，而本节实现这个迷你Provider的主要目的主要是为了帮助读者了解Provider Package底层的原理。 其它状态管理包 现在Flutter社区已经有很多专门用于状态管理的包了，在此我们列出几个相对评分比较高的： 包名 介绍 Provider & Scoped Model 这两个包都是基于InheritedWidget的，原理相似 Redux 是Web开发中React生态链中Redux包的Flutter实现 MobX 是Web开发中React生态链中MobX包的Flutter实现 BLoC 是BLoC模式的Flutter实现 在此笔者不对这些包做推荐，读者有兴趣都可以研究一下，了解它们各自的思想。 总结 本节通过介绍事件总线在跨组件共享中的一些缺点引出了通过InheritedWidget来实现状态的共享的思想，然后基于该思想实现了一个简单的Provider，在实现的过程中也更深入的探索了InheritedWidget与其依赖项的注册机制和更新机制。通过本节的学习，读者应该达到两个目标，首先是对InheritedWidget彻底吃透，其次是Provider的设计思想。 InheritedWidget是Flutter中非常重要的一个Widget，像国际化、主题等都是通过它来实现，所以我们也不惜篇幅，通过好几节来介绍它的，在下一节中，我们将介绍另一个基于InheritedWidget的组件Theme(主题)。 "},"chapter7/theme.html":{"url":"chapter7/theme.html","title":"7.4：颜色和主题（Theme）","keywords":"","body":"7.4 颜色和主题 7.4.1 颜色 在介绍主题前我们先了解一些Flutter中的Color类。Color类中颜色以一个int值保存，我们知道显示器颜色是由红、绿、蓝三基色组成，每种颜色站8比特，存储结构如下： Bit（位） 颜色 0-7 蓝色 8-15 绿色 16-23 红色 24-31 Alpha (不透明度) 上面表格中的的字段在Color类中都有对应的属性，而Color中的众多方法也就是操作这些属性的，由于大多比较简单，读者可以查看类定义了解。在此我们主要讨论两点：色值转换和亮度。 如何将颜色字符串转成Color对象 如Web开发中的色值通常是一个字符串如\"#dc380d\"，它是一个RGB值，我们可以通过下面这些方法将其转为Color类： Color(0xffdc380d); //如果颜色固定可以直接使用整数值 //颜色是一个字符串变量 var c = \"dc380d\"; Color(int.parse(c,radix:16)|0xFF000000) //通过位运算符将Alpha设置为FF Color(int.parse(c,radix:16)).withAlpha(255) //通过方法将Alpha设置为FF 颜色亮度 假如我们需要要实现一个背景颜色和Title可以自定义导航栏，并且背景色为深色时我们应该让Title显示浅色；背景色为浅色时，Title显示深色。要实现这个功能，我们就需要来计算背景色的亮度。Color类中提供了一个computeLuminance()方法，他可以返回一个[0-1]的一个值，数字越大颜色就越浅，我们可以根据它来动态确定Title的颜色，下面是导航栏NavBar的简单实现： class NavBar extends StatelessWidget { final String title; final Color color; //背景颜色 NavBar({ Key key, this.color, this.title, }); @override Widget build(BuildContext context) { return Container( constraints: BoxConstraints( minHeight: 52, minWidth: double.infinity, ), decoration: BoxDecoration( color: color, boxShadow: [ //阴影 BoxShadow( color: Colors.black26, offset: Offset(0, 3), blurRadius: 3, ), ], ), child: Text( title, style: TextStyle( fontWeight: FontWeight.bold, //根据背景色亮度来确定Title颜色 color: color.computeLuminance() 测试代码如下： Column( children: [ //背景为蓝色，则title自动为白色 NavBar(color: Colors.blue, title: \"标题\"), //背景为白色，则title自动为黑色 NavBar(color: Colors.white, title: \"标题\"), ] ) 运行效果如图7-4所示： MaterialColor MaterialColor是实现Material Design中的颜色的类，它包含一种颜色的10个级别的渐变色。MaterialColor通过\"[]\"运算符的索引值来代表颜色的深度，有效的索引有：50，100，200，…，900，数字越大，颜色越深。MaterialColor的默认值为索引等于500的颜色。举个例子，Colors.blue是预定义的一个MaterialColor类对象，定义如下： static const MaterialColor blue = MaterialColor( _bluePrimaryValue, { 50: Color(0xFFE3F2FD), 100: Color(0xFFBBDEFB), 200: Color(0xFF90CAF9), 300: Color(0xFF64B5F6), 400: Color(0xFF42A5F5), 500: Color(_bluePrimaryValue), 600: Color(0xFF1E88E5), 700: Color(0xFF1976D2), 800: Color(0xFF1565C0), 900: Color(0xFF0D47A1), }, ); static const int _bluePrimaryValue = 0xFF2196F3; Colors.blue[50]到Colors.blue[100]的色值从浅蓝到深蓝渐变，效果如图7-5所示： 7.4.2 Theme Theme组件可以为Material APP定义主题数据（ThemeData）。Material组件库里很多组件都使用了主题数据，如导航栏颜色、标题字体、Icon样式等。Theme内会使用InheritedWidget来为其子树共享样式数据。 ThemeData ThemeData用于保存是Material 组件库的主题数据，Material组件需要遵守相应的设计规范，而这些规范可自定义部分都定义在ThemeData中了，所以我们可以通过ThemeData来自定义应用主题。在子组件中，我们可以通过Theme.of方法来获取当前的ThemeData。 注意：Material Design 设计规范中有些是不能自定义的，如导航栏高度，ThemeData只包含了可自定义部分。 我们看看ThemeData部分数据定义： ThemeData({ Brightness brightness, //深色还是浅色 MaterialColor primarySwatch, //主题颜色样本，见下面介绍 Color primaryColor, //主色，决定导航栏颜色 Color accentColor, //次级色，决定大多数Widget的颜色，如进度条、开关等。 Color cardColor, //卡片颜色 Color dividerColor, //分割线颜色 ButtonThemeData buttonTheme, //按钮主题 Color cursorColor, //输入框光标颜色 Color dialogBackgroundColor,//对话框背景颜色 String fontFamily, //文字字体 TextTheme textTheme,// 字体主题，包括标题、body等文字样式 IconThemeData iconTheme, // Icon的默认样式 TargetPlatform platform, //指定平台，应用特定平台控件风格 ... }) 上面只是ThemeData的一小部分属性，完整的数据定义读者可以查看SDK。上面属性中需要说明的是primarySwatch，它是主题颜色的一个\"样本色\"，通过这个样本色可以在一些条件下生成一些其它的属性，例如，如果没有指定primaryColor，并且当前主题不是深色主题，那么primaryColor就会默认为primarySwatch指定的颜色，还有一些相似的属性如accentColor 、indicatorColor等也会受primarySwatch影响。 示例 我们实现一个路由换肤功能： class ThemeTestRoute extends StatefulWidget { @override _ThemeTestRouteState createState() => new _ThemeTestRouteState(); } class _ThemeTestRouteState extends State { Color _themeColor = Colors.teal; //当前路由主题色 @override Widget build(BuildContext context) { ThemeData themeData = Theme.of(context); return Theme( data: ThemeData( primarySwatch: _themeColor, //用于导航栏、FloatingActionButton的背景色等 iconTheme: IconThemeData(color: _themeColor) //用于Icon颜色 ), child: Scaffold( appBar: AppBar(title: Text(\"主题测试\")), body: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ //第一行Icon使用主题中的iconTheme Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(Icons.favorite), Icon(Icons.airport_shuttle), Text(\" 颜色跟随主题\") ] ), //为第二行Icon自定义颜色（固定为黑色) Theme( data: themeData.copyWith( iconTheme: themeData.iconTheme.copyWith( color: Colors.black ), ), child: Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(Icons.favorite), Icon(Icons.airport_shuttle), Text(\" 颜色固定黑色\") ] ), ), ], ), floatingActionButton: FloatingActionButton( onPressed: () => //切换主题 setState(() => _themeColor = _themeColor == Colors.teal ? Colors.blue : Colors.teal ), child: Icon(Icons.palette) ), ), ); } } 运行后点击右下角悬浮按钮则可以切换主题，如图7-6、7-7所示： 需要注意的有三点： 可以通过局部主题覆盖全局主题，正如代码中通过Theme为第二行图标指定固定颜色（黑色）一样，这是一种常用的技巧，Flutter中会经常使用这种方法来自定义子树主题。那么为什么局部主题可以覆盖全局主题？这主要是因为Widget中使用主题样式时是通过Theme.of(BuildContext context)来获取的，我们看看其简化后的代码： static ThemeData of(BuildContext context, { bool shadowThemeOnly = false }) { // 简化代码，并非源码 return context.inheritFromWidgetOfExactType(_InheritedTheme) } context.inheritFromWidgetOfExactType 会在widget树中从当前位置向上查找第一个类型为_InheritedTheme的Widget。所以当局部使用Theme后，其子树中Theme.of()找到的第一个_InheritedTheme便是该Theme的。 本示例是对单个路由换肤，如果相对整个应用换肤，可以去修改MaterialApp的theme属性。 "},"chapter7/futurebuilder_and_streambuilder.html":{"url":"chapter7/futurebuilder_and_streambuilder.html","title":"7.5：异步UI更新（FutureBuilder、StreamBuilder）","keywords":"","body":"7.5 异步UI更新（FutureBuilder、StreamBuilder） 很多时候我们会依赖一些异步数据来动态更新UI，比如在打开一个页面时我们需要先从互联网上获取数据，在获取数据的过程中我们显式一个加载框，等获取到数据时我们再渲染页面；又比如我们想展示Stream（比如文件流、互联网数据接收流）的进度。当然，通过StatefulWidget我们完全可以实现上述这些功能。但由于在实际开发中依赖异步数据更新UI的这种场景非常常见，因此Flutter专门提供了FutureBuilder和StreamBuilder两个组件来快速实现这种功能。 7.5.1 FutureBuilder FutureBuilder会依赖一个Future，它会根据所依赖的Future的状态来动态构建自身。我们看一下FutureBuilder构造函数： FutureBuilder({ this.future, this.initialData, @required this.builder, }) future：FutureBuilder依赖的Future，通常是一个异步耗时任务。 initialData：初始数据，用户设置默认数据。 builder：Widget构建器；该构建器会在Future执行的不同阶段被多次调用，构建器签名如下： Function (BuildContext context, AsyncSnapshot snapshot) snapshot会包含当前异步任务的状态信息及结果信息 ，比如我们可以通过snapshot.connectionState获取异步任务的状态信息、通过snapshot.hasError判断异步任务是否有错误等等，完整的定义读者可以查看AsyncSnapshot类定义。 另外，FutureBuilder的builder函数签名和StreamBuilder的builder是相同的。 示例 我们实现一个路由，当该路由打开时我们从网上获取数据，获取数据时弹一个加载框；获取结束时，如果成功则显示获取到的数据，如果失败则显示错误。由于我们还没有介绍在flutter中如何发起网络请求，所以在这里我们不真正去网络请求数据，而是模拟一下这个过程，隔3秒后返回一个字符串： Future mockNetworkData() async { return Future.delayed(Duration(seconds: 2), () => \"我是从互联网上获取的数据\"); } FutureBuilder使用代码如下： ... Widget build(BuildContext context) { return Center( child: FutureBuilder( future: mockNetworkData(), builder: (BuildContext context, AsyncSnapshot snapshot) { // 请求已结束 if (snapshot.connectionState == ConnectionState.done) { if (snapshot.hasError) { // 请求失败，显示错误 return Text(\"Error: ${snapshot.error}\"); } else { // 请求成功，显示数据 return Text(\"Contents: ${snapshot.data}\"); } } else { // 请求未结束，显示loading return CircularProgressIndicator(); } }, ), ); } 运行结果如图7-8、7-9所示： 上面代码中我们在builder中根据当前异步任务状态ConnectionState来返回不同的widget。ConnectionState是一个枚举类，定义如下： enum ConnectionState { /// 当前没有异步任务，比如[FutureBuilder]的[future]为null时 none, /// 异步任务处于等待状态 waiting, /// Stream处于激活状态（流上已经有数据传递了），对于FutureBuilder没有该状态。 active, /// 异步任务已经终止. done, } 注意，ConnectionState.active只在StreamBuilder中才会出现。 7.5.2 StreamBuilder 我们知道，在Dart中Stream 也是用于接收异步事件数据，和Future 不同的是，它可以接收多个异步操作的结果，它常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。StreamBuilder正是用于配合Stream来展示流上事件（数据）变化的UI组件。下面看一下StreamBuilder的默认构造函数： StreamBuilder({ Key key, this.initialData, Stream stream, @required this.builder, }) 可以看到和FutureBuilder的构造函数只有一点不同：前者需要一个future，而后者需要一个stream。 示例 我们创建一个计时器的示例：每隔1秒，计数加1。这里，我们使用Stream来实现每隔一秒生成一个数字: Stream counter() { return Stream.periodic(Duration(seconds: 1), (i) { return i; }); } StreamBuilder使用代码如下： Widget build(BuildContext context) { return StreamBuilder( stream: counter(), // //initialData: ,// a Stream or null builder: (BuildContext context, AsyncSnapshot snapshot) { if (snapshot.hasError) return Text('Error: ${snapshot.error}'); switch (snapshot.connectionState) { case ConnectionState.none: return Text('没有Stream'); case ConnectionState.waiting: return Text('等待数据...'); case ConnectionState.active: return Text('active: ${snapshot.data}'); case ConnectionState.done: return Text('Stream已关闭'); } return null; // unreachable }, ); } 读者可以自己运行本示例查看运行结果。注意，本示例只是为了演示StreamBuilder的使用，在实战中，凡是UI会依赖多个异步数据而发生变化的场景都可以使用StreamBuilder。 "},"chapter7/dailog.html":{"url":"chapter7/dailog.html","title":"7.6：对话框详解","keywords":"","body":"7.6 对话框详解 本节将详细介绍一下Flutter中话框对话框的使用方式、实现原理、样式定制及状态管理。 7.6.1 使用对话框 对话框本质上也是UI布局，通常一个对话框会包含标题、内容，以及一些操作按钮，为此，Material库中提提供了一些现成的对话框组件来用于快速的构建出一个完整的对话框。 AlertDialog 下面我们主要介绍一下Material库中的AlertDialog组件，它的构造函数定义如下： const AlertDialog({ Key key, this.title, //对话框标题组件 this.titlePadding, // 标题填充 this.titleTextStyle, //标题文本样式 this.content, // 对话框内容组件 this.contentPadding = const EdgeInsets.fromLTRB(24.0, 20.0, 24.0, 24.0), //内容的填充 this.contentTextStyle,// 内容文本样式 this.actions, // 对话框操作按钮组 this.backgroundColor, // 对话框背景色 this.elevation,// 对话框的阴影 this.semanticLabel, //对话框语义化标签(用于读屏软件) this.shape, // 对话框外形 }) 参数都比较简单，不在赘述。下面我们看一个例子，假如我们要在删除文件事弹出一个确认对话框，该对话框如图7-10所示： 该对话框样式代码如下： AlertDialog( title: Text(\"提示\"), content: Text(\"您确定要删除当前文件吗?\"), actions: [ FlatButton( child: Text(\"取消\"), onPressed: () => Navigator.of(context).pop(), //关闭对话框 ), FlatButton( child: Text(\"删除\"), onPressed: () { // ... 执行删除操作 Navigator.of(context).pop(true); //关闭对话框 }, ), ], ); 实现代码很简单，不在赘述。唯一需要注意的是我们是通过Navigator.of(context).pop(…)方法来关闭对话框的，这和路由返回的方式是一致的，并且都可以返回一个结果数据。现在，对话框我们已经构建好了，那么如何将它弹出来呢？还有对话框返回的数据如何应如何被接收呢？这些问题的答案都在showDialog()方法中。 showDialog()是Material组件库提供的一个用于弹出Material风格对话框的方法，签名如下： Future showDialog({ @required BuildContext context, bool barrierDismissible = true, //点击对话框barrier(遮罩)时是否关闭它 WidgetBuilder builder, // 对话框UI的builder }) 该方法只有两个参数，含义见注释。该方法返回一个Future，它正是用于接收对话框的返回值：如果我们是通过点击对话框遮罩关闭的，则Future的值为null，否则为我们通过Navigator.of(context).pop(result)返回的result值，下面我们看一下整个示例： //点击该按钮后弹出对话框 RaisedButton( child: Text(\"对话框1\"), onPressed: () async { //弹出对话框并等待其关闭 bool delete = await showDeleteConfirmDialog1(); if (delete == null) { print(\"取消删除\"); } else { print(\"已确认删除\"); //... 删除文件 } }, ), // 弹出对话框 Future showDeleteConfirmDialog1() { return showDialog( context: context, builder: (context) { return AlertDialog( title: Text(\"提示\"), content: Text(\"您确定要删除当前文件吗?\"), actions: [ FlatButton( child: Text(\"取消\"), onPressed: () => Navigator.of(context).pop(), // 关闭对话框 ), FlatButton( child: Text(\"删除\"), onPressed: () { //关闭对话框并返回true Navigator.of(context).pop(true); }, ), ], ); }, ); } 示例运行后，我们点击对话框“取消”按钮或遮罩，控制台就会输出\"取消删除\"，如果点击“删除”按钮，控制台就会输出\"已确认删除\"。 注意：如果AlertDialog的内容过长，内容将会溢出，这在很多时候可能不是我们期望的，所以如果对话框内容过长时，可以用SingleChildScrollView将内容包裹起来。 SimpleDialog SimpleDialog也是Material组件库提供的对话框，它会展示一个列表，用于列表选择的场景。下面是一个选择APP语言的示例，运行结果如图7-11。 实现代码如下： Future changeLanguage() async { int i = await showDialog( context: context, builder: (BuildContext context) { return SimpleDialog( title: const Text('请选择语言'), children: [ SimpleDialogOption( onPressed: () { // 返回1 Navigator.pop(context, 1); }, child: Padding( padding: const EdgeInsets.symmetric(vertical: 6), child: const Text('中文简体'), ), ), SimpleDialogOption( onPressed: () { // 返回2 Navigator.pop(context, 2); }, child: Padding( padding: const EdgeInsets.symmetric(vertical: 6), child: const Text('美国英语'), ), ), ], ); }); if (i != null) { print(\"选择了：${i == 1 ? \"中文简体\" : \"美国英语\"}\"); } } 列表项组件我们使用了SimpleDialogOption组件来包装了一下，它相当于一个FlatButton，只不过按钮文案是左对齐的，并且padding较小。上面示例运行后，用户选择一种语言后，控制台就会打印出它。 Dialog 实际上AlertDialog和SimpleDialog都使用了Dialog类。由于AlertDialog和SimpleDialog中使用了IntrinsicWidth来尝试通过子组件的实际尺寸来调整自身尺寸，这就导致他们的子组件不能是延迟加载模型的组件（如ListView、GridView 、 CustomScrollView等），如下面的代码运行后会报错。 AlertDialog( content: ListView( children: ...//省略 ), ); 如果我们就是需要嵌套一个ListView应该怎么做？这时，我们可以直接使用Dialog类，如： Dialog( child: ListView( children: ...//省略 ), ); 下面我们看一个弹出一个有30个列表项的对话框示例，运行效果如图7-12所示： 实现代码如下： Future showListDialog() async { int index = await showDialog( context: context, builder: (BuildContext context) { var child = Column( children: [ ListTile(title: Text(\"请选择\")), Expanded( child: ListView.builder( itemCount: 30, itemBuilder: (BuildContext context, int index) { return ListTile( title: Text(\"$index\"), onTap: () => Navigator.of(context).pop(index), ); }, )), ], ); //使用AlertDialog会报错 //return AlertDialog(content: child); return Dialog(child: child); }, ); if (index != null) { print(\"点击了：$index\"); } } 现在，我们己经介绍完了AlertDialog、SimpleDialog以及Dialog。上面的示例中，我们在调用showDialog时，在builder中都是构建了这三个对话框组件的一种，可能有些读者会惯性的以为在builder中只能返回这三者之一，其实这不是必须的！就拿Dialog的示例来距离，我们完全可以用下面的代码来替代Dialog： // return Dialog(child: child) return UnconstrainedBox( constrainedAxis: Axis.vertical, child: ConstrainedBox( constraints: BoxConstraints(maxWidth: 280), child: Material( child: child, type: MaterialType.card, ), ), ); 上面代码运行后可以实现一样的效果。现在我们总结一下：AlertDialog、SimpleDialog以及Dialog是Material组件库提供的三种对话框，旨在帮助开发者快速构建出符合Material设计规范的对话框，但读者完全可以自定义对话框样式，因此，我们仍然可以实现各种样式的对话框，这样即带来了易用性，又有很强的扩展性。 7.6.2 对话框打开动画及遮罩 我们可以把对话框分为内部样式和外部样式两部分。内部样式指对话框中显示的具体内容，这部分内容我们已经在上面介绍过了；外部样式包含对话框遮罩样式、打开动画等，本节主要介绍如何自定义这些外部样式。 关于动画相关内容我们将在本书后面章节介绍，下面内容读者可以先了解一下（不必深究），读者可以在学习完动画相关内容后再回头来看。 我们已经介绍过了showDialog方法，它是Material组件库中提供的一个打开Material风格对话框的方法。那如何打开一个普通风格的对话框呢（非Material风格）？ Flutter 提供了一个showGeneralDialog方法，签名如下： Future showGeneralDialog({ @required BuildContext context, @required RoutePageBuilder pageBuilder, //构建对话框内部UI bool barrierDismissible, //点击遮罩是否关闭对话框 String barrierLabel, // 语义化标签(用于读屏软件) Color barrierColor, // 遮罩颜色 Duration transitionDuration, // 对话框打开/关闭的动画时长 RouteTransitionsBuilder transitionBuilder, // 对话框打开/关闭的动画 }) 实际上，showDialog方法正是showGeneralDialog的一个封装，定制了Material风格对话框的遮罩颜色和动画。Material风格对话框打开/关闭动画是一个Fade（渐隐渐显）动画，如果我们想使用一个缩放动画就可以通过transitionBuilder来自定义。下面我们自己封装一个showCustomDialog方法，它定制的对话框动画为缩放动画，并同时制定遮罩颜色为Colors.black87： Future showCustomDialog({ @required BuildContext context, bool barrierDismissible = true, WidgetBuilder builder, }) { final ThemeData theme = Theme.of(context, shadowThemeOnly: true); return showGeneralDialog( context: context, pageBuilder: (BuildContext buildContext, Animation animation, Animation secondaryAnimation) { final Widget pageChild = Builder(builder: builder); return SafeArea( child: Builder(builder: (BuildContext context) { return theme != null ? Theme(data: theme, child: pageChild) : pageChild; }), ); }, barrierDismissible: barrierDismissible, barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel, barrierColor: Colors.black87, // 自定义遮罩颜色 transitionDuration: const Duration(milliseconds: 150), transitionBuilder: _buildMaterialDialogTransitions, ); } Widget _buildMaterialDialogTransitions( BuildContext context, Animation animation, Animation secondaryAnimation, Widget child) { // 使用缩放动画 return ScaleTransition( scale: CurvedAnimation( parent: animation, curve: Curves.easeOut, ), child: child, ); } 现在，我们使用showCustomDialog打开文件删除确认对话框，代码如下： ... //省略无关代码 showCustomDialog( context: context, builder: (context) { return AlertDialog( title: Text(\"提示\"), content: Text(\"您确定要删除当前文件吗?\"), actions: [ FlatButton( child: Text(\"取消\"), onPressed: () => Navigator.of(context).pop(), ), FlatButton( child: Text(\"删除\"), onPressed: () { // 执行删除操作 Navigator.of(context).pop(true); }, ), ], ); }, ); 运行效果如图7-13所示： 可以发现，遮罩颜色比通过showDialog方法打开的对话框更深。另外对话框打开/关闭的动画已变为缩放动画了，读者可以亲自运行示例查看效果。 7.6.3 对话框实现原理 我们已经知道对话框最终都是由showGeneralDialog方法打开的，我们来看看它的具体实现： Future showGeneralDialog({ @required BuildContext context, @required RoutePageBuilder pageBuilder, bool barrierDismissible, String barrierLabel, Color barrierColor, Duration transitionDuration, RouteTransitionsBuilder transitionBuilder, }) { return Navigator.of(context, rootNavigator: true).push(_DialogRoute( pageBuilder: pageBuilder, barrierDismissible: barrierDismissible, barrierLabel: barrierLabel, barrierColor: barrierColor, transitionDuration: transitionDuration, transitionBuilder: transitionBuilder, )); } 实现很简单，直接调用Navigator的push方法打开了一个新的对话框路由_DialogRoute，然后返回了push的返回值。可以对话框实际上正是通过路由的形式实现的，这也是为什么我们可以使用Navigator的pop 方法来退出对话框的原因。关于对话框的样式定制在_DialogRoute中，没有什么新的东西，读者可以自行查看。 7.6.4 对话框状态管理 我们在用户选择删除一个文件时，会询问是否产出此文件；在用户选择一个文件夹是，应该再让用户确认是否删除子文件夹。为了在用户选择了文件夹时避免二次弹窗确认是否删除子目录，我们在确认对话框底部添加一个“同时删除子目录？”的复选框，如图7-14所示： 现在就有一个问题：如何管理复选框的选中状态？习惯上，我们会在路由页的State中来管理选中状态，我们可能会写出如下这样的代码： class _DialogRouteState extends State { bool withTree = false; // 复选框选中状态 @override Widget build(BuildContext context) { return Column( children: [ RaisedButton( child: Text(\"对话框2\"), onPressed: () async { bool delete = await showDeleteConfirmDialog2(); if (delete == null) { print(\"取消删除\"); } else { print(\"同时删除子目录: $delete\"); } }, ), ], ); } Future showDeleteConfirmDialog2() { withTree = false; // 默认复选框不选中 return showDialog( context: context, builder: (context) { return AlertDialog( title: Text(\"提示\"), content: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisSize: MainAxisSize.min, children: [ Text(\"您确定要删除当前文件吗?\"), Row( children: [ Text(\"同时删除子目录？\"), Checkbox( value: withTree, onChanged: (bool value) { //复选框选中状态发生变化时重新构建UI setState(() { //更新复选框状态 withTree = !withTree; }); }, ), ], ), ], ), actions: [ FlatButton( child: Text(\"取消\"), onPressed: () => Navigator.of(context).pop(), ), FlatButton( child: Text(\"删除\"), onPressed: () { //执行删除操作 Navigator.of(context).pop(withTree); }, ), ], ); }, ); } } 然后，当我们运行上面的代码时我们会发现复选框根本选不中！为什么会这样呢？其实原因很简单，我们知道setState方法只会针对当前context的子树重新build，但是我们的对话框并不是在_DialogRouteState的build 方法中构建的，而是通过showDialog单独构建的，所以调用在_DialogRouteState的context中调用setState是无法影响通过showDialog构建的UI的。另外，我们可以从另外一个角度来理解这个现象，前面说过动画框也是通过路由的方式来实现的，那么上面的代码实际上就等同于企图在父路由中调用setState来让子路由更新，这显然是不行的！简尔言之，根本原因就是context不对。那如何让复选框可点击呢？通常有如下三种方法： 单独抽离出StatefulWidget 既然是context不对，那么直接的思路就是将复选框的选中逻辑单独封装成一个StatefulWidget，然后其再内部管理复选状态。我们先来看看这种方法，下面是实现代码： // 单独封装一个内部管理选中状态的复选框组件 class DialogCheckbox extends StatefulWidget { DialogCheckbox({ Key key, this.value, @required this.onChanged, }); final ValueChanged onChanged; final bool value; @override _DialogCheckboxState createState() => _DialogCheckboxState(); } class _DialogCheckboxState extends State { bool value; @override void initState() { value = widget.value; super.initState(); } @override Widget build(BuildContext context) { return Checkbox( value: value, onChanged: (v) { //将选中状态通过事件的形式抛出 widget.onChanged(v); setState(() { //更新自身选中状态 value = v; }); }, ); } } 下面是弹出对话框的代码： Future showDeleteConfirmDialog3() { bool _withTree = false; //记录复选框是否选中 return showDialog( context: context, builder: (context) { return AlertDialog( title: Text(\"提示\"), content: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisSize: MainAxisSize.min, children: [ Text(\"您确定要删除当前文件吗?\"), Row( children: [ Text(\"同时删除子目录？\"), DialogCheckbox( value: _withTree, //默认不选中 onChanged: (bool value) { //更新选中状态 _withTree = !_withTree; }, ), ], ), ], ), actions: [ FlatButton( child: Text(\"取消\"), onPressed: () => Navigator.of(context).pop(), ), FlatButton( child: Text(\"删除\"), onPressed: () { // 将选中状态返回 Navigator.of(context).pop(_withTree); }, ), ], ); }, ); } 最后，就是使用： RaisedButton( child: Text(\"话框3（复选框可点击）\"), onPressed: () async { //弹出删除确认对话框，等待用户确认 bool deleteTree = await showDeleteConfirmDialog3(); if (deleteTree == null) { print(\"取消删除\"); } else { print(\"同时删除子目录: $deleteTree\"); } }, ), 运行后效果如图7-15所示： 可见复选框能选中了，点击“取消”或“删除”后，控制台就会打印出最终的确认状态。 使用StatefulBuilder方法 上面的方法虽然能解决对话框状态更新的问题，但是有一个明显的缺点——对话框上所有需要会改变状态的组件都得单独封装在一个在内部管理状态StatefulWidget中，这样不仅麻烦，而且复用性不大。因此，我们来想想能不能找到一种更简单的方法？上面的方法本质上就是将对话框的状态置于一个StatefulWidget的上下文中，由StatefulWidget在内部管理，那么我们有没有办法在不需要单独抽离组件的情况下创建一个StatefulWidget的上下文呢？想到这里，我们可以从Builder组件的实现获得灵感。在前面介绍过Builder组件可以获得组件所在位置的真正的Context，那它是怎么实现的呢，我们看看它的源码： class Builder extends StatelessWidget { const Builder({ Key key, @required this.builder, }) : assert(builder != null), super(key: key); final WidgetBuilder builder; @override Widget build(BuildContext context) => builder(context); } 可以看到，Builder实际上只是继承了StatelessWidget，然后在build方法中对获取当前context后将构建方法代理到了builder回调，Builder实际上是获取了StatelessWidget 的上下文。那我们能否用相同的方法获取StatefulWidget 上下文，并代理其build方法呢？我们照猫画虎，来封装一个StatefulBuilder方法： class StatefulBuilder extends StatefulWidget { const StatefulBuilder({ Key key, @required this.builder, }) : assert(builder != null), super(key: key); final StatefulWidgetBuilder builder; @override _StatefulBuilderState createState() => _StatefulBuilderState(); } class _StatefulBuilderState extends State { @override Widget build(BuildContext context) => widget.builder(context, setState); } 代码很简单，StatefulBuilder获取了StatefulWidget的上下文，并代理了其构建过程。下面我们就可以通过StatefulBuilder来重构上面的代码了（变动只在DialogCheckbox部分）： ... //省略无关代码 Row( children: [ Text(\"同时删除子目录？\"), //使用StatefulBuilder来构建StatefulWidget上下文 StatefulBuilder( builder: (context, _setState) { return Checkbox( value: _withTree, //默认不选中 onChanged: (bool value) { //_setState方法实际就是该StatefulWidget的setState方法， //调用后builder方法会重新被调用 _setState(() { //更新选中状态 _withTree = !_withTree; }); }, ); }, ), ], ), 实际上，这种方法本质上就是子组件通知父组件（StatefulWidget）重新build子组件本身来实现UI更新的，读者可以对比代码理解。实际上StatefulBuilder正是Flutter SDK中提供的一个类，它和Builder的原理是一样的，在此，提醒读者一定要将StatefulBuilder和Builder理解透彻，因为它们在Flutter中是非常实用的。 精妙的解法 要确认这个问题，我们就得先想想UI是怎么更新的，我们知道在调用setState方法后StatefulWidget就会重新build，那setState方法做了什么呢？我们能不能从中找到方法？顺着这个思路，我们就得看一下setState的核心源码： void setState(VoidCallback fn) { ... //省略无关代码 _element.markNeedsBuild(); } 可以发现，setState中调用了Element的markNeedsBuild()方法，我们前面说过，Flutter是一个响应式框架，要更新UI只需改变状态后通知框架页面需要重构即可，而Element的markNeedsBuild()方法正是来实现这个功能的！markNeedsBuild()方法会将当前的Element对象标记为“dirty”（脏的），在每一个Frame，Flutter都会重新构建被标记为“dirty”Element对象。既然如此，我们有没有办法获取到对话框内部UI的Element对象，然后将其表姐为为“dirty”呢？答案是肯定的！我们可以通过Context来得到Element对象，至于Element与Context的关系我们将会在后面“Flutter核心原理”一章中再深入介绍，现在只需要简单的认为：在组件树种，context实际上就是Element对象的引用。知道这个后，那么解决的方案就呼之欲出了，我们可以通过如下方式来让复选框可以更新： Future showDeleteConfirmDialog4() { bool _withTree = false; return showDialog( context: context, builder: (context) { return AlertDialog( title: Text(\"提示\"), content: Column( crossAxisAlignment: CrossAxisAlignment.start, mainAxisSize: MainAxisSize.min, children: [ Text(\"您确定要删除当前文件吗?\"), Row( children: [ Text(\"同时删除子目录？\"), Checkbox( // 依然使用Checkbox组件 value: _withTree, onChanged: (bool value) { // 此时context为对话框UI的根Element，我们 // 直接将对话框UI对应的Element标记为dirty (context as Element).markNeedsBuild(); _withTree = !_withTree; }, ), ], ), ], ), actions: [ FlatButton( child: Text(\"取消\"), onPressed: () => Navigator.of(context).pop(), ), FlatButton( child: Text(\"删除\"), onPressed: () { // 执行删除操作 Navigator.of(context).pop(_withTree); }, ), ], ); }, ); } 上面的代码运行后复选框也可以正常选中。可以看到，我们只用了一行代码便解决了这个问题！当然上面的代码并不是最优，因为我们只需要更新复选框的状态，而此时的context我们用的是对话框的根context，所以会导致整个对话框UI组件全部rebuild，因此最好的作法是将context的“范围”缩小，也就是说只将Checkbox的Element标记为dirty，优化后的代码为： ... //省略无关代码 Row( children: [ Text(\"同时删除子目录？\"), // 通过Builder来获得构建Checkbox的`context`， // 这是一种常用的缩小`context`范围的方式 Builder( builder: (BuildContext context) { return Checkbox( value: _withTree, onChanged: (bool value) { (context as Element).markNeedsBuild(); _withTree = !_withTree; }, ); }, ), ], ), 7.6.5 其它类型的对话框 底部菜单列表 showModalBottomSheet方法可以弹出一个Material风格的底部菜单列表模态对话框，示例如下： // 弹出底部菜单列表模态对话框 Future _showModalBottomSheet() { return showModalBottomSheet( context: context, builder: (BuildContext context) { return ListView.builder( itemCount: 30, itemBuilder: (BuildContext context, int index) { return ListTile( title: Text(\"$index\"), onTap: () => Navigator.of(context).pop(index), ); }, ); }, ); } 点击按钮，弹出该对话框： RaisedButton( child: Text(\"显示底部菜单列表\"), onPressed: () async { int type = await _showModalBottomSheet(); print(type); }, ), 运行后效果如图7-16所示： showModalBottomSheet的实现原理和showGeneralDialog实现原理相同，都是通过路由的方式来实现的，读者可以查看源码对比。但值得一提的是还有一个showBottomSheet方法，该方法会从设备底部向上弹出一个全屏的菜单列表，示例如下： // 返回的是一个controller PersistentBottomSheetController _showBottomSheet() { return showBottomSheet( context: context, builder: (BuildContext context) { return ListView.builder( itemCount: 30, itemBuilder: (BuildContext context, int index) { return ListTile( title: Text(\"$index\"), onTap: (){ // do something print(\"$index\"); Navigator.of(context).pop(); }, ); }, ); }, ); } 运行效果如图7-17所示： PersistentBottomSheetController中包含了一下控制对话框的方法比如close方法可以关闭该对话框，功能比较简单，读者可以自行查看源码。唯一需要注意的是，showBottomSheet和我们上面介绍的弹出对话框的方法原理不同：showBottomSheet是调用widget树顶部的Scaffold组件的ScaffoldState的showBottomSheet同名方法实现，也就是说要调用showBottomSheet方法就必须得保证父级组件中有Scaffold。 Loading框 其实Loading框可以直接通过showDialog+AlertDialog来自定义： showLoadingDialog() { showDialog( context: context, barrierDismissible: false, //点击遮罩不关闭对话框 builder: (context) { return AlertDialog( content: Column( mainAxisSize: MainAxisSize.min, children: [ CircularProgressIndicator(), Padding( padding: const EdgeInsets.only(top: 26.0), child: Text(\"正在加载，请稍后...\"), ) ], ), ); }, ); } 显示效果如图7-18所示： 如果我们嫌Loading框太宽，想自定义对话框宽度，这时只使用SizedBox或ConstrainedBox是不行的，原因是showDialog中已经给对话框设置了宽度限制，根据我们在第五章“尺寸限制类容器”一节中所述，我们可以使用UnconstrainedBox先抵消showDialog对宽度的限制，然后再使用SizedBox指定宽度，代码如下： ... //省略无关代码 UnconstrainedBox( constrainedAxis: Axis.vertical, child: SizedBox( width: 280, child: AlertDialog( content: Column( mainAxisSize: MainAxisSize.min, children: [ CircularProgressIndicator(value: .8,), Padding( padding: const EdgeInsets.only(top: 26.0), child: Text(\"正在加载，请稍后...\"), ) ], ), ), ), ); 代码运行后，效果如图7-19所示： 日历选择 我们先看一下Material风格的日历选择器，如图7-20所示： 实现代码： Future _showDatePicker1() { var date = DateTime.now(); return showDatePicker( context: context, initialDate: date, firstDate: date, lastDate: date.add( //未来30天可选 Duration(days: 30), ), ); } iOS风格的日历选择器需要使用showCupertinoModalPopup方法和CupertinoDatePicker组件来实现： Future _showDatePicker2() { var date = DateTime.now(); return showCupertinoModalPopup( context: context, builder: (ctx) { return SizedBox( height: 200, child: CupertinoDatePicker( mode: CupertinoDatePickerMode.dateAndTime, minimumDate: date, maximumDate: date.add( Duration(days: 30), ), maximumYear: date.year + 1, onDateTimeChanged: (DateTime value) { print(value); }, ), ); }, ); } 运行效果如图7-21所示： "},"chapter8/":{"url":"chapter8/","title":"第八章：事件处理与通知","keywords":"","body":"事件处理与通知 Flutter中的手势系统有两个独立的层。第一层为原始指针(pointer)事件，它描述了屏幕上指针（例如，触摸、鼠标和触控笔）的位置和移动。 第二层为手势，描述由一个或多个指针移动组成的语义动作，如拖动、缩放、双击等。本章将先分别介绍如何处理这两种事件，最后再介绍一下Flutter中重要的Notification机制。 本章目录 原始指针事件处理 手势识别 全局事件总线 通知Notification "},"chapter8/listener.html":{"url":"chapter8/listener.html","title":"8.1：原始指针事件处理","keywords":"","body":"8.1 原始指针事件处理 本节先来介绍一下原始指针事件(Pointer Event，在移动设备上通常为触摸事件)，下一节再介绍手势处理。 在移动端，各个平台或UI系统的原始指针事件模型基本都是一致，即：一次完整的事件分为三个阶段：手指按下、手指移动、和手指抬起，而更高级别的手势（如点击、双击、拖动等）都是基于这些原始事件的。 当指针按下时，Flutter会对应用程序执行命中测试(Hit Test)，以确定指针与屏幕接触的位置存在哪些组件（widget）， 指针按下事件（以及该指针的后续事件）然后被分发到由命中测试发现的最内部的组件，然后从那里开始，事件会在组件树中向上冒泡，这些事件会从最内部的组件被分发到组件树根的路径上的所有组件，这和Web开发中浏览器的事件冒泡机制相似， 但是Flutter中没有机制取消或停止”冒泡“过程，而浏览器的冒泡是可以停止的。注意，只有通过命中测试的组件才能触发事件。 Flutter中可以使用Listener来监听原始触摸事件，按照本书对组件的分类，则Listener也是一个功能性组件。下面是Listener的构造函数定义： Listener({ Key key, this.onPointerDown, //手指按下回调 this.onPointerMove, //手指移动回调 this.onPointerUp,//手指抬起回调 this.onPointerCancel,//触摸事件取消回调 this.behavior = HitTestBehavior.deferToChild, //在命中测试期间如何表现 Widget child }) 我们先看一个示例，后面再单独讨论一下behavior属性。 ... //定义一个状态，保存当前指针位置 PointerEvent _event; ... Listener( child: Container( alignment: Alignment.center, color: Colors.blue, width: 300.0, height: 150.0, child: Text(_event?.toString()??\"\",style: TextStyle(color: Colors.white)), ), onPointerDown: (PointerDownEvent event) => setState(()=>_event=event), onPointerMove: (PointerMoveEvent event) => setState(()=>_event=event), onPointerUp: (PointerUpEvent event) => setState(()=>_event=event), ), 运行后效果如图8-1所示： 手指在蓝色矩形区域内移动即可看到当前指针偏移，当触发指针事件时，参数PointerDownEvent、PointerMoveEvent、PointerUpEvent都是PointerEvent的一个子类，PointerEvent类中包括当前指针的一些信息，如： position：它是鼠标相对于当对于全局坐标的偏移。 delta：两次指针移动事件（PointerMoveEvent）的距离。 pressure：按压力度，如果手机屏幕支持压力传感器(如iPhone的3D Touch)，此属性会更有意义，如果手机不支持，则始终为1。 orientation：指针移动方向，是一个角度值。 上面只是PointerEvent一些常用属性，除了这些它还有很多属性，读者可以查看API文档。 现在，我们重点来介绍一下behavior属性，它决定子组件如何响应命中测试，它的值类型为HitTestBehavior，这是一个枚举类，有三个枚举值： deferToChild：子组件会一个接一个的进行命中测试，如果子组件中有测试通过的，则当前组件通过，这就意味着，如果指针事件作用于子组件上时，其父级组件也肯定可以收到该事件。 opaque：在命中测试时，将当前组件当成不透明处理(即使本身是透明的)，最终的效果相当于当前Widget的整个区域都是点击区域。举个例子： Listener( child: ConstrainedBox( constraints: BoxConstraints.tight(Size(300.0, 150.0)), child: Center(child: Text(\"Box A\")), ), //behavior: HitTestBehavior.opaque, onPointerDown: (event) => print(\"down A\") ), 上例中，只有点击文本内容区域才会触发点击事件，因为 deferToChild 会去子组件判断是否命中测试，而该例中子组件就是 Text(\"Box A\") 。 如果我们想让整个300×150的矩形区域都能点击我们可以将behavior设为HitTestBehavior.opaque。注意，该属性并不能用于在组件树中拦截（忽略）事件，它只是决定命中测试时的组件大小。 translucent：当点击组件透明区域时，可以对自身边界内及底部可视区域都进行命中测试，这意味着点击顶部组件透明区域时，顶部组件和底部组件都可以接收到事件，例如： Stack( children: [ Listener( child: ConstrainedBox( constraints: BoxConstraints.tight(Size(300.0, 200.0)), child: DecoratedBox( decoration: BoxDecoration(color: Colors.blue)), ), onPointerDown: (event) => print(\"down0\"), ), Listener( child: ConstrainedBox( constraints: BoxConstraints.tight(Size(200.0, 100.0)), child: Center(child: Text(\"左上角200*100范围内非文本区域点击\")), ), onPointerDown: (event) => print(\"down1\"), //behavior: HitTestBehavior.translucent, //放开此行注释后可以\"点透\" ) ], ) 上例中，当注释掉最后一行代码后，在左上角200*100范围内非文本区域点击时（顶部组件透明区域），控制台只会打印“down0”，也就是说顶部组件没有接收到事件，而只有底部接收到了。当放开注释后，再点击时顶部和底部都会接收到事件，此时会打印： I/flutter ( 3039): down1 I/flutter ( 3039): down0 如果behavior值改为HitTestBehavior.opaque，则只会打印\"down1\"。 忽略PointerEvent 假如我们不想让某个子树响应PointerEvent的话，我们可以使用IgnorePointer和AbsorbPointer，这两个组件都能阻止子树接收指针事件，不同之处在于AbsorbPointer本身会参与命中测试，而IgnorePointer本身不会参与，这就意味着AbsorbPointer本身是可以接收指针事件的(但其子树不行)，而IgnorePointer不可以。一个简单的例子如下： Listener( child: AbsorbPointer( child: Listener( child: Container( color: Colors.red, width: 200.0, height: 100.0, ), onPointerDown: (event)=>print(\"in\"), ), ), onPointerDown: (event)=>print(\"up\"), ) 点击Container时，由于它在AbsorbPointer的子树上，所以不会响应指针事件，所以日志不会输出\"in\"，但AbsorbPointer本身是可以接收指针事件的，所以会输出\"up\"。如果将AbsorbPointer换成IgnorePointer，那么两个都不会输出。 "},"chapter8/gesture.html":{"url":"chapter8/gesture.html","title":"8.2：手势识别","keywords":"","body":"8.2 手势识别 本节先介绍一些Flutter中用于处理手势的GestureDetector和GestureRecognizer，然后再仔细讨论一下手势竞争与冲突问题。 8.2.1 GestureDetector GestureDetector是一个用于手势识别的功能性组件，我们通过它可以来识别各种手势。GestureDetector实际上是指针事件的语义化封装，接下来我们详细介绍一下各种手势识别。 点击、双击、长按 我们通过GestureDetector对Container进行手势识别，触发相应事件后，在Container上显示事件名，为了增大点击区域，将Container设置为200×100，代码如下： class GestureDetectorTestRoute extends StatefulWidget { @override _GestureDetectorTestRouteState createState() => new _GestureDetectorTestRouteState(); } class _GestureDetectorTestRouteState extends State { String _operation = \"No Gesture detected!\"; //保存事件名 @override Widget build(BuildContext context) { return Center( child: GestureDetector( child: Container( alignment: Alignment.center, color: Colors.blue, width: 200.0, height: 100.0, child: Text(_operation, style: TextStyle(color: Colors.white), ), ), onTap: () => updateText(\"Tap\"),//点击 onDoubleTap: () => updateText(\"DoubleTap\"), //双击 onLongPress: () => updateText(\"LongPress\"), //长按 ), ); } void updateText(String text) { //更新显示的事件名 setState(() { _operation = text; }); } } 运行效果如图8-2所示： 注意： 当同时监听onTap和onDoubleTap事件时，当用户触发tap事件时，会有200毫秒左右的延时，这是因为当用户点击完之后很可能会再次点击以触发双击事件，所以GestureDetector会等一段时间来确定是否为双击事件。如果用户只监听了onTap（没有监听onDoubleTap）事件时，则没有延时。 拖动、滑动 一次完整的手势过程是指用户手指按下到抬起的整个过程，期间，用户按下手指后可能会移动，也可能不会移动。GestureDetector对于拖动和滑动事件是没有区分的，他们本质上是一样的。GestureDetector会将要监听的组件的原点（左上角）作为本次手势的原点，当用户在监听的组件上按下手指时，手势识别就会开始。下面我们看一个拖动圆形字母A的示例： class _Drag extends StatefulWidget { @override _DragState createState() => new _DragState(); } class _DragState extends State with SingleTickerProviderStateMixin { double _top = 0.0; //距顶部的偏移 double _left = 0.0;//距左边的偏移 @override Widget build(BuildContext context) { return Stack( children: [ Positioned( top: _top, left: _left, child: GestureDetector( child: CircleAvatar(child: Text(\"A\")), //手指按下时会触发此回调 onPanDown: (DragDownDetails e) { //打印手指按下的位置(相对于屏幕) print(\"用户手指按下：${e.globalPosition}\"); }, //手指滑动时会触发此回调 onPanUpdate: (DragUpdateDetails e) { //用户手指滑动时，更新偏移，重新构建 setState(() { _left += e.delta.dx; _top += e.delta.dy; }); }, onPanEnd: (DragEndDetails e){ //打印滑动结束时在x、y轴上的速度 print(e.velocity); }, ), ) ], ); } } 运行后，就可以在任意方向拖动了，运行效果如图8-3所示： 日志： I/flutter ( 8513): 用户手指按下：Offset(26.3, 101.8) I/flutter ( 8513): Velocity(235.5, 125.8) 代码解释： DragDownDetails.globalPosition：当用户按下时，此属性为用户按下的位置相对于屏幕（而非父组件）原点(左上角)的偏移。 DragUpdateDetails.delta：当用户在屏幕上滑动时，会触发多次Update事件，delta指一次Update事件的滑动的偏移量。 DragEndDetails.velocity：该属性代表用户抬起手指时的滑动速度(包含x、y两个轴的），示例中并没有处理手指抬起时的速度，常见的效果是根据用户抬起手指时的速度做一个减速动画。 单一方向拖动 在本示例中，是可以朝任意方向拖动的，但是在很多场景，我们只需要沿一个方向来拖动，如一个垂直方向的列表，GestureDetector可以只识别特定方向的手势事件，我们将上面的例子改为只能沿垂直方向拖动： class _DragVertical extends StatefulWidget { @override _DragVerticalState createState() => new _DragVerticalState(); } class _DragVerticalState extends State { double _top = 0.0; @override Widget build(BuildContext context) { return Stack( children: [ Positioned( top: _top, child: GestureDetector( child: CircleAvatar(child: Text(\"A\")), //垂直方向拖动事件 onVerticalDragUpdate: (DragUpdateDetails details) { setState(() { _top += details.delta.dy; }); } ), ) ], ); } } 这样就只能在垂直方向拖动了，如果只想在水平方向滑动同理。 缩放 GestureDetector可以监听缩放事件，下面示例演示了一个简单的图片缩放效果： class _ScaleTestRouteState extends State { double _width = 200.0; //通过修改图片宽度来达到缩放效果 @override Widget build(BuildContext context) { return Center( child: GestureDetector( //指定宽度，高度自适应 child: Image.asset(\"./images/sea.png\", width: _width), onScaleUpdate: (ScaleUpdateDetails details) { setState(() { //缩放倍数在0.8到10倍之间 _width=200*details.scale.clamp(.8, 10.0); }); }, ), ); } } 运行效果如图8-4所示： 现在在图片上双指张开、收缩就可以放大、缩小图片。本示例比较简单，实际中我们通常还需要一些其它功能，如双击放大或缩小一定倍数、双指张开离开屏幕时执行一个减速放大动画等，读者可以在学习完后面”动画“一章中的内容后自己来尝试实现一下。 8.2.2 GestureRecognizer GestureDetector内部是使用一个或多个GestureRecognizer来识别各种手势的，而GestureRecognizer的作用就是通过Listener来将原始指针事件转换为语义手势，GestureDetector直接可以接收一个子widget。GestureRecognizer是一个抽象类，一种手势的识别器对应一个GestureRecognizer的子类，Flutter实现了丰富的手势识别器，我们可以直接使用。 示例 假设我们要给一段富文本（RichText）的不同部分分别添加点击事件处理器，但是TextSpan并不是一个widget，这时我们不能用GestureDetector，但TextSpan有一个recognizer属性，它可以接收一个GestureRecognizer。 假设我们需要在点击时给文本变色: import 'package:flutter/gestures.dart'; class _GestureRecognizerTestRouteState extends State { TapGestureRecognizer _tapGestureRecognizer = new TapGestureRecognizer(); bool _toggle = false; //变色开关 @override void dispose() { //用到GestureRecognizer的话一定要调用其dispose方法释放资源 _tapGestureRecognizer.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return Center( child: Text.rich( TextSpan( children: [ TextSpan(text: \"你好世界\"), TextSpan( text: \"点我变色\", style: TextStyle( fontSize: 30.0, color: _toggle ? Colors.blue : Colors.red ), recognizer: _tapGestureRecognizer ..onTap = () { setState(() { _toggle = !_toggle; }); }, ), TextSpan(text: \"你好世界\"), ] ) ), ); } } 运行效果： 注意：使用GestureRecognizer后一定要调用其dispose()方法来释放资源（主要是取消内部的计时器）。 8.2.3 手势竞争与冲突 竞争 如果在上例中我们同时监听水平和垂直方向的拖动事件，那么我们斜着拖动时哪个方向会生效？实际上取决于第一次移动时两个轴上的位移分量，哪个轴的大，哪个轴在本次滑动事件竞争中就胜出。实际上Flutter中的手势识别引入了一个Arena的概念，Arena直译为“竞技场”的意思，每一个手势识别器（GestureRecognizer）都是一个“竞争者”（GestureArenaMember），当发生滑动事件时，他们都要在“竞技场”去竞争本次事件的处理权，而最终只有一个“竞争者”会胜出(win)。例如，假设有一个ListView，它的第一个子组件也是ListView，如果现在滑动这个子ListView，父ListView会动吗？答案是否定的，这时只有子ListView会动，因为这时子ListView会胜出而获得滑动事件的处理权。 示例 我们以拖动手势为例，同时识别水平和垂直方向的拖动手势，当用户按下手指时就会触发竞争（水平方向和垂直方向），一旦某个方向“获胜”，则直到当次拖动手势结束都会沿着该方向移动。代码如下： import 'package:flutter/material.dart'; class BothDirectionTestRoute extends StatefulWidget { @override BothDirectionTestRouteState createState() => new BothDirectionTestRouteState(); } class BothDirectionTestRouteState extends State { double _top = 0.0; double _left = 0.0; @override Widget build(BuildContext context) { return Stack( children: [ Positioned( top: _top, left: _left, child: GestureDetector( child: CircleAvatar(child: Text(\"A\")), //垂直方向拖动事件 onVerticalDragUpdate: (DragUpdateDetails details) { setState(() { _top += details.delta.dy; }); }, onHorizontalDragUpdate: (DragUpdateDetails details) { setState(() { _left += details.delta.dx; }); }, ), ) ], ); } } 此示例运行后，每次拖动只会沿一个方向移动（水平或垂直），而竞争发生在手指按下后首次移动（move）时，此例中具体的“获胜”条件是：首次移动时的位移在水平和垂直方向上的分量大的一个获胜。 手势冲突 由于手势竞争最终只有一个胜出者，所以，当有多个手势识别器时，可能会产生冲突。假设有一个widget，它可以左右拖动，现在我们也想检测在它上面手指按下和抬起的事件，代码如下： class GestureConflictTestRouteState extends State { double _left = 0.0; @override Widget build(BuildContext context) { return Stack( children: [ Positioned( left: _left, child: GestureDetector( child: CircleAvatar(child: Text(\"A\")), //要拖动和点击的widget onHorizontalDragUpdate: (DragUpdateDetails details) { setState(() { _left += details.delta.dx; }); }, onHorizontalDragEnd: (details){ print(\"onHorizontalDragEnd\"); }, onTapDown: (details){ print(\"down\"); }, onTapUp: (details){ print(\"up\"); }, ), ) ], ); } } 现在我们按住圆形“A”拖动然后抬起手指，控制台日志如下: I/flutter (17539): down I/flutter (17539): onHorizontalDragEnd 我们发现没有打印\"up\"，这是因为在拖动时，刚开始按下手指时在没有移动时，拖动手势还没有完整的语义，此时TapDown手势胜出(win)，此时打印\"down\"，而拖动时，拖动手势会胜出，当手指抬起时，onHorizontalDragEnd 和 onTapUp发生了冲突，但是因为是在拖动的语义中，所以onHorizontalDragEnd胜出，所以就会打印 “onHorizontalDragEnd”。如果我们的代码逻辑中，对于手指按下和抬起是强依赖的，比如在一个轮播图组件中，我们希望手指按下时，暂停轮播，而抬起时恢复轮播，但是由于轮播图组件中本身可能已经处理了拖动手势（支持手动滑动切换），甚至可能也支持了缩放手势，这时我们如果在外部再用onTapDown、onTapUp来监听的话是不行的。这时我们应该怎么做？其实很简单，通过Listener监听原始指针事件就行： Positioned( top:80.0, left: _leftB, child: Listener( onPointerDown: (details) { print(\"down\"); }, onPointerUp: (details) { //会触发 print(\"up\"); }, child: GestureDetector( child: CircleAvatar(child: Text(\"B\")), onHorizontalDragUpdate: (DragUpdateDetails details) { setState(() { _leftB += details.delta.dx; }); }, onHorizontalDragEnd: (details) { print(\"onHorizontalDragEnd\"); }, ), ), ) 总结 手势冲突只是手势级别的，而手势是对原始指针的语义化的识别，所以在遇到复杂的冲突场景时，都可以通过Listener直接识别原始指针事件来解决冲突。 "},"chapter8/eventbus.html":{"url":"chapter8/eventbus.html","title":"8.3：全局事件总线","keywords":"","body":"8.3 事件总线 在APP中，我们经常会需要一个广播机制，用以跨页面事件通知，比如一个需要登录的APP中，页面会关注用户登录或注销事件，来进行一些状态更新。这时候，一个事件总线便会非常有用，事件总线通常实现了订阅者模式，订阅者模式包含发布者和订阅者两种角色，可以通过事件总线来触发事件和监听事件，本节我们实现一个简单的全局事件总线，我们使用单例模式，代码如下： //订阅者回调签名 typedef void EventCallback(arg); class EventBus { //私有构造函数 EventBus._internal(); //保存单例 static EventBus _singleton = new EventBus._internal(); //工厂构造函数 factory EventBus()=> _singleton; //保存事件订阅者队列，key:事件名(id)，value: 对应事件的订阅者队列 var _emap = new Map>(); //添加订阅者 void on(eventName, EventCallback f) { if (eventName == null || f == null) return; _emap[eventName] ??= new List(); _emap[eventName].add(f); } //移除订阅者 void off(eventName, [EventCallback f]) { var list = _emap[eventName]; if (eventName == null || list == null) return; if (f == null) { _emap[eventName] = null; } else { list.remove(f); } } //触发事件，事件触发后该事件所有订阅者会被调用 void emit(eventName, [arg]) { var list = _emap[eventName]; if (list == null) return; int len = list.length - 1; //反向遍历，防止在订阅者在回调中移除自身带来的下标错位 for (var i = len; i > -1; --i) { list[i](arg); } } } //定义一个top-level变量，页面引入该文件后可以直接使用bus var bus = new EventBus(); 使用 //页面A中 ... //监听登录事件 bus.on(\"login\", (arg) { // do something }); //登录页B中 ... //登录成功后触发登录事件，页面A中订阅者会被调用 bus.emit(\"login\", userInfo); 注意：Dart中实现单例模式的标准做法就是使用static变量+工厂构造函数的方式，这样就可以保证new EventBus()始终返回都是同一个实例，读者应该理解并掌握这种方法。 事件总线通常用于组件之间状态共享，但关于组件之间状态共享也有一些专门的包如redux、以及前面介绍过的Provider。对于一些简单的应用，事件总线是足以满足业务需求的，如果你决定使用状态管理包的话，一定要想清楚您的APP是否真的有必要使用它，防止“化简为繁”、过度设计。 "},"chapter8/notification.html":{"url":"chapter8/notification.html","title":"8.4：通知(Notification)","keywords":"","body":"8.4 Notification 通知（Notification）是Flutter中一个重要的机制，在widget树中，每一个节点都可以分发通知，通知会沿着当前节点向上传递，所有父节点都可以通过NotificationListener来监听通知。Flutter中将这种由子向父的传递通知的机制称为通知冒泡（Notification Bubbling）。通知冒泡和用户触摸事件冒泡是相似的，但有一点不同：通知冒泡可以中止，但用户触摸事件不行。 通知冒泡和Web开发中浏览器事件冒泡原理是相似的，都是事件从出发源逐层向上传递，我们可以在上层节点任意位置来监听通知/事件，也可以终止冒泡过程，终止冒泡后，通知将不会再向上传递。 Flutter中很多地方使用了通知，如可滚动组件（Scrollable Widget）滑动时就会分发滚动通知（ScrollNotification），而Scrollbar正是通过监听ScrollNotification来确定滚动条位置的。 下面是一个监听可滚动组件滚动通知的例子： NotificationListener( onNotification: (notification){ switch (notification.runtimeType){ case ScrollStartNotification: print(\"开始滚动\"); break; case ScrollUpdateNotification: print(\"正在滚动\"); break; case ScrollEndNotification: print(\"滚动停止\"); break; case OverscrollNotification: print(\"滚动到边界\"); break; } }, child: ListView.builder( itemCount: 100, itemBuilder: (context, index) { return ListTile(title: Text(\"$index\"),); } ), ); 上例中的滚动通知如ScrollStartNotification、ScrollUpdateNotification等都是继承自ScrollNotification类，不同类型的通知子类会包含不同的信息，比如ScrollUpdateNotification有一个scrollDelta属性，它记录了移动的位移，其它通知属性读者可以自己查看SDK文档。 上例中，我们通过NotificationListener来监听子ListView的滚动通知的，NotificationListener定义如下： class NotificationListener extends StatelessWidget { const NotificationListener({ Key key, @required this.child, this.onNotification, }) : super(key: key); ...//省略无关代码 } 我们可以看到： NotificationListener 继承自StatelessWidget类，所以它可以直接嵌套到Widget树中。 NotificationListener 可以指定一个模板参数，该模板参数类型必须是继承自Notification；当显式指定模板参数时，NotificationListener 便只会接收该参数类型的通知。举个例子，如果我们将上例子代码给为： //指定监听通知的类型为滚动结束通知(ScrollEndNotification) NotificationListener( onNotification: (notification){ //只会在滚动结束时才会触发此回调 print(notification); }, child: ListView.builder( itemCount: 100, itemBuilder: (context, index) { return ListTile(title: Text(\"$index\"),); } ), ); 上面代码运行后便只会在滚动结束时在控制台打印出通知的信息。 onNotification回调为通知处理回调，其函数签名如下： typedef NotificationListenerCallback = bool Function(T notification); 它的返回值类型为布尔值，当返回值为true时，阻止冒泡，其父级Widget将再也收不到该通知；当返回值为false 时继续向上冒泡通知。 Flutter的UI框架实现中，除了在可滚动组件在滚动过程中会发出ScrollNotification之外，还有一些其它的通知，如SizeChangedLayoutNotification、KeepAliveNotification 、LayoutChangedNotification等，Flutter正是通过这种通知机制来使父元素可以在一些特定时机来做一些事情。 自定义通知 除了Flutter内部通知，我们也可以自定义通知，下面我们看看如何实现自定义通知： 定义一个通知类，要继承自Notification类； class MyNotification extends Notification { MyNotification(this.msg); final String msg; } 分发通知。 Notification有一个dispatch(context)方法，它是用于分发通知的，我们说过context实际上就是操作Element的一个接口，它与Element树上的节点是对应的，通知会从context对应的Element节点向上冒泡。 下面我们看一个完整的例子： class NotificationRoute extends StatefulWidget { @override NotificationRouteState createState() { return new NotificationRouteState(); } } class NotificationRouteState extends State { String _msg=\"\"; @override Widget build(BuildContext context) { //监听通知 return NotificationListener( onNotification: (notification) { setState(() { _msg+=notification.msg+\" \"; }); return true; }, child: Center( child: Column( mainAxisSize: MainAxisSize.min, children: [ // RaisedButton( // onPressed: () => MyNotification(\"Hi\").dispatch(context), // child: Text(\"Send Notification\"), // ), Builder( builder: (context) { return RaisedButton( //按钮点击时分发通知 onPressed: () => MyNotification(\"Hi\").dispatch(context), child: Text(\"Send Notification\"), ); }, ), Text(_msg) ], ), ), ); } } class MyNotification extends Notification { MyNotification(this.msg); final String msg; } 上面代码中，我们每点一次按钮就会分发一个MyNotification类型的通知，我们在Widget根上监听通知，收到通知后我们将通知通过Text显示在屏幕上。 注意：代码中注释的部分是不能正常工作的，因为这个context是根Context，而NotificationListener是监听的子树，所以我们通过Builder来构建RaisedButton，来获得按钮位置的context。 运行效果如图8-6所示： 阻止冒泡 我们将上面的例子改为： class NotificationRouteState extends State { String _msg=\"\"; @override Widget build(BuildContext context) { //监听通知 return NotificationListener( onNotification: (notification){ print(notification.msg); //打印通知 return false; }, child: NotificationListener( onNotification: (notification) { setState(() { _msg+=notification.msg+\" \"; }); return false; }, child: ...//省略重复代码 ), ); } } 上列中两个NotificationListener进行了嵌套，子NotificationListener的onNotification回调返回了false，表示不阻止冒泡，所以父NotificationListener仍然会受到通知，所以控制台会打印出通知信息；如果将子NotificationListener的onNotification回调的返回值改为true，则父NotificationListener便不会再打印通知了，因为子NotificationListener已经终止通知冒泡了。 通知冒泡原理 我们在上面介绍了通知冒泡的现象及使用，现在我们更深入一些，介绍一下Flutter框架中是如何实现通知冒泡的。为了搞清楚这个问题，就必须看一下源码，我们从通知分发的的源头出发，然后再顺腾摸瓜。由于通知是通过Notification的dispatch(context)方法发出的，那我们先看看dispatch(context)方法中做了什么，下面是相关源码： void dispatch(BuildContext target) { target?.visitAncestorElements(visitAncestor); } dispatch(context)中调用了当前context的visitAncestorElements方法，该方法会从当前Element开始向上遍历父级元素；visitAncestorElements有一个遍历回调参数，在遍历过程中对遍历到的父级元素都会执行该回调。遍历的终止条件是：已经遍历到根Element或某个遍历回调返回false。源码中传给visitAncestorElements方法的遍历回调为visitAncestor方法，我们看看visitAncestor方法的实现： //遍历回调，会对每一个父级Element执行此回调 bool visitAncestor(Element element) { //判断当前element对应的Widget是否是NotificationListener。 //由于NotificationListener是继承自StatelessWidget， //故先判断是否是StatelessElement if (element is StatelessElement) { //是StatelessElement，则获取element对应的Widget，判断 //是否是NotificationListener 。 final StatelessWidget widget = element.widget; if (widget is NotificationListener) { //是NotificationListener，则调用该NotificationListener的_dispatch方法 if (widget._dispatch(this, element)) return false; } } return true; } visitAncestor会判断每一个遍历到的父级Widget是否是NotificationListener，如果不是，则返回true继续向上遍历，如果是，则调用NotificationListener的_dispatch方法，我们看看_dispatch方法的源码： bool _dispatch(Notification notification, Element element) { // 如果通知监听器不为空，并且当前通知类型是该NotificationListener // 监听的通知类型，则调用当前NotificationListener的onNotification if (onNotification != null && notification is T) { final bool result = onNotification(notification); // 返回值决定是否继续向上遍历 return result == true; } return false; } 我们可以看到NotificationListener的onNotification回调最终是在_dispatch方法中执行的，然后会根据返回值来确定是否继续向上冒泡。上面的源码实现其实并不复杂，通过阅读这些源码，一些额外的点读者可以注意一下： Context上也提供了遍历Element树的方法。 我们可以通过Element.widget得到element节点对应的widget；我们已经反复讲过Widget和Element的对应关系，读者通过这些源码来加深理解。 总结 Flutter中通过通知冒泡实现了一套自低向上的消息传递机制，这个和Web开发中浏览器的事件冒泡原理类似，Web开发者可以类比学习。另外我们通过源码了解了Flutter 通知冒泡的流程和原理，便于读者加深理解和学习Flutter的框架设计思想，在此，再次建议读者在平时学习中能多看看源码，定会受益匪浅。 "},"chapter9/":{"url":"chapter9/","title":"第九章：动画","keywords":"","body":"简介 精心设计的动画会让用户界面感觉更直观、流畅，能改善用户体验。 Flutter可以轻松实现各种动画类型，对于许多widget，特别是Material Design widgets，都带有在其设计规范中定义的标准动画效果(但也可以自定义这些效果)。本章将详细介绍Flutter的动画系统，并会通过几个小实例来演示，以帮助开发者迅速理解并掌握动画的开发流程与原理。 本章目录 9.1：Flutter动画简介 9.2：动画结构 9.3：自定义路由过渡动画 9.4：Hero动画 9.5：交织动画 9.6：通用\"切换动画\"组件（AnimatedSwitcher） "},"chapter9/intro.html":{"url":"chapter9/intro.html","title":"9.1：Flutter动画简介","keywords":"","body":"9.1 Flutter动画简介 在任何系统的UI框架中，动画实现的原理都是相同的，即：在一段时间内，快速地多次改变UI外观；由于人眼会产生视觉暂留，所以最终看到的就是一个“连续”的动画，这和电影的原理是一样的。我们将UI的一次改变称为一个动画帧，对应一次屏幕刷新，而决定动画流畅度的一个重要指标就是帧率FPS（Frame Per Second），即每秒的动画帧数。很明显，帧率越高则动画就会越流畅！一般情况下，对于人眼来说，动画帧率超过16FPS，就比较流畅了，超过32FPS就会非常的细腻平滑，而超过32FPS，人眼基本上就感受不到差别了。由于动画的每一帧都是要改变UI输出，所以在一个时间段内连续的改变UI输出是比较耗资源的，对设备的软硬件系统要求都较高，所以在UI系统中，动画的平均帧率是重要的性能指标，而在Flutter中，理想情况下是可以实现60FPS的，这和原生应用能达到的帧率是基本是持平的。 Flutter中动画抽象 为了方便开发者创建动画，不同的UI系统对动画都进行了一些抽象，比如在Android中可以通过XML来描述一个动画然后设置给View。Flutter中也对动画进行了抽象，主要涉及Animation、Curve、Controller、Tween这四个角色，它们一起配合来完成一个完整动画，下面我们一一来介绍它们。 Animation Animation是一个抽象类，它本身和UI渲染没有任何关系，而它主要的功能是保存动画的插值和状态；其中一个比较常用的Animation类是Animation。Animation对象是一个在一段时间内依次生成一个区间(Tween)之间值的类。Animation对象在整个动画执行过程中输出的值可以是线性的、曲线的、一个步进函数或者任何其他曲线函数等等，这由Curve来决定。 根据Animation对象的控制方式，动画可以正向运行（从起始状态开始，到终止状态结束），也可以反向运行，甚至可以在中间切换方向。Animation还可以生成除double之外的其他类型值，如：Animation 或Animation。在动画的每一帧中，我们可以通过Animation对象的value属性获取动画的当前状态值。 动画通知 我们可以通过Animation来监听动画每一帧以及执行状态的变化，Animation有如下两个方法： addListener()；它可以用于给Animation添加帧监听器，在每一帧都会被调用。帧监听器中最常见的行为是改变状态后调用setState()来触发UI重建。 addStatusListener()；它可以给Animation添加“动画状态改变”监听器；动画开始、结束、正向或反向（见AnimationStatus定义）时会调用状态改变的监听器。 读者在此只需要知道帧监听器和状态监听器的区别，在后面的章节中我们将会举例说明。 Curve 动画过程可以是匀速的、匀加速的或者先加速后减速等。Flutter中通过Curve（曲线）来描述动画过程，我们把匀速动画称为线性的(Curves.linear)，而非匀速动画称为非线性的。 我们可以通过CurvedAnimation来指定动画的曲线，如： final CurvedAnimation curve = new CurvedAnimation(parent: controller, curve: Curves.easeIn); CurvedAnimation和AnimationController（下面介绍）都是Animation类型。CurvedAnimation可以通过包装AnimationController和Curve生成一个新的动画对象 ，我们正是通过这种方式来将动画和动画执行的曲线关联起来的。我们指定动画的曲线为Curves.easeIn，它表示动画开始时比较慢，结束时比较快。 Curves 类是一个预置的枚举类，定义了许多常用的曲线，下面列几种常用的： Curves曲线 动画过程 linear 匀速的 decelerate 匀减速 ease 开始加速，后面减速 easeIn 开始慢，后面快 easeOut 开始快，后面慢 easeInOut 开始慢，然后加速，最后再减速 除了上面列举的， Curves 类中还定义了许多其它的曲线，在此便不一一介绍，读者可以自行查看Curves类定义。 当然我们也可以创建自己Curve，例如我们定义一个正弦曲线： class ShakeCurve extends Curve { @override double transform(double t) { return math.sin(t * math.PI * 2); } } AnimationController AnimationController用于控制动画，它包含动画的启动forward()、停止stop() 、反向播放 reverse()等方法。AnimationController会在动画的每一帧，就会生成一个新的值。默认情况下，AnimationController在给定的时间段内线性的生成从0.0到1.0（默认区间）的数字。 例如，下面代码创建一个Animation对象（但不会启动动画）： final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 2000), vsync: this); AnimationController生成数字的区间可以通过lowerBound和upperBound来指定，如： final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 2000), lowerBound: 10.0, upperBound: 20.0, vsync: this ); AnimationController派生自Animation，因此可以在需要Animation对象的任何地方使用。 但是，AnimationController具有控制动画的其他方法，例如forward()方法可以启动正向动画，reverse()可以启动反向动画。在动画开始执行后开始生成动画帧，屏幕没刷新一次就是一个动画帧，在动画的每一帧，会随着根据动画的曲线来生成当前的动画值（Animation.value），然后根据当前的动画值去构建UI，当所有动画帧依次触发时，动画值会依次改变，所以构建的UI也会依次变化，所以最终我们可以看到一个完成的动画。 另外在动画的每一帧，Animation对象会调用其帧监听器，等动画状态发生改变时（如动画结束）会调用状态改变监听器。 duration表示动画执行的时长，通过它我们可以控制动画的速度。 注意： 在某些情况下，动画值可能会超出AnimationController的[0.0，1.0]的范围，这取决于具体的曲线。例如，fling()函数可以根据我们手指滑动（甩出）的速度(velocity)、力量(force)等来模拟一个手指甩出动画，因此它的动画值可以在[0.0，1.0]范围之外 。也就是说，根据选择的曲线，CurvedAnimation的输出可以具有比输入更大的范围。例如，Curves.elasticIn等弹性曲线会生成大于或小于默认范围的值。 Ticker 当创建一个AnimationController时，需要传递一个vsync参数，它接收一个TickerProvider类型的对象，它的主要职责是创建Ticker，定义如下： abstract class TickerProvider { //通过一个回调创建一个Ticker Ticker createTicker(TickerCallback onTick); } Flutter应用在启动时都会绑定一个SchedulerBinding，通过SchedulerBinding可以给每一次屏幕刷新添加回调，而Ticker就是通过SchedulerBinding来添加屏幕刷新回调，这样一来，每次屏幕刷新都会调用TickerCallback。使用Ticker(而不是Timer)来驱动动画会防止屏幕外动画（动画的UI不在当前屏幕时，如锁屏时）消耗不必要的资源，因为Flutter中屏幕刷新时会通知到绑定的SchedulerBinding，而Ticker是受SchedulerBinding驱动的，由于锁屏后屏幕会停止刷新，所以Ticker就不会再触发。 通常我们会将SingleTickerProviderStateMixin添加到State的定义中，然后将State对象作为vsync的值，这在后面的例子中可以见到。 Tween 默认情况下，AnimationController对象值的范围是[0.0，1.0]。如果我们需要构建UI的动画值在不同的范围或不同的数据类型，则可以使用Tween来添加映射以生成不同的范围或数据类型的值。例如，像下面示例，Tween生成[-200.0，0.0]的值： final Tween doubleTween = new Tween(begin: -200.0, end: 0.0); Tween构造函数需要begin和end两个参数。Tween的唯一职责就是定义从输入范围到输出范围的映射。输入范围通常为[0.0，1.0]，但这不是必须的，我们可以自定义需要的范围。 Tween继承自Animatable，而不是继承自Animation，Animatable中主要定义动画值的映射规则。 下面我们看一个ColorTween将动画输入范围映射为两种颜色值之间过渡输出的例子： final Tween colorTween = new ColorTween(begin: Colors.transparent, end: Colors.black54); Tween对象不存储任何状态，相反，它提供了evaluate(Animation animation)方法，它可以获取动画当前映射值。 Animation对象的当前值可以通过value()方法取到。evaluate函数还执行一些其它处理，例如分别确保在动画值为0.0和1.0时返回开始和结束状态。 Tween.animate 要使用Tween对象，需要调用其animate()方法，然后传入一个控制器对象。例如，以下代码在500毫秒内生成从0到255的整数值。 final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 500), vsync: this); Animation alpha = new IntTween(begin: 0, end: 255).animate(controller); 注意animate()返回的是一个Animation，而不是一个Animatable。 以下示例构建了一个控制器、一条曲线和一个Tween： final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 500), vsync: this); final Animation curve = new CurvedAnimation(parent: controller, curve: Curves.easeOut); Animation alpha = new IntTween(begin: 0, end: 255).animate(curve); "},"chapter9/animation_structure.html":{"url":"chapter9/animation_structure.html","title":"9.2：动画结构","keywords":"","body":"9.2 动画基本结构及状态监听 9.2.1 动画基本结构 在Flutter中我们可以通过多种方式来实现动画，下面通过一个图片逐渐放大示例的不同实现来演示Flutter中动画的不同实现方式的区别。 基础版本 下面我们演示一下最基础的动画实现方式： class ScaleAnimationRoute extends StatefulWidget { @override _ScaleAnimationRouteState createState() => new _ScaleAnimationRouteState(); } //需要继承TickerProvider，如果有多个AnimationController，则应该使用TickerProviderStateMixin。 class _ScaleAnimationRouteState extends State with SingleTickerProviderStateMixin{ Animation animation; AnimationController controller; initState() { super.initState(); controller = new AnimationController( duration: const Duration(seconds: 3), vsync: this); //图片宽高从0变到300 animation = new Tween(begin: 0.0, end: 300.0).animate(controller) ..addListener(() { setState(()=>{}); }); //启动动画(正向执行) controller.forward(); } @override Widget build(BuildContext context) { return new Center( child: Image.asset(\"imgs/avatar.png\", width: animation.value, height: animation.value ), ); } dispose() { //路由销毁时需要释放动画资源 controller.dispose(); super.dispose(); } } 上面代码中addListener()函数调用了setState()，所以每次动画生成一个新的数字时，当前帧被标记为脏(dirty)，这会导致widget的build()方法再次被调用，而在build()中，改变Image的宽高，因为它的高度和宽度现在使用的是animation.value ，所以就会逐渐放大。值得注意的是动画完成时要释放控制器(调用dispose()方法)以防止内存泄漏。 上面的例子中并没有指定Curve，所以放大的过程是线性的（匀速），下面我们指定一个Curve，来实现一个类似于弹簧效果的动画过程，我们只需要将initState中的代码改为下面这样即可： initState() { super.initState(); controller = new AnimationController( duration: const Duration(seconds: 3), vsync: this); //使用弹性曲线 animation=CurvedAnimation(parent: controller, curve: Curves.bounceIn); //图片宽高从0变到300 animation = new Tween(begin: 0.0, end: 300.0).animate(animation) ..addListener(() { setState(() { }); }); //启动动画 controller.forward(); } 上面代码执行后截取了其中的两帧，效果如图9-1、9-2所示： 使用AnimatedWidget简化 细心的读者可能已经发现上面示例中通过addListener()和setState() 来更新UI这一步其实是通用的，如果每个动画中都加这么一句是比较繁琐的。AnimatedWidget类封装了调用setState()的细节，并允许我们将widget分离出来，重构后的代码如下： class AnimatedImage extends AnimatedWidget { AnimatedImage({Key key, Animation animation}) : super(key: key, listenable: animation); Widget build(BuildContext context) { final Animation animation = listenable; return new Center( child: Image.asset(\"imgs/avatar.png\", width: animation.value, height: animation.value ), ); } } class ScaleAnimationRoute1 extends StatefulWidget { @override _ScaleAnimationRouteState createState() => new _ScaleAnimationRouteState(); } class _ScaleAnimationRouteState extends State with SingleTickerProviderStateMixin { Animation animation; AnimationController controller; initState() { super.initState(); controller = new AnimationController( duration: const Duration(seconds: 3), vsync: this); //图片宽高从0变到300 animation = new Tween(begin: 0.0, end: 300.0).animate(controller); //启动动画 controller.forward(); } @override Widget build(BuildContext context) { return AnimatedImage(animation: animation,); } dispose() { //路由销毁时需要释放动画资源 controller.dispose(); super.dispose(); } } 用AnimatedBuilder重构 用AnimatedWidget可以从动画中分离出widget，而动画的渲染过程（即设置宽高）仍然在AnimatedWidget中，假设如果我们再添加一个widget透明度变化的动画，那么我们需要再实现一个AnimatedWidget，这样不是很优雅，如果我们能把渲染过程也抽象出来，那就会好很多，而AnimatedBuilder正是将渲染逻辑分离出来, 上面的build方法中的代码可以改为： @override Widget build(BuildContext context) { //return AnimatedImage(animation: animation,); return AnimatedBuilder( animation: animation, child: Image.asset(\"images/avatar.png\"), builder: (BuildContext ctx, Widget child) { return new Center( child: Container( height: animation.value, width: animation.value, child: child, ), ); }, ); } 上面的代码中有一个迷惑的问题是，child看起来像被指定了两次。但实际发生的事情是：将外部引用child传递给AnimatedBuilder后AnimatedBuilder再将其传递给匿名构造器， 然后将该对象用作其子对象。最终的结果是AnimatedBuilder返回的对象插入到widget树中。 也许你会说这和我们刚开始的示例差不了多少，其实它会带来三个好处： 不用显式的去添加帧监听器，然后再调用setState() 了，这个好处和AnimatedWidget是一样的。 动画构建的范围缩小了，如果没有builder，setState()将会在父组件上下文中调用，这将会导致父组件的build方法重新调用；而有了builder之后，只会导致动画widget自身的build重新调用，避免不必要的rebuild。 通过AnimatedBuilder可以封装常见的过渡效果来复用动画。下面我们通过封装一个GrowTransition来说明，它可以对子widget实现放大动画： class GrowTransition extends StatelessWidget { GrowTransition({this.child, this.animation}); final Widget child; final Animation animation; Widget build(BuildContext context) { return new Center( child: new AnimatedBuilder( animation: animation, builder: (BuildContext context, Widget child) { return new Container( height: animation.value, width: animation.value, child: child ); }, child: child ), ); } } 这样，最初的示例就可以改为： ... Widget build(BuildContext context) { return GrowTransition( child: Image.asset(\"images/avatar.png\"), animation: animation, ); } Flutter中正是通过这种方式封装了很多动画，如：FadeTransition、ScaleTransition、SizeTransition、FractionalTranslation等，很多时候都可以复用这些预置的过渡类。 9.2.2 动画状态监听 上面说过，我们可以通过Animation的addStatusListener()方法来添加动画状态改变监听器。Flutter中，有四种动画状态，在AnimationStatus枚举类中定义，下面我们逐个说明： 枚举值 含义 dismissed 动画在起始点停止 forward 动画正在正向执行 reverse 动画正在反向执行 completed 动画在终点停止 示例 我们将上面图片放大的示例改为先放大再缩小再放大……这样的循环动画。要实现这种效果，我们只需要监听动画状态的改变即可，即：在动画正向执行结束时反转动画，在动画反向执行结束时再正向执行动画。代码如下： initState() { super.initState(); controller = new AnimationController( duration: const Duration(seconds: 1), vsync: this); //图片宽高从0变到300 animation = new Tween(begin: 0.0, end: 300.0).animate(controller); animation.addStatusListener((status) { if (status == AnimationStatus.completed) { //动画执行结束时反向执行动画 controller.reverse(); } else if (status == AnimationStatus.dismissed) { //动画恢复到初始状态时执行动画（正向） controller.forward(); } }); //启动动画（正向） controller.forward(); } "},"chapter9/route_transition.html":{"url":"chapter9/route_transition.html","title":"9.3：自定义路由过渡动画","keywords":"","body":"9.3 自定义路由切换动画 我们在第二章”路由管理“一节中讲过：Material组件库中提供了一个MaterialPageRoute组件，它可以使用和平台风格一致的路由切换动画，如在iOS上会左右滑动切换，而在Android上会上下滑动切换。现在，我们如果在Android上也想使用左右切换风格，该怎么做？一个简单的作法是可以直接使用CupertinoPageRoute，如： Navigator.push(context, CupertinoPageRoute( builder: (context)=>PageB(), )); CupertinoPageRoute是Cupertino组件库提供的iOS风格的路由切换组件，它实现的就是左右滑动切换。那么我们如何来自定义路由切换动画呢？答案就是PageRouteBuilder。下面我们来看看如何使用PageRouteBuilder来自定义路由切换动画。例如我们想以渐隐渐入动画来实现路由过渡，实现代码如下： Navigator.push( context, PageRouteBuilder( transitionDuration: Duration(milliseconds: 500), //动画时间为500毫秒 pageBuilder: (BuildContext context, Animation animation, Animation secondaryAnimation) { return new FadeTransition( //使用渐隐渐入过渡, opacity: animation, child: PageB(), //路由B ); }, ), ); 我们可以看到pageBuilder 有一个animation参数，这是Flutter路由管理器提供的，在路由切换时pageBuilder在每个动画帧都会被回调，因此我们可以通过animation对象来自定义过渡动画。 无论是MaterialPageRoute、CupertinoPageRoute，还是PageRouteBuilder，它们都继承自PageRoute类，而PageRouteBuilder其实只是PageRoute的一个包装，我们可以直接继承PageRoute类来实现自定义路由，上面的例子可以通过如下方式实现： 定义一个路由类FadeRoute class FadeRoute extends PageRoute { FadeRoute({ @required this.builder, this.transitionDuration = const Duration(milliseconds: 300), this.opaque = true, this.barrierDismissible = false, this.barrierColor, this.barrierLabel, this.maintainState = true, }); final WidgetBuilder builder; @override final Duration transitionDuration; @override final bool opaque; @override final bool barrierDismissible; @override final Color barrierColor; @override final String barrierLabel; @override final bool maintainState; @override Widget buildPage(BuildContext context, Animation animation, Animation secondaryAnimation) => builder(context); @override Widget buildTransitions(BuildContext context, Animation animation, Animation secondaryAnimation, Widget child) { return FadeTransition( opacity: animation, child: builder(context), ); } } 使用FadeRoute Navigator.push(context, FadeRoute(builder: (context) { return PageB(); })); 虽然上面的两种方法都可以实现自定义切换动画，但实际使用时应优先考虑使用PageRouteBuilder，这样无需定义一个新的路由类，使用起来会比较方便。但是有些时候PageRouteBuilder是不能满足需求的，例如在应用过渡动画时我们需要读取当前路由的一些属性，这时就只能通过继承PageRoute的方式了，举个例子，假如我们只想在打开新路由时应用动画，而在返回时不使用动画，那么我们在构建过渡动画时就必须判断当前路由isActive属性是否为true，代码如下： @override Widget buildTransitions(BuildContext context, Animation animation, Animation secondaryAnimation, Widget child) { //当前路由被激活，是打开新路由 if(isActive) { return FadeTransition( opacity: animation, child: builder(context), ); }else{ //是返回，则不应用过渡动画 return Padding(padding: EdgeInsets.zero); } } 关于路由参数的详细信息读者可以自行查阅API文档，比较简单，不再赘述。 "},"chapter9/hero.html":{"url":"chapter9/hero.html","title":"9.4：Hero动画","keywords":"","body":"9.4 Hero动画 Hero指的是可以在路由(页面)之间“飞行”的widget，简单来说Hero动画就是在路由切换时，有一个共享的widget可以在新旧路由间切换。由于共享的widget在新旧路由页面上的位置、外观可能有所差异，所以在路由切换时会从旧路逐渐过渡到新路由中的指定位置，这样就会产生一个Hero动画。 你可能多次看到过 hero 动画。例如，一个路由中显示待售商品的缩略图列表，选择一个条目会将其跳转到一个新路由，新路由中包含该商品的详细信息和“购买”按钮。 在Flutter中将图片从一个路由“飞”到另一个路由称为hero动画，尽管相同的动作有时也称为 共享元素转换。下面我们通过一个示例来体验一下hero 动画。 为什么要将这种可飞行的共享组件称为hero（英雄），有一种说法是说美国文化中的超人是可以飞的，那是美国人心中的大英雄，还有漫威中的超级英雄基本上都是会飞的，所以Flutter开发人员就对这种”会飞的widget\"就起了一个富有浪漫主义的名字hero。当然这种说法并非官方解释，但却很有意思。 示例 假设有两个路由A和B，他们的内容交互如下： A：包含一个用户头像，圆形，点击后跳到B路由，可以查看大图。 B：显示用户头像原图，矩形； 在AB两个路由之间跳转的时候，用户头像会逐渐过渡到目标路由页的头像上，接下来我们先看看代码，然后再解析： // 路由A class HeroAnimationRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Container( alignment: Alignment.topCenter, child: InkWell( child: Hero( tag: \"avatar\", //唯一标记，前后两个路由页Hero的tag必须相同 child: ClipOval( child: Image.asset(\"images/avatar.png\", width: 50.0, ), ), ), onTap: () { //打开B路由 Navigator.push(context, PageRouteBuilder( pageBuilder: (BuildContext context, Animation animation, Animation secondaryAnimation) { return new FadeTransition( opacity: animation, child: Scaffold( appBar: AppBar( title: Text(\"原图\"), ), body: HeroAnimationRouteB(), ), ); }) ); }, ), ); } } 路由B: class HeroAnimationRouteB extends StatelessWidget { @override Widget build(BuildContext context) { return Center( child: Hero( tag: \"avatar\", //唯一标记，前后两个路由页Hero的tag必须相同 child: Image.asset(\"images/avatar.png\"), ), ); } } 我们可以看到，实现Hero动画只需要用Hero组件将要共享的widget包装起来，并提供一个相同的tag即可，中间的过渡帧都是Flutter Framework自动完成的。必须要注意， 前后路由页的共享Hero的tag必须是相同的，Flutter Framework内部正是通过tag来确定新旧路由页widget的对应关系的。 Hero动画的原理比较简单，Flutter Framework知道新旧路由页中共享元素的位置和大小，所以根据这两个端点，在动画执行过程中求出过渡时的插值（中间态）即可，而感到幸运的是，这些事情不需要我们自己动手，Flutter已经帮我们做了！ "},"chapter9/stagger_animation.html":{"url":"chapter9/stagger_animation.html","title":"9.5：交织动画","keywords":"","body":"9.5 交织动画 有些时候我们可能会需要一些复杂的动画，这些动画可能由一个动画序列或重叠的动画组成，比如：有一个柱状图，需要在高度增长的同时改变颜色，等到增长到最大高度后，我们需要在X轴上平移一段距离。可以发现上述场景在不同阶段包含了多种动画，要实现这种效果，使用交织动画（Stagger Animation）会非常简单。交织动画需要注意以下几点： 要创建交织动画，需要使用多个动画对象（Animation）。 一个AnimationController控制所有的动画对象。 给每一个动画对象指定时间间隔（Interval） 所有动画都由同一个AnimationController驱动，无论动画需要持续多长时间，控制器的值必须在0.0到1.0之间，而每个动画的间隔（Interval）也必须介于0.0和1.0之间。对于在间隔中设置动画的每个属性，需要分别创建一个Tween 用于指定该属性的开始值和结束值。也就是说0.0到1.0代表整个动画过程，我们可以给不同动画指定不同的起始点和终止点来决定它们的开始时间和终止时间。 示例 下面我们看一个例子，实现一个柱状图增长的动画： 开始时高度从0增长到300像素，同时颜色由绿色渐变为红色；这个过程占据整个动画时间的60%。 高度增长到300后，开始沿X轴向右平移100像素；这个过程占用整个动画时间的40%。 我们将执行动画的Widget分离出来： class StaggerAnimation extends StatelessWidget { StaggerAnimation({ Key key, this.controller }): super(key: key){ //高度动画 height = Tween( begin:.0 , end: 300.0, ).animate( CurvedAnimation( parent: controller, curve: Interval( 0.0, 0.6, //间隔，前60%的动画时间 curve: Curves.ease, ), ), ); color = ColorTween( begin:Colors.green , end:Colors.red, ).animate( CurvedAnimation( parent: controller, curve: Interval( 0.0, 0.6,//间隔，前60%的动画时间 curve: Curves.ease, ), ), ); padding = Tween( begin:EdgeInsets.only(left: .0), end:EdgeInsets.only(left: 100.0), ).animate( CurvedAnimation( parent: controller, curve: Interval( 0.6, 1.0, //间隔，后40%的动画时间 curve: Curves.ease, ), ), ); } final Animation controller; Animation height; Animation padding; Animation color; Widget _buildAnimation(BuildContext context, Widget child) { return Container( alignment: Alignment.bottomCenter, padding:padding.value , child: Container( color: color.value, width: 50.0, height: height.value, ), ); } @override Widget build(BuildContext context) { return AnimatedBuilder( builder: _buildAnimation, animation: controller, ); } } StaggerAnimation中定义了三个动画，分别是对Container的height、color、padding属性设置的动画，然后通过Interval来为每个动画指定在整个动画过程中的起始点和终点。下面我们来实现启动动画的路由： class StaggerRoute extends StatefulWidget { @override _StaggerRouteState createState() => _StaggerRouteState(); } class _StaggerRouteState extends State with TickerProviderStateMixin { AnimationController _controller; @override void initState() { super.initState(); _controller = AnimationController( duration: const Duration(milliseconds: 2000), vsync: this ); } Future _playAnimation() async { try { //先正向执行动画 await _controller.forward().orCancel; //再反向执行动画 await _controller.reverse().orCancel; } on TickerCanceled { // the animation got canceled, probably because we were disposed } } @override Widget build(BuildContext context) { return GestureDetector( behavior: HitTestBehavior.opaque, onTap: () { _playAnimation(); }, child: Center( child: Container( width: 300.0, height: 300.0, decoration: BoxDecoration( color: Colors.black.withOpacity(0.1), border: Border.all( color: Colors.black.withOpacity(0.5), ), ), //调用我们定义的交织动画Widget child: StaggerAnimation( controller: _controller ), ), ), ); } } 执行效果如图，点击图9-3灰色矩形，就可以看到整个动画效果，图9-4是动画执行过程中的一帧。 "},"chapter9/animated_switcher.html":{"url":"chapter9/animated_switcher.html","title":"9.6：通用\"切换动画\"组件（AnimatedSwitcher）","keywords":"","body":"9.6 通用\"切换动画\"组件（AnimatedSwitcher） 实际开发中，我们经常会遇到切换UI元素的场景，比如Tab切换、路由切换。为了增强用户体验，通常在切换时都会指定一个动画，以使切换过程显得平滑。Flutter SDK组件库中已经提供了一些常用的切换组件，如PageView、TabView等，但是，这些组件并不能覆盖全部的需求场景，为此，Flutter SDK中提供了一个AnimatedSwitcher组件，它定义了一种通用的UI切换抽象。 9.6.1 AnimatedSwitcher AnimatedSwitcher 可以同时对其新、旧子元素添加显示、隐藏动画。也就是说在AnimatedSwitcher的子元素发生变化时，会对其旧元素和新元素，我们先看看AnimatedSwitcher 的定义： const AnimatedSwitcher({ Key key, this.child, @required this.duration, // 新child显示动画时长 this.reverseDuration,// 旧child隐藏的动画时长 this.switchInCurve = Curves.linear, // 新child显示的动画曲线 this.switchOutCurve = Curves.linear,// 旧child隐藏的动画曲线 this.transitionBuilder = AnimatedSwitcher.defaultTransitionBuilder, // 动画构建器 this.layoutBuilder = AnimatedSwitcher.defaultLayoutBuilder, //布局构建器 }) 当AnimatedSwitcher的child发生变化时（类型或Key不同），旧child会执行隐藏动画，新child会执行执行显示动画。究竟执行何种动画效果则由transitionBuilder参数决定，该参数接受一个AnimatedSwitcherTransitionBuilder类型的builder，定义如下： typedef AnimatedSwitcherTransitionBuilder = Widget Function(Widget child, Animation animation); 该builder在AnimatedSwitcher的child切换时会分别对新、旧child绑定动画： 对旧child，绑定的动画会反向执行（reverse） 对新child，绑定的动画会正向指向（forward） 这样一下，便实现了对新、旧child的动画绑定。AnimatedSwitcher的默认值是AnimatedSwitcher.defaultTransitionBuilder ： Widget defaultTransitionBuilder(Widget child, Animation animation) { return FadeTransition( opacity: animation, child: child, ); } 可以看到，返回了FadeTransition对象，也就是说默认情况，AnimatedSwitcher会对新旧child执行“渐隐”和“渐显”动画。 例子 下面我们看一个列子：实现一个计数器，然后再每一次自增的过程中，旧数字执行缩小动画隐藏，新数字执行放大动画显示，代码如下： import 'package:flutter/material.dart'; class AnimatedSwitcherCounterRoute extends StatefulWidget { const AnimatedSwitcherCounterRoute({Key key}) : super(key: key); @override _AnimatedSwitcherCounterRouteState createState() => _AnimatedSwitcherCounterRouteState(); } class _AnimatedSwitcherCounterRouteState extends State { int _count = 0; @override Widget build(BuildContext context) { return Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ AnimatedSwitcher( duration: const Duration(milliseconds: 500), transitionBuilder: (Widget child, Animation animation) { //执行缩放动画 return ScaleTransition(child: child, scale: animation); }, child: Text( '$_count', //显示指定key，不同的key会被认为是不同的Text，这样才能执行动画 key: ValueKey(_count), style: Theme.of(context).textTheme.display1, ), ), RaisedButton( child: const Text('+1',), onPressed: () { setState(() { _count += 1; }); }, ), ], ), ); } } 运行示例代码，当点击“+1”按钮时，原先的数字会逐渐缩小直至隐藏，而新数字会逐渐放大，我截取了动画执行过程的一帧，如图9-5所示： 上图是第一次点击“+1”按钮后切换动画的一帧，此时“0”正在逐渐缩小，而“1”正在“0”的中间，正在逐渐放大。 注意：AnimatedSwitcher的新旧child，如果类型相同，则Key必须不相等。 9.6.2 AnimatedSwitcher高级用法 假设现在我们想实现一个类似路由平移切换的动画：旧页面屏幕中向左侧平移退出，新页面重屏幕右侧平移进入。如果要用AnimatedSwitcher的话，我们很快就会发现一个问题：做不到！我们可能会写出下面的代码： AnimatedSwitcher( duration: Duration(milliseconds: 200), transitionBuilder: (Widget child, Animation animation) { var tween=Tween(begin: Offset(1, 0), end: Offset(0, 0)) return SlideTransition( child: child, position: tween.animate(animation), ); }, ...//省略 ) 上面的代码有什么问题呢？我们前面说过在AnimatedSwitcher的child切换时会分别对新child执行正向动画（forward），而对旧child执行反向动画（reverse），所以真正的效果便是：新child确实从屏幕右侧平移进入了，但旧child却会从屏幕右侧（而不是左侧）退出。其实也很容易理解，因为在没有特殊处理的情况下同一个动画的正向和逆向正好是相反（对称）的。 那么问题来了，难道就不能用AnimatedSwitcher了？答案当时是否定的！仔细想想这个问题，究其原因，就是因为同一个Animation正向（forward）和反向（reverse）是对称的。所以如果我们可以打破这种对称性，那么便可以实现这个功能，下面我们来封装一个MySlideTransition，它和SlideTransition唯一的不同就是对动画的反向执行进行了（从左边滑出隐藏）： class MySlideTransition extends AnimatedWidget { MySlideTransition({ Key key, @required Animation position, this.transformHitTests = true, this.child, }) : assert(position != null), super(key: key, listenable: position) ; Animation get position => listenable; final bool transformHitTests; final Widget child; @override Widget build(BuildContext context) { Offset offset=position.value; //动画反向执行时，调整x偏移，实现”从左边滑出隐藏“ if (position.status == AnimationStatus.reverse) { offset = Offset(-offset.dx, offset.dy); } return FractionalTranslation( translation: offset, transformHitTests: transformHitTests, child: child, ); } } 调用时，将SlideTransition替换成MySlideTransition即可： AnimatedSwitcher( duration: Duration(milliseconds: 200), transitionBuilder: (Widget child, Animation animation) { var tween=Tween(begin: Offset(1, 0), end: Offset(0, 0)) return MySlideTransition( child: child, position: tween.animate(animation), ); }, ...//省略 ) 运行后，我截取动画执行过程中的一帧，如图9-6所示： 上图中“0”从左侧滑出，而\"1\"从右侧滑入。可以看到，我们通过这种巧妙的方式实现了类似路由进场切换的动画，实际上Flutter路由切换也正是通过AnimatedSwitcher来实现的。 SlideTransitionX 上面的示例我们实现了”左出右入“的动画，那如果要实现”右入左出“、”上入下出“或者 ”下入上出“怎么办？当然，我们可以分别修改上面的代码，但是这样每种动画都得单独定义一个”Transition“，这很麻烦。本节将分装一个通用的SlideTransitionX 来实现这种”出入滑动动画“，代码如下： class SlideTransitionX extends AnimatedWidget { SlideTransitionX({ Key key, @required Animation position, this.transformHitTests = true, this.direction = AxisDirection.down, this.child, }) : assert(position != null), super(key: key, listenable: position) { // 偏移在内部处理 switch (direction) { case AxisDirection.up: _tween = Tween(begin: Offset(0, 1), end: Offset(0, 0)); break; case AxisDirection.right: _tween = Tween(begin: Offset(-1, 0), end: Offset(0, 0)); break; case AxisDirection.down: _tween = Tween(begin: Offset(0, -1), end: Offset(0, 0)); break; case AxisDirection.left: _tween = Tween(begin: Offset(1, 0), end: Offset(0, 0)); break; } } Animation get position => listenable; final bool transformHitTests; final Widget child; //退场（出）方向 final AxisDirection direction; Tween _tween; @override Widget build(BuildContext context) { Offset offset = _tween.evaluate(position); if (position.status == AnimationStatus.reverse) { switch (direction) { case AxisDirection.up: offset = Offset(offset.dx, -offset.dy); break; case AxisDirection.right: offset = Offset(-offset.dx, offset.dy); break; case AxisDirection.down: offset = Offset(offset.dx, -offset.dy); break; case AxisDirection.left: offset = Offset(-offset.dx, offset.dy); break; } } return FractionalTranslation( translation: offset, transformHitTests: transformHitTests, child: child, ); } } 现在如果我们想实现各种”滑动出入动画\"\"便非常容易，只需给direction传递不同的方向值即可，比如要实现”上入下出“，则： AnimatedSwitcher( duration: Duration(milliseconds: 200), transitionBuilder: (Widget child, Animation animation) { var tween=Tween(begin: Offset(1, 0), end: Offset(0, 0)) return SlideTransitionX( child: child, direction: AxisDirection.down, //上入下出 position: animation, ); }, ...//省略其余代码 ) 运行后，我截取动画执行过程中的一帧，如图9-7所示： 上图中“1”从底部滑出，而\"2\"从顶部滑入。读者可以尝试给SlideTransitionX的direction取不同的值来查看运行效果。 总结 本节我们学习了AnimatedSwitcher的详细用法，同时也介绍了打破AnimatedSwitcher动画对称性的方法。我们可以发现：在需要切换新旧UI元素的场景，AnimatedSwitcher将十分实用。 "},"chapter10/":{"url":"chapter10/","title":"第十章：自定义组件","keywords":"","body":"本章目录 10.1：自定义组件方法简介 10.2：组合现有组件 10.3：组合实例：TurnBox 10.4：自绘组件（CustomPaint与Canvas） 10.5：自绘实例：圆形渐变进度条(自绘) "},"chapter10/intro.html":{"url":"chapter10/intro.html","title":"10.1：自定义组件方法简介","keywords":"","body":"10.1 自定义组件方法简介 当Flutter提供的现有组件无法满足我们的需求，或者我们为了共享代码需要封装一些通用组件，这时我们就需要自定义组件。在Flutter中自定义组件有三种方式：通过组合其它组件、自绘和实现RenderObject。本节我们先分别介绍一下这三种方式的特点，后面章节中则详细介绍它们的细节。 组合其它Widget 这种方式是通过拼装其它组件来组合成一个新的组件。例如我们之前介绍的Container就是一个组合组件，它是由DecoratedBox、ConstrainedBox、Transform、Padding、Align等组件组成。 在Flutter中，组合的思想非常重要，Flutter提供了非常多的基础组件，而我们的界面开发其实就是按照需要组合这些组件来实现各种不同的布局而已。 自绘 如果遇到无法通过现有的组件来实现需要的UI时，我们可以通过自绘组件的方式来实现，例如我们需要一个颜色渐变的圆形进度条，而Flutter提供的CircularProgressIndicator并不支持在显示精确进度时对进度条应用渐变色（其valueColor 属性只支持执行旋转动画时变化Indicator的颜色），这时最好的方法就是通过自定义组件来绘制出我们期望的外观。我们可以通过Flutter中提供的CustomPaint和Canvas来实现UI自绘。 实现RenderObject Flutter提供的自身具有UI外观的组件，如文本Text、Image都是通过相应的RenderObject（我们将在“Flutter核心原理”一章中详细介绍RenderObject）渲染出来的，如Text是由RenderParagraph渲染；而Image是由RenderImage渲染。RenderObject是一个抽象类，它定义了一个抽象方法paint(...)： void paint(PaintingContext context, Offset offset) PaintingContext代表组件的绘制上下文，通过PaintingContext.canvas可以获得Canvas，而绘制逻辑主要是通过Canvas API来实现。子类需要重写此方法以实现自身的绘制逻辑，如RenderParagraph需要实现文本绘制逻辑，而RenderImage需要实现图片绘制逻辑。 可以发现，RenderObject中最终也是通过Canvas API来绘制的，那么通过实现RenderObject的方式和上面介绍的通过CustomPaint和Canvas自绘的方式有什么区别？其实答案很简单，CustomPaint只是为了方便开发者封装的一个代理类，它直接继承自SingleChildRenderObjectWidget，通过RenderCustomPaint的paint方法将Canvas和画笔Painter(需要开发者实现，后面章节介绍)连接起来实现了最终的绘制（绘制逻辑在Painter中）。 总结 “组合”是自定义组件最简单的方法，在任何需要自定义组件的场景下，我们都应该优先考虑是否能够通过组合来实现。而自绘和通过实现RenderObject的方法本质上是一样的，都需要开发者调用Canvas API手动去绘制UI，优点是强大灵活，理论上可以实现任何外观的UI，而缺点是必须了解Canvas API细节，并且得自己去实现绘制逻辑。 在本章接下来的小节中，我们将通过一些实例来详细介绍自定义UI的过程，由于后两种方法本质是相同的，并且Flutter中很多基础组件都是通过RenderObject的形式来实现的，所以后续我们只介绍CustomPaint和Canvas的方式，读者如果对自定义RenderObject的方法好奇，可以查看Flutter中相关基础组件对应的RenderObject的实现源码，如RenderParagraph或RenderImage。 "},"chapter10/combine.html":{"url":"chapter10/combine.html","title":"10.2：组合现有组件","keywords":"","body":"10.2 组合现有组件 在Flutter中页面UI通常都是由一些低阶别的组件组合而成，当我们需要封装一些通用组件时，应该首先考虑是否可以通过组合其它组件来实现，如果可以，则应优先使用组合，因为直接通过现有组件拼装会非常简单、灵活、高效。 示例：自定义渐变按钮 Flutter Material组件库中的按钮默认不支持渐变背景，为了实现渐变背景按钮，我们自定义一个GradientButton组件，它需要支持一下功能： 背景支持渐变色 手指按下时有涟漪效果 可以支持圆角 我们先来看看最终要实现的效果（图10-1）： 我们DecoratedBox可以支持背景色渐变和圆角，InkWell在手指按下有涟漪效果，所以我们可以通过组合DecoratedBox和InkWell来实现GradientButton，代码如下： import 'package:flutter/material.dart'; class GradientButton extends StatelessWidget { GradientButton({ this.colors, this.width, this.height, this.onPressed, this.borderRadius, @required this.child, }); // 渐变色数组 final List colors; // 按钮宽高 final double width; final double height; final Widget child; final BorderRadius borderRadius; //点击回调 final GestureTapCallback onPressed; @override Widget build(BuildContext context) { ThemeData theme = Theme.of(context); //确保colors数组不空 List _colors = colors ?? [theme.primaryColor, theme.primaryColorDark ?? theme.primaryColor]; return DecoratedBox( decoration: BoxDecoration( gradient: LinearGradient(colors: _colors), borderRadius: borderRadius, ), child: Material( type: MaterialType.transparency, child: InkWell( splashColor: _colors.last, highlightColor: Colors.transparent, borderRadius: borderRadius, onTap: onPressed, child: ConstrainedBox( constraints: BoxConstraints.tightFor(height: height, width: width), child: Center( child: Padding( padding: const EdgeInsets.all(8.0), child: DefaultTextStyle( style: TextStyle(fontWeight: FontWeight.bold), child: child, ), ), ), ), ), ), ); } } 可以看到GradientButton是由DecoratedBox、Padding、Center、InkWell等组件组合而成。当然上面的代码只是一个示例，作为一个按钮它还并不完整，比如没有禁用状态，读者可以根据实际需要来完善。 使用GradientButton import 'package:flutter/material.dart'; import '../widgets/index.dart'; class GradientButtonRoute extends StatefulWidget { @override _GradientButtonRouteState createState() => _GradientButtonRouteState(); } class _GradientButtonRouteState extends State { @override Widget build(BuildContext context) { return Container( child: Column( children: [ GradientButton( colors: [Colors.orange, Colors.red], height: 50.0, child: Text(\"Submit\"), onPressed: onTap, ), GradientButton( height: 50.0, colors: [Colors.lightGreen, Colors.green[700]], child: Text(\"Submit\"), onPressed: onTap, ), GradientButton( height: 50.0, colors: [Colors.lightBlue[300], Colors.blueAccent], child: Text(\"Submit\"), onPressed: onTap, ), ], ), ); } onTap() { print(\"button click\"); } } 总结 通过组合的方式定义组件和我们之前写界面并无差异，不过在抽离出单独的组件时我们要考虑代码规范性，如必要参数要用@required 标注，对于可选参数在特定场景需要判空或设置默认值等。这是由于使用者大多时候可能不了解组件的内部细节，所以为了保证代码健壮性，我们需要在用户错误地使用组件时能够兼容或报错提示（使用assert断言函数）。 "},"chapter10/turn_box.html":{"url":"chapter10/turn_box.html","title":"10.3：组合实例：TurnBox","keywords":"","body":"10.3 组合实例：TurnBox 我们之前已经介绍过RotatedBox，它可以旋转子组件，但是它有两个缺点：一是只能将其子节点以90度的倍数旋转；二是当旋转的角度发生变化时，旋转角度更新过程没有动画。 本节我们将实现一个TurnBox组件，它不仅可以以任意角度来旋转其子节点，而且可以在角度发生变化时执行一个动画以过渡到新状态，同时，我们可以手动指定动画速度。 TurnBox的完整代码如下： import 'package:flutter/widgets.dart'; class TurnBox extends StatefulWidget { const TurnBox({ Key key, this.turns = .0, //旋转的“圈”数,一圈为360度，如0.25圈即90度 this.speed = 200, //过渡动画执行的总时长 this.child }) :super(key: key); final double turns; final int speed; final Widget child; @override _TurnBoxState createState() => new _TurnBoxState(); } class _TurnBoxState extends State with SingleTickerProviderStateMixin { AnimationController _controller; @override void initState() { super.initState(); _controller = new AnimationController( vsync: this, lowerBound: -double.infinity, upperBound: double.infinity ); _controller.value = widget.turns; } @override void dispose() { _controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return RotationTransition( turns: _controller, child: widget.child, ); } @override void didUpdateWidget(TurnBox oldWidget) { super.didUpdateWidget(oldWidget); //旋转角度发生变化时执行过渡动画 if (oldWidget.turns != widget.turns) { _controller.animateTo( widget.turns, duration: Duration(milliseconds: widget.speed??200), curve: Curves.easeOut, ); } } } 上面代码中： 我们是通过组合RotationTransition和child来实现的旋转效果。 在didUpdateWidget中，我们判断要旋转的角度是否发生了变化，如果变了，则执行一个过渡动画。 下面我们测试一下TurnBox的功能，测试代码如下： import 'package:flutter/material.dart'; import '../widgets/index.dart'; class TurnBoxRoute extends StatefulWidget { @override _TurnBoxRouteState createState() => new _TurnBoxRouteState(); } class _TurnBoxRouteState extends State { double _turns = .0; @override Widget build(BuildContext context) { return Center( child: Column( children: [ TurnBox( turns: _turns, speed: 500, child: Icon(Icons.refresh, size: 50,), ), TurnBox( turns: _turns, speed: 1000, child: Icon(Icons.refresh, size: 150.0,), ), RaisedButton( child: Text(\"顺时针旋转1/5圈\"), onPressed: () { setState(() { _turns += .2; }); }, ), RaisedButton( child: Text(\"逆时针旋转1/5圈\"), onPressed: () { setState(() { _turns -= .2; }); }, ) ], ), ); } } 测试代码运行后效果如图10-2所示： 当我们点击旋转按钮时，两个图标的旋转都会旋转1/5圈，但旋转的速度是不同的，读者可以自己运行一下示例看看效果。 实际上本示例只组合了RotationTransition一个组件，它是一个最简的组合类组件示例。另外，如果我们封装的是StatefulWidget，那么一定要注意在组件更新时是否需要同步状态。比如我们要封装一个富文本展示组件MyRichText ，它可以自动处理url链接，定义如下： class MyRichText extends StatefulWidget { MyRichText({ Key key, this.text, // 文本字符串 this.linkStyle, // url链接样式 }) : super(key: key); final String text; final TextStyle linkStyle; @override _MyRichTextState createState() => _MyRichTextState(); } 接下来我们在_MyRichTextState中要实现的功能有两个： 解析文本字符串“text”，生成TextSpan缓存起来； 在build中返回最终的富文本样式； _MyRichTextState 实现的代码大致如下： class _MyRichTextState extends State { TextSpan _textSpan; @override Widget build(BuildContext context) { return RichText( text: _textSpan, ); } TextSpan parseText(String text) { // 耗时操作：解析文本字符串，构建出TextSpan。 // 省略具体实现。 } @override void initState() { _textSpan = parseText(widget.text) super.initState(); } } 由于解析文本字符串，构建出TextSpan是一个耗时操作，为了不在每次build的时候都解析一次，所以我们在initState中对解析的结果进行了缓存，然后再build中直接使用解析的结果_textSpan。这看起来很不错，但是上面的代码有一个严重的问题，就是父组件传入的text发生变化时（组件树结构不变），那么MyRichText显示的内容不会更新，原因就是initState只会在State创建时被调用，所以在text发生变化时，parseText没有重新执行，导致_textSpan任然是旧的解析值。要解决这个问题也很简单，我们只需添加一个didUpdateWidget回调，然后再里面重新调用parseText即可： @override void didUpdateWidget(MyRichText oldWidget) { if (widget.text != oldWidget.text) { _textSpan = parseText(widget.text); } super.didUpdateWidget(oldWidget); } 有些读者可能会觉得这个点也很简单，是的，的确很简单，之所以要在这里反复强调是因为这个点在实际开发中很容易被忽略，它虽然简单，但却很重要。总之，当我们在State中会缓存某些依赖Widget参数的数据时，一定要注意在组件更新时是否需要同步状态。 "},"chapter10/custom_paint.html":{"url":"chapter10/custom_paint.html","title":"10.4：自绘组件（CustomPaint与Canvas）","keywords":"","body":"10.4 自绘组件 （CustomPaint与Canvas） 对于一些复杂或不规则的UI，我们可能无法通过组合其它组件的方式来实现，比如我们需要一个正六边形、一个渐变的圆形进度条、一个棋盘等。当然，有时候我们可以使用图片来实现，但在一些需要动态交互的场景静态图片也是实现不了的，比如要实现一个手写输入面板，这时，我们就需要来自己绘制UI外观。 几乎所有的UI系统都会提供一个自绘UI的接口，这个接口通常会提供一块2D画布Canvas，Canvas内部封装了一些基本绘制的API，开发者可以通过Canvas绘制各种自定义图形。在Flutter中，提供了一个CustomPaint 组件，它可以结合画笔CustomPainter来实现自定义图形绘制。 CustomPaint 我们看看CustomPaint构造函数： CustomPaint({ Key key, this.painter, this.foregroundPainter, this.size = Size.zero, this.isComplex = false, this.willChange = false, Widget child, //子节点，可以为空 }) painter: 背景画笔，会显示在子节点后面; foregroundPainter: 前景画笔，会显示在子节点前面 size：当child为null时，代表默认绘制区域大小，如果有child则忽略此参数，画布尺寸则为child尺寸。如果有child但是想指定画布为特定大小，可以使用SizeBox包裹CustomPaint实现。 isComplex：是否复杂的绘制，如果是，Flutter会应用一些缓存策略来减少重复渲染的开销。 willChange：和isComplex配合使用，当启用缓存时，该属性代表在下一帧中绘制是否会改变。 可以看到，绘制时我们需要提供前景或背景画笔，两者也可以同时提供。我们的画笔需要继承CustomPainter类，我们在画笔类中实现真正的绘制逻辑。 注意 如果CustomPaint有子节点，为了避免子节点不必要的重绘并提高性能，通常情况下都会将子节点包裹在RepaintBoundary组件中，这样会在绘制时就会创建一个新的绘制层（Layer），其子组件将在新的Layer上绘制，而父组件将在原来Layer上绘制，也就是说RepaintBoundary 子组件的绘制将独立于父组件的绘制，RepaintBoundary会隔离其子节点和CustomPaint本身的绘制边界。示例如下： CustomPaint( size: Size(300, 300), //指定画布大小 painter: MyPainter(), child: RepaintBoundary(child:...)), ) CustomPainter CustomPainter中提定义了一个虚函数paint： void paint(Canvas canvas, Size size); paint有两个参数: Canvas：一个画布，包括各种绘制方法，我们列出一下常用的方法： |API名称 | 功能 | | ---------- | ------ | | drawLine | 画线 | | drawPoint | 画点 | | drawPath | 画路径 | | drawImage | 画图像 | | drawRect | 画矩形 | | drawCircle | 画圆 | | drawOval | 画椭圆 | | drawArc | 画圆弧 | Size：当前绘制区域大小。 画笔Paint 现在画布有了，我们最后还缺一个画笔，Flutter提供了Paint类来实现画笔。在Paint中，我们可以配置画笔的各种属性如粗细、颜色、样式等。如： var paint = Paint() //创建一个画笔并配置其属性 ..isAntiAlias = true //是否抗锯齿 ..style = PaintingStyle.fill //画笔样式：填充 ..color=Color(0x77cdb175);//画笔颜色 更多的配置属性读者可以参考Paint类定义。 示例：五子棋/盘 下面我们通过一个五子棋游戏中棋盘和棋子的绘制来演示自绘UI的过程，首先我们看一下我们的目标效果，如图10-3所示： 代码： import 'package:flutter/material.dart'; import 'dart:math'; class CustomPaintRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Center( child: CustomPaint( size: Size(300, 300), //指定画布大小 painter: MyPainter(), ), ); } } class MyPainter extends CustomPainter { @override void paint(Canvas canvas, Size size) { double eWidth = size.width / 15; double eHeight = size.height / 15; //画棋盘背景 var paint = Paint() ..isAntiAlias = true ..style = PaintingStyle.fill //填充 ..color = Color(0x77cdb175); //背景为纸黄色 canvas.drawRect(Offset.zero & size, paint); //画棋盘网格 paint ..style = PaintingStyle.stroke //线 ..color = Colors.black87 ..strokeWidth = 1.0; for (int i = 0; i true; } 性能 绘制是比较昂贵的操作，所以我们在实现自绘控件时应该考虑到性能开销，下面是两条关于性能优化的建议： 尽可能的利用好shouldRepaint返回值；在UI树重新build时，控件在绘制前都会先调用该方法以确定是否有必要重绘；假如我们绘制的UI不依赖外部状态，那么就应该始终返回false，因为外部状态改变导致重新build时不会影响我们的UI外观；如果绘制依赖外部状态，那么我们就应该在shouldRepaint中判断依赖的状态是否改变，如果已改变则应返回true来重绘，反之则应返回false不需要重绘。 绘制尽可能多的分层；在上面五子棋的示例中，我们将棋盘和棋子的绘制放在了一起，这样会有一个问题：由于棋盘始终是不变的，用户每次落子时变的只是棋子，但是如果按照上面的代码来实现，每次绘制棋子时都要重新绘制一次棋盘，这是没必要的。优化的方法就是将棋盘单独抽为一个组件，并设置其shouldRepaint回调值为false，然后将棋盘组件作为背景。然后将棋子的绘制放到另一个组件中，这样每次落子时只需要绘制棋子。 总结 自绘控件非常强大，理论上可以实现任何2D图形外观，实际上Flutter提供的所有组件最终都是通过调用Canvas绘制出来的，只不过绘制的逻辑被封装起来了，读者有兴趣可以查看具有外观样式的组件源码，找到其对应的RenderObject对象，如Text对应的RenderParagraph对象最终会通过Canvas实现文本绘制逻辑。下一节我们会再通过一个自绘的圆形背景渐变进度条的实例来帮助读者加深印象。 "},"chapter10/gradient_circular_progress_demo.html":{"url":"chapter10/gradient_circular_progress_demo.html","title":"10.5：自绘实例：圆形渐变进度条(自绘)","keywords":"","body":"10.5 自绘实例：圆形背景渐变进度条 本节我们实现一个圆形背景渐变进度条，它支持： 支持多种背景渐变色。 任意弧度；进度条可以不是整圆。 可以自定义粗细、两端是否圆角等样式。 可以发现要实现这样的一个进度条是无法通过现有组件组合而成的，所以我们通过自绘方式实现，代码如下： import 'dart:math'; import 'package:flutter/material.dart'; class GradientCircularProgressIndicator extends StatelessWidget { GradientCircularProgressIndicator({ this.strokeWidth = 2.0, @required this.radius, @required this.colors, this.stops, this.strokeCapRound = false, this.backgroundColor = const Color(0xFFEEEEEE), this.totalAngle = 2 * pi, this.value }); ///粗细 final double strokeWidth; /// 圆的半径 final double radius; ///两端是否为圆角 final bool strokeCapRound; /// 当前进度，取值范围 [0.0-1.0] final double value; /// 进度条背景色 final Color backgroundColor; /// 进度条的总弧度，2*PI为整圆，小于2*PI则不是整圆 final double totalAngle; /// 渐变色数组 final List colors; /// 渐变色的终止点，对应colors属性 final List stops; @override Widget build(BuildContext context) { double _offset = .0; // 如果两端为圆角，则需要对起始位置进行调整，否则圆角部分会偏离起始位置 // 下面调整的角度的计算公式是通过数学几何知识得出，读者有兴趣可以研究一下为什么是这样 if (strokeCapRound) { _offset = asin(strokeWidth / (radius * 2 - strokeWidth)); } var _colors = colors; if (_colors == null) { Color color = Theme .of(context) .accentColor; _colors = [color, color]; } return Transform.rotate( angle: -pi / 2.0 - _offset, child: CustomPaint( size: Size.fromRadius(radius), painter: _GradientCircularProgressPainter( strokeWidth: strokeWidth, strokeCapRound: strokeCapRound, backgroundColor: backgroundColor, value: value, total: totalAngle, radius: radius, colors: _colors, ) ), ); } } //实现画笔 class _GradientCircularProgressPainter extends CustomPainter { _GradientCircularProgressPainter({ this.strokeWidth: 10.0, this.strokeCapRound: false, this.backgroundColor = const Color(0xFFEEEEEE), this.radius, this.total = 2 * pi, @required this.colors, this.stops, this.value }); final double strokeWidth; final bool strokeCapRound; final double value; final Color backgroundColor; final List colors; final double total; final double radius; final List stops; @override void paint(Canvas canvas, Size size) { if (radius != null) { size = Size.fromRadius(radius); } double _offset = strokeWidth / 2.0; double _value = (value ?? .0); _value = _value.clamp(.0, 1.0) * total; double _start = .0; if (strokeCapRound) { _start = asin(strokeWidth/ (size.width - strokeWidth)); } Rect rect = Offset(_offset, _offset) & Size( size.width - strokeWidth, size.height - strokeWidth ); var paint = Paint() ..strokeCap = strokeCapRound ? StrokeCap.round : StrokeCap.butt ..style = PaintingStyle.stroke ..isAntiAlias = true ..strokeWidth = strokeWidth; // 先画背景 if (backgroundColor != Colors.transparent) { paint.color = backgroundColor; canvas.drawArc( rect, _start, total, false, paint ); } // 再画前景，应用渐变 if (_value > 0) { paint.shader = SweepGradient( startAngle: 0.0, endAngle: _value, colors: colors, stops: stops, ).createShader(rect); canvas.drawArc( rect, _start, _value, false, paint ); } } @override bool shouldRepaint(CustomPainter oldDelegate) => true; } 下面我们来测试一下，为了尽可能多的展示GradientCircularProgressIndicator的不同外观和用途，这个示例代码会比较长，并且添加了动画，建议读者将此示例运行起来观看实际效果，我们先看看其中的一帧动画的截图： 示例代码： import 'dart:math'; import 'package:flutter/material.dart'; import '../widgets/index.dart'; class GradientCircularProgressRoute extends StatefulWidget { @override GradientCircularProgressRouteState createState() { return new GradientCircularProgressRouteState(); } } class GradientCircularProgressRouteState extends State with TickerProviderStateMixin { AnimationController _animationController; @override void initState() { super.initState(); _animationController = new AnimationController(vsync: this, duration: Duration(seconds: 3)); bool isForward = true; _animationController.addStatusListener((status) { if (status == AnimationStatus.forward) { isForward = true; } else if (status == AnimationStatus.completed || status == AnimationStatus.dismissed) { if (isForward) { _animationController.reverse(); } else { _animationController.forward(); } } else if (status == AnimationStatus.reverse) { isForward = false; } }); _animationController.forward(); } @override void dispose() { _animationController.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return SingleChildScrollView( child: Center( child: Column( crossAxisAlignment: CrossAxisAlignment.center, children: [ AnimatedBuilder( animation: _animationController, builder: (BuildContext context, Widget child) { return Padding( padding: const EdgeInsets.symmetric(vertical: 16.0), child: Column( children: [ Wrap( spacing: 10.0, runSpacing: 16.0, children: [ GradientCircularProgressIndicator( // No gradient colors: [Colors.blue, Colors.blue], radius: 50.0, strokeWidth: 3.0, value: _animationController.value, ), GradientCircularProgressIndicator( colors: [Colors.red, Colors.orange], radius: 50.0, strokeWidth: 3.0, value: _animationController.value, ), GradientCircularProgressIndicator( colors: [Colors.red, Colors.orange, Colors.red], radius: 50.0, strokeWidth: 5.0, value: _animationController.value, ), GradientCircularProgressIndicator( colors: [Colors.teal, Colors.cyan], radius: 50.0, strokeWidth: 5.0, strokeCapRound: true, value: CurvedAnimation( parent: _animationController, curve: Curves.decelerate) .value, ), TurnBox( turns: 1 / 8, child: GradientCircularProgressIndicator( colors: [Colors.red, Colors.orange, Colors.red], radius: 50.0, strokeWidth: 5.0, strokeCapRound: true, backgroundColor: Colors.red[50], totalAngle: 1.5 * pi, value: CurvedAnimation( parent: _animationController, curve: Curves.ease) .value), ), RotatedBox( quarterTurns: 1, child: GradientCircularProgressIndicator( colors: [Colors.blue[700], Colors.blue[200]], radius: 50.0, strokeWidth: 3.0, strokeCapRound: true, backgroundColor: Colors.transparent, value: _animationController.value), ), GradientCircularProgressIndicator( colors: [ Colors.red, Colors.amber, Colors.cyan, Colors.green[200], Colors.blue, Colors.red ], radius: 50.0, strokeWidth: 5.0, strokeCapRound: true, value: _animationController.value, ), ], ), GradientCircularProgressIndicator( colors: [Colors.blue[700], Colors.blue[200]], radius: 100.0, strokeWidth: 20.0, value: _animationController.value, ), Padding( padding: const EdgeInsets.symmetric(vertical: 16.0), child: GradientCircularProgressIndicator( colors: [Colors.blue[700], Colors.blue[300]], radius: 100.0, strokeWidth: 20.0, value: _animationController.value, strokeCapRound: true, ), ), //剪裁半圆 ClipRect( child: Align( alignment: Alignment.topCenter, heightFactor: .5, child: Padding( padding: const EdgeInsets.only(bottom: 8.0), child: SizedBox( //width: 100.0, child: TurnBox( turns: .75, child: GradientCircularProgressIndicator( colors: [Colors.teal, Colors.cyan[500]], radius: 100.0, strokeWidth: 8.0, value: _animationController.value, totalAngle: pi, strokeCapRound: true, ), ), ), ), ), ), SizedBox( height: 104.0, width: 200.0, child: Stack( alignment: Alignment.center, children: [ Positioned( height: 200.0, top: .0, child: TurnBox( turns: .75, child: GradientCircularProgressIndicator( colors: [Colors.teal, Colors.cyan[500]], radius: 100.0, strokeWidth: 8.0, value: _animationController.value, totalAngle: pi, strokeCapRound: true, ), ), ), Padding( padding: const EdgeInsets.only(top: 10.0), child: Text( \"${(_animationController.value * 100).toInt()}%\", style: TextStyle( fontSize: 25.0, color: Colors.blueGrey, ), ), ) ], ), ), ], ), ); }, ), ], ), ), ); } } 怎么样，很炫酷吧！GradientCircularProgressIndicator已经被添加进了笔者维护的flukit组件库中了，读者如果有需要，可以直接依赖flukit包。 "},"chapter11/":{"url":"chapter11/","title":"第十一章：文件操作与网络请求","keywords":"","body":"本章目录 11.1：文件操作 11.2：Http请求-HttpClient 11.3：Http请求-Dio package 11.4：实例：Http分块下载 11.5：WebSocket 11.6：使用Socket API 11.7：Json转Dart Model类 "},"chapter11/file_operation.html":{"url":"chapter11/file_operation.html","title":"11.1：文件操作","keywords":"","body":"11.1 文件操作 Dart的IO库包含了文件读写的相关类，它属于Dart语法标准的一部分，所以通过Dart IO库，无论是Dart VM下的脚本还是Flutter，都是通过Dart IO库来操作文件的，不过和Dart VM相比，Flutter有一个重要差异是文件系统路径不同，这是因为Dart VM是运行在PC或服务器操作系统下，而Flutter是运行在移动操作系统中，他们的文件系统会有一些差异。 APP目录 Android和iOS的应用存储目录不同，PathProvider 插件提供了一种平台透明的方式来访问设备文件系统上的常用位置。该类当前支持访问两个文件系统位置： 临时目录: 可以使用 getTemporaryDirectory() 来获取临时目录； 系统可随时清除的临时目录（缓存）。在iOS上，这对应于NSTemporaryDirectory() 返回的值。在Android上，这是getCacheDir())返回的值。 文档目录: 可以使用getApplicationDocumentsDirectory()来获取应用程序的文档目录，该目录用于存储只有自己可以访问的文件。只有当应用程序被卸载时，系统才会清除该目录。在iOS上，这对应于NSDocumentDirectory。在Android上，这是AppData目录。 外部存储目录：可以使用getExternalStorageDirectory()来获取外部存储目录，如SD卡；由于iOS不支持外部目录，所以在iOS下调用该方法会抛出UnsupportedError异常，而在Android下结果是android SDK中getExternalStorageDirectory的返回值。 一旦你的Flutter应用程序有一个文件位置的引用，你可以使用dart:ioAPI来执行对文件系统的读/写操作。有关使用Dart处理文件和目录的详细内容可以参考Dart语言文档，下面我们看一个简单的例子。 示例 我们还是以计数器为例，实现在应用退出重启后可以恢复点击次数。 这里，我们使用文件来保存数据： 引入PathProvider插件；在pubspec.yaml文件中添加如下声明： path_provider: ^0.4.1 添加后，执行flutter packages get 获取一下, 版本号可能随着时间推移会发生变化，读者可以使用最新版。 实现： import 'dart:io'; import 'dart:async'; import 'package:flutter/material.dart'; import 'package:path_provider/path_provider.dart'; class FileOperationRoute extends StatefulWidget { FileOperationRoute({Key key}) : super(key: key); @override _FileOperationRouteState createState() => new _FileOperationRouteState(); } class _FileOperationRouteState extends State { int _counter; @override void initState() { super.initState(); //从文件读取点击次数 _readCounter().then((int value) { setState(() { _counter = value; }); }); } Future _getLocalFile() async { // 获取应用目录 String dir = (await getApplicationDocumentsDirectory()).path; return new File('$dir/counter.txt'); } Future _readCounter() async { try { File file = await _getLocalFile(); // 读取点击次数（以字符串） String contents = await file.readAsString(); return int.parse(contents); } on FileSystemException { return 0; } } Future _incrementCounter() async { setState(() { _counter++; }); // 将点击次数以字符串类型写到文件中 await (await _getLocalFile()).writeAsString('$_counter'); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar(title: new Text('文件操作')), body: new Center( child: new Text('点击了 $_counter 次'), ), floatingActionButton: new FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: new Icon(Icons.add), ), ); } } 上面代码比较简单，不再赘述，需要说明的是，本示例只是为了演示文件读写，而在实际开发中，如果要存储一些简单的数据，使用shared_preferences插件会比较简单。 注意，Dart IO库操作文件的API非常丰富，但本书不是介绍Dart语言的，故不详细说明，读者需要的话可以自行学习。 "},"chapter11/http.html":{"url":"chapter11/http.html","title":"11.2：Http请求-HttpClient","keywords":"","body":"11.2 通过HttpClient发起HTTP请求 Dart IO库中提供了用于发起Http请求的一些类，我们可以直接使用HttpClient来发起请求。使用HttpClient发起请求分为五步： 创建一个HttpClient： HttpClient httpClient = new HttpClient(); 打开Http连接，设置请求头： HttpClientRequest request = await httpClient.getUrl(uri); 这一步可以使用任意Http Method，如httpClient.post(...)、httpClient.delete(...)等。如果包含Query参数，可以在构建uri时添加，如： Uri uri=Uri(scheme: \"https\", host: \"flutterchina.club\", queryParameters: { \"xx\":\"xx\", \"yy\":\"dd\" }); 通过HttpClientRequest可以设置请求header，如： request.headers.add(\"user-agent\", \"test\"); 如果是post或put等可以携带请求体方法，可以通过HttpClientRequest对象发送request body，如： String payload=\"...\"; request.add(utf8.encode(payload)); //request.addStream(_inputStream); //可以直接添加输入流 等待连接服务器： HttpClientResponse response = await request.close(); 这一步完成后，请求信息就已经发送给服务器了，返回一个HttpClientResponse对象，它包含响应头（header）和响应流(响应体的Stream)，接下来就可以通过读取响应流来获取响应内容。 读取响应内容： String responseBody = await response.transform(utf8.decoder).join(); 我们通过读取响应流来获取服务器返回的数据，在读取时我们可以设置编码格式，这里是utf8。 请求结束，关闭HttpClient： httpClient.close(); 关闭client后，通过该client发起的所有请求都会中止。 示例 我们实现一个获取百度首页html的例子，示例效果如图11-1所示： ​ 点击“获取百度首页”按钮后，会请求百度首页，请求成功后，我们将返回内容显示出来并在控制台打印响应header，代码如下： import 'dart:convert'; import 'dart:io'; import 'package:flutter/material.dart'; class HttpTestRoute extends StatefulWidget { @override _HttpTestRouteState createState() => new _HttpTestRouteState(); } class _HttpTestRouteState extends State { bool _loading = false; String _text = \"\"; @override Widget build(BuildContext context) { return ConstrainedBox( constraints: BoxConstraints.expand(), child: SingleChildScrollView( child: Column( children: [ RaisedButton( child: Text(\"获取百度首页\"), onPressed: _loading ? null : () async { setState(() { _loading = true; _text = \"正在请求...\"; }); try { //创建一个HttpClient HttpClient httpClient = new HttpClient(); //打开Http连接 HttpClientRequest request = await httpClient.getUrl( Uri.parse(\"https://www.baidu.com\")); //使用iPhone的UA request.headers.add(\"user-agent\", \"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1\"); //等待连接服务器（会将请求信息发送给服务器） HttpClientResponse response = await request.close(); //读取响应内容 _text = await response.transform(utf8.decoder).join(); //输出响应头 print(response.headers); //关闭client后，通过该client发起的所有请求都会中止。 httpClient.close(); } catch (e) { _text = \"请求失败：$e\"; } finally { setState(() { _loading = false; }); } } ), Container( width: MediaQuery.of(context).size.width-50.0, child: Text(_text.replaceAll(new RegExp(r\"\\s\"), \"\")) ) ], ), ), ); } } 控制台输出： I/flutter (18545): connection: Keep-Alive I/flutter (18545): cache-control: no-cache I/flutter (18545): set-cookie: .... //有多个，省略... I/flutter (18545): transfer-encoding: chunked I/flutter (18545): date: Tue, 30 Oct 2018 10:00:52 GMT I/flutter (18545): content-encoding: gzip I/flutter (18545): vary: Accept-Encoding I/flutter (18545): strict-transport-security: max-age=172800 I/flutter (18545): content-type: text/html;charset=utf-8 I/flutter (18545): tracecode: 00525262401065761290103018, 00522983 HttpClient配置 HttpClient有很多属性可以配置，常用的属性列表如下： 属性 含义 idleTimeout 对应请求头中的keep-alive字段值，为了避免频繁建立连接，httpClient在请求结束后会保持连接一段时间，超过这个阈值后才会关闭连接。 connectionTimeout 和服务器建立连接的超时，如果超过这个值则会抛出SocketException异常。 maxConnectionsPerHost 同一个host，同时允许建立连接的最大数量。 autoUncompress 对应请求头中的Content-Encoding，如果设置为true，则请求头中Content-Encoding的值为当前HttpClient支持的压缩算法列表，目前只有\"gzip\" userAgent 对应请求头中的User-Agent字段。 可以发现，有些属性只是为了更方便的设置请求头，对于这些属性，你完全可以通过HttpClientRequest直接设置header，不同的是通过HttpClient设置的对整个httpClient都生效，而通过HttpClientRequest设置的只对当前请求生效。 HTTP请求认证 Http协议的认证（Authentication）机制可以用于保护非公开资源。如果Http服务器开启了认证，那么用户在发起请求时就需要携带用户凭据，如果你在浏览器中访问了启用Basic认证的资源时，浏览就会弹出一个登录框，如： 我们先看看Basic认证的基本过程： 客户端发送http请求给服务器，服务器验证该用户是否已经登录验证过了，如果没有的话， 服务器会返回一个401 Unauthozied给客户端，并且在响应header中添加一个 “WWW-Authenticate” 字段，例如： WWW-Authenticate: Basic realm=\"admin\" 其中\"Basic\"为认证方式，realm为用户角色的分组，可以在后台添加分组。 客户端得到响应码后，将用户名和密码进行base64编码（格式为用户名:密码），设置请求头Authorization，继续访问 : Authorization: Basic YXXFISDJFISJFGIJIJG 服务器验证用户凭据，如果通过就返回资源内容。 注意，Http的方式除了Basic认证之外还有：Digest认证、Client认证、Form Based认证等，目前Flutter的HttpClient只支持Basic和Digest两种认证方式，这两种认证方式最大的区别是发送用户凭据时，对于用户凭据的内容，前者只是简单的通过Base64编码（可逆），而后者会进行哈希运算，相对来说安全一点点，但是为了安全起见，无论是采用Basic认证还是Digest认证，都应该在Https协议下，这样可以防止抓包和中间人攻击。 HttpClient关于Http认证的方法和属性： addCredentials(Uri url, String realm, HttpClientCredentials credentials) 该方法用于添加用户凭据,如： httpClient.addCredentials(_uri, \"admin\", new HttpClientBasicCredentials(\"username\",\"password\"), //Basic认证凭据 ); 如果是Digest认证，可以创建Digest认证凭据： HttpClientDigestCredentials(\"username\",\"password\") authenticate(Future f(Uri url, String scheme, String realm)) 这是一个setter，类型是一个回调，当服务器需要用户凭据且该用户凭据未被添加时，httpClient会调用此回调，在这个回调当中，一般会调用addCredential()来动态添加用户凭证，例如： httpClient.authenticate=(Uri url, String scheme, String realm) async{ if(url.host==\"xx.com\" && realm==\"admin\"){ httpClient.addCredentials(url, \"admin\", new HttpClientBasicCredentials(\"username\",\"pwd\"), ); return true; } return false; }; 一个建议是，如果所有请求都需要认证，那么应该在HttpClient初始化时就调用addCredentials()来添加全局凭证，而不是去动态添加。 代理 可以通过findProxy来设置代理策略，例如，我们要将所有请求通过代理服务器（192.168.1.2:8888）发送出去： client.findProxy = (uri) { // 如果需要过滤uri，可以手动判断 return \"PROXY 192.168.1.2:8888\"; }; findProxy 回调返回值是一个遵循浏览器PAC脚本格式的字符串，详情可以查看API文档，如果不需要代理，返回\"DIRECT\"即可。 在APP开发中，很多时候我们需要抓包来调试，而抓包软件(如charles)就是一个代理，这时我们就可以将请求发送到我们的抓包软件，我们就可以在抓包软件中看到请求的数据了。 有时代理服务器也启用了身份验证，这和http协议的认证是相似的，HttpClient提供了对应的Proxy认证方法和属性： set authenticateProxy( Future f(String host, int port, String scheme, String realm)); void addProxyCredentials( String host, int port, String realm, HttpClientCredentials credentials); 他们的使用方法和上面“HTTP请求认证”一节中介绍的addCredentials和authenticate 相同，故不再赘述。 证书校验 Https中为了防止通过伪造证书而发起的中间人攻击，客户端应该对自签名或非CA颁发的证书进行校验。HttpClient对证书校验的逻辑如下： 如果请求的Https证书是可信CA颁发的，并且访问host包含在证书的domain列表中(或者符合通配规则)并且证书未过期，则验证通过。 如果第一步验证失败，但在创建HttpClient时，已经通过SecurityContext将证书添加到证书信任链中，那么当服务器返回的证书在信任链中的话，则验证通过。 如果1、2验证都失败了，如果用户提供了badCertificateCallback回调，则会调用它，如果回调返回true，则允许继续链接，如果返回false，则终止链接。 综上所述，我们的证书校验其实就是提供一个badCertificateCallback回调，下面通过一个示例来说明。 示例 假设我们的后台服务使用的是自签名证书，证书格式是PEM格式，我们将证书的内容保存在本地字符串中，那么我们的校验逻辑如下： String PEM=\"XXXXX\";//可以从文件读取 ... httpClient.badCertificateCallback=(X509Certificate cert, String host, int port){ if(cert.pem==PEM){ return true; //证书一致，则允许发送数据 } return false; }; X509Certificate是证书的标准格式，包含了证书除私钥外所有信息，读者可以自行查阅文档。另外，上面的示例没有校验host，是因为只要服务器返回的证书内容和本地的保存一致就已经能证明是我们的服务器了（而不是中间人），host验证通常是为了防止证书和域名不匹配。 对于自签名的证书，我们也可以将其添加到本地证书信任链中，这样证书验证时就会自动通过，而不会再走到badCertificateCallback回调中： SecurityContext sc=new SecurityContext(); //file为证书路径 sc.setTrustedCertificates(file); //创建一个HttpClient HttpClient httpClient = new HttpClient(context: sc); 注意，通过setTrustedCertificates()设置的证书格式必须为PEM或PKCS12，如果证书格式为PKCS12，则需将证书密码传入，这样则会在代码中暴露证书密码，所以客户端证书校验不建议使用PKCS12格式的证书。 总结 值得注意的是，HttpClient提供的这些属性和方法最终都会作用在请求header里，我们完全可以通过手动去设置header来实现，之所以提供这些方法，只是为了方便开发者而已。另外，Http协议是一个非常重要的、使用最多的网络协议，每一个开发者都应该对http协议非常熟悉。 "},"chapter11/dio.html":{"url":"chapter11/dio.html","title":"11.3：Http请求-Dio package","keywords":"","body":"11.3 Http请求-Dio http库 通过上一节介绍，我们可以发现直接使用HttpClient发起网络请求是比较麻烦的，很多事情得我们手动处理，如果再涉及到文件上传/下载、Cookie管理等就会非常繁琐。幸运的是，Dart社区有一些第三方http请求库，用它们来发起http请求将会简单的多，本节我们介绍一下目前人气较高的dio库。 dio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时等。dio的使用方式随着其版本升级可能会发生变化，如果本节所述内容和dio官方有差异，请以dio官方文档为准。 引入 引入dio: dependencies: dio: ^x.x.x #请使用pub上的最新版本 导入并创建dio实例： import 'package:dio/dio.dart'; Dio dio = Dio(); 接下来就可以通过 dio实例来发起网络请求了，注意，一个dio实例可以发起多个http请求，一般来说，APP只有一个http数据源时，dio应该使用单例模式。 示例 发起 GET 请求 : Response response; response=await dio.get(\"/test?id=12&name=wendu\") print(response.data.toString()); 对于GET请求我们可以将query参数通过对象来传递，上面的代码等同于： response=await dio.get(\"/test\",queryParameters:{\"id\":12,\"name\":\"wendu\"}) print(response); 发起一个 POST 请求: response=await dio.post(\"/test\",data:{\"id\":12,\"name\":\"wendu\"}) 发起多个并发请求: response= await Future.wait([dio.post(\"/info\"),dio.get(\"/token\")]); 下载文件: response=await dio.download(\"https://www.google.com/\",_savePath); 发送 FormData: FormData formData = new FormData.from({ \"name\": \"wendux\", \"age\": 25, }); response = await dio.post(\"/info\", data: formData) 如果发送的数据是FormData，则dio会将请求header的contentType设为“multipart/form-data”。 通过FormData上传多个文件: FormData formData = new FormData.from({ \"name\": \"wendux\", \"age\": 25, \"file1\": new UploadFileInfo(new File(\"./upload.txt\"), \"upload1.txt\"), \"file2\": new UploadFileInfo(new File(\"./upload.txt\"), \"upload2.txt\"), // 支持文件数组上传 \"files\": [ new UploadFileInfo(new File(\"./example/upload.txt\"), \"upload.txt\"), new UploadFileInfo(new File(\"./example/upload.txt\"), \"upload.txt\") ] }); response = await dio.post(\"/info\", data: formData) 值得一提的是，dio内部仍然使用HttpClient发起的请求，所以代理、请求认证、证书校验等和HttpClient是相同的，我们可以在onHttpClientCreate回调中设置，例如： (dio.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate = (client) { //设置代理 client.findProxy = (uri) { return \"PROXY 192.168.1.2:8888\"; }; //校验证书 httpClient.badCertificateCallback=(X509Certificate cert, String host, int port){ if(cert.pem==PEM){ return true; //证书一致，则允许发送数据 } return false; }; }; 注意，onHttpClientCreate会在当前dio实例内部需要创建HttpClient时调用，所以通过此回调配置HttpClient会对整个dio实例生效，如果你想针对某个应用请求单独的代理或证书校验策略，可以创建一个新的dio实例即可。 怎么样，是不是很简单，除了这些基本的用法，dio还支持请求配置、拦截器等，官方资料比较详细，故本书不再赘述，详情可以参考dio主页：https://github.com/flutterchina/dio 。 下一节我们将使用dio实现一个分块下载器。 实例 我们通过Github开放的API来请求flutterchina组织下的所有公开的开源项目，实现： 在请求阶段弹出loading 请求结束后，如果请求失败，则展示错误信息；如果成功，则将项目名称列表展示出来。 代码如下： class _FutureBuilderRouteState extends State { Dio _dio = new Dio(); @override Widget build(BuildContext context) { return new Container( alignment: Alignment.center, child: FutureBuilder( future: _dio.get(\"https://api.github.com/orgs/flutterchina/repos\"), builder: (BuildContext context, AsyncSnapshot snapshot) { //请求完成 if (snapshot.connectionState == ConnectionState.done) { Response response = snapshot.data; //发生错误 if (snapshot.hasError) { return Text(snapshot.error.toString()); } //请求成功，通过项目信息构建用于显示项目名称的ListView return ListView( children: response.data.map((e) => ListTile(title: Text(e[\"full_name\"])) ).toList(), ); } //请求未完成时弹出loading return CircularProgressIndicator(); } ), ); } } "},"chapter11/download_with_chunks.html":{"url":"chapter11/download_with_chunks.html","title":"11.4：实例：Http分块下载","keywords":"","body":"11.4 实例：Http分块下载 本节将通过一个“Http分块下载”的示例演示一下dio的具体用法。 原理 Http协议定义了分块传输的响应header字段，但具体是否支持取决于Server的实现，我们可以指定请求头的\"range\"字段来验证服务器是否支持分块传输。例如，我们可以利用curl命令来验证： bogon:~ duwen$ curl -H \"Range: bytes=0-10\" http://download.dcloud.net.cn/HBuilder.9.0.2.macosx_64.dmg -v # 请求头 > GET /HBuilder.9.0.2.macosx_64.dmg HTTP/1.1 > Host: download.dcloud.net.cn > User-Agent: curl/7.54.0 > Accept: */* > Range: bytes=0-10 # 响应头 我们在请求头中添加\"Range: bytes=0-10\"的作用是，告诉服务器本次请求我们只想获取文件0-10(包括10，共11字节)这块内容。如果服务器支持分块传输，则响应状态码为206，表示“部分内容”，并且同时响应头中包含”Content-Range“字段，如果不支持则不会包含。我们看看上面\"Content-Range\"的内容： Content-Range: bytes 0-10/233295878 0-10表示本次返回的区块，233295878代表文件的总长度，单位都是byte, 也就是该文件大概233M多一点。 基于此，我们可以设计一个简单的多线程的文件分块下载器，实现的思路是： 先检测是否支持分块传输，如果不支持，则直接下载；若支持，则将剩余内容分块下载。 各个分块下载时保存到各自临时文件，等到所有分块下载完后合并临时文件。 删除临时文件。 实现 下面是整体的流程： // 通过第一个分块请求检测服务器是否支持分块传输 Response response = await downloadChunk(url, 0, firstChunkSize, 0); if (response.statusCode == 206) { //如果支持 //解析文件总长度，进而算出剩余长度 total = int.parse( response.headers.value(HttpHeaders.contentRangeHeader).split(\"/\").last); int reserved = total - int.parse(response.headers.value(HttpHeaders.contentLengthHeader)); //文件的总块数(包括第一块) int chunk = (reserved / firstChunkSize).ceil() + 1; if (chunk > 1) { int chunkSize = firstChunkSize; if (chunk > maxChunk + 1) { chunk = maxChunk + 1; chunkSize = (reserved / maxChunk).ceil(); } var futures = []; for (int i = 0; i 下面我们使用dio的download API 实现downloadChunk： //start 代表当前块的起始位置，end代表结束位置 //no 代表当前是第几块 Future downloadChunk(url, start, end, no) async { progress.add(0); //progress记录每一块已接收数据的长度 --end; return dio.download( url, savePath + \"temp$no\", //临时文件按照块的序号命名，方便最后合并 onReceiveProgress: createCallback(no), // 创建进度回调，后面实现 options: Options( headers: {\"range\": \"bytes=$start-$end\"}, //指定请求的内容区间 ), ); } 接下来实现mergeTempFiles: Future mergeTempFiles(chunk) async { File f = File(savePath + \"temp0\"); IOSink ioSink= f.openWrite(mode: FileMode.writeOnlyAppend); //合并临时文件 for (int i = 1; i 下面我们看一下完整实现： /// Downloading by spiting as file in chunks Future downloadWithChunks( url, savePath, { ProgressCallback onReceiveProgress, }) async { const firstChunkSize = 102; const maxChunk = 3; int total = 0; var dio = Dio(); var progress = []; createCallback(no) { return (int received, _) { progress[no] = received; if (onReceiveProgress != null && total != 0) { onReceiveProgress(progress.reduce((a, b) => a + b), total); } }; } Future downloadChunk(url, start, end, no) async { progress.add(0); --end; return dio.download( url, savePath + \"temp$no\", onReceiveProgress: createCallback(no), options: Options( headers: {\"range\": \"bytes=$start-$end\"}, ), ); } Future mergeTempFiles(chunk) async { File f = File(savePath + \"temp0\"); IOSink ioSink= f.openWrite(mode: FileMode.writeOnlyAppend); for (int i = 1; i 1) { int chunkSize = firstChunkSize; if (chunk > maxChunk + 1) { chunk = maxChunk + 1; chunkSize = (reserved / maxChunk).ceil(); } var futures = []; for (int i = 0; i 现在可以进行分块下载了： main() async { var url = \"http://download.dcloud.net.cn/HBuilder.9.0.2.macosx_64.dmg\"; var savePath = \"./example/HBuilder.9.0.2.macosx_64.dmg\"; await downloadWithChunks(url, savePath, onReceiveProgress: (received, total) { if (total != -1) { print(\"${(received / total * 100).floor()}%\"); } }); } 思考 分块下载真的能提高下载速度吗？ 其实下载速度的主要瓶颈是取决于网络速度和服务器的出口速度，如果是同一个数据源，分块下载的意义并不大，因为服务器是同一个，出口速度确定的，主要取决于网速，而上面的例子正式同源分块下载，读者可以自己对比一下分块和不分块的的下载速度。如果有多个下载源，并且每个下载源的出口带宽都是有限制的，这时分块下载可能会更快一下，之所以说“可能”，是由于这并不是一定的，比如有三个源，三个源的出口带宽都为1G/s，而我们设备所连网络的峰值假设只有800M/s，那么瓶颈就在我们的网络。即使我们设备的带宽大于任意一个源，下载速度依然不一定就比单源单线下载快，试想一下，假设有两个源A和B，速度A源是B源的3倍，如果采用分块下载，两个源各下载一半的话，读者可以算一下所需的下载时间，然后再算一下只从A源下载所需的时间，看看哪个更快。 分块下载的最终速度受设备所在网络带宽、源出口速度、每个块大小、以及分块的数量等诸多因素影响，实际过程中很难保证速度最优。在实际开发中，读者可可以先测试对比后再决定是否使用。 分块下载有什么实际的用处吗？ 分块下载还有一个比较使用的场景是断点续传，可以将文件分为若干个块，然后维护一个下载状态文件用以记录每一个块的状态，这样即使在网络中断后，也可以恢复中断前的状态，具体实现读者可以自己尝试一下，还是有一些细节需要特别注意的，比如分块大小多少合适？下载到一半的块如何处理？要不要维护一个任务队列？ "},"chapter11/websocket.html":{"url":"chapter11/websocket.html","title":"11.5：WebSocket","keywords":"","body":"使用WebSockets Http协议是无状态的，只能由客户端主动发起，服务端再被动响应，服务端无法向客户端主动推送内容，并且一旦服务器响应结束，链接就会断开(见注解部分)，所以无法进行实时通信。WebSocket协议正是为解决客户端与服务端实时通信而产生的技术，现在已经被主流浏览器支持，所以对于Web开发者来说应该比较熟悉了，Flutter也提供了专门的包来支持WebSocket协议。 注意：Http协议中虽然可以通过keep-alive机制使服务器在响应结束后链接会保持一段时间，但最终还是会断开，keep-alive机制主要是用于避免在同一台服务器请求多个资源时频繁创建链接，它本质上是支持链接复用的技术，而并非用于实时通信，读者需要知道这两者的区别。 WebSocket协议本质上是一个基于tcp的协议，它是先通过HTTP协议发起一条特殊的http请求进行握手后，如果服务端支持WebSocket协议，则会进行协议升级。WebSocket会使用http协议握手后创建的tcp链接，和http协议不同的是，WebSocket的tcp链接是个长链接（不会断开），所以服务端与客户端就可以通过此TCP连接进行实时通信。有关WebSocket协议细节，读者可以看RFC文档，下面我们重点看看Flutter中如何使用WebSocket。 在接下来例子中，我们将连接到由websocket.org提供的测试服务器。服务器将简单地返回我们发送给它的相同消息！ 步骤 连接到WebSocket服务器。 监听来自服务器的消息。 将数据发送到服务器。 关闭WebSocket连接。 1. 连接到WebSocket服务器 web_socket_channel package 提供了我们需要连接到WebSocket服务器的工具。该package提供了一个WebSocketChannel允许我们既可以监听来自服务器的消息，又可以将消息发送到服务器的方法。 在Flutter中，我们可以创建一个WebSocketChannel连接到一台服务器： final channel = IOWebSocketChannel.connect('ws://echo.websocket.org'); 2. 监听来自服务器的消息 现在我们建立了连接，我们可以监听来自服务器的消息，在我们发送消息给测试服务器之后，它会返回相同的消息。 我们如何收取消息并显示它们？在这个例子中，我们将使用一个StreamBuilder 来监听新消息， 并用一个Text来显示它们。 new StreamBuilder( stream: widget.channel.stream, builder: (context, snapshot) { return new Text(snapshot.hasData ? '${snapshot.data}' : ''); }, ); 工作原理 WebSocketChannel提供了一个来自服务器的消息Stream 。该Stream类是dart:async包中的一个基础类。它提供了一种方法来监听来自数据源的异步事件。与Future返回单个异步响应不同，Stream类可以随着时间推移传递很多事件。该StreamBuilder 组件将连接到一个Stream， 并在每次收到消息时通知Flutter重新构建界面。 3. 将数据发送到服务器 为了将数据发送到服务器，我们会add消息给WebSocketChannel提供的sink。 channel.sink.add('Hello!'); 工作原理 WebSocketChannel提供了一个StreamSink，它将消息发给服务器。 StreamSink类提供了给数据源同步或异步添加事件的一般方法。 4. 关闭WebSocket连接 在我们使用WebSocket后，要关闭连接： channel.sink.close(); 完整的例子 import 'package:flutter/material.dart'; import 'package:web_socket_channel/io.dart'; class WebSocketRoute extends StatefulWidget { @override _WebSocketRouteState createState() => new _WebSocketRouteState(); } class _WebSocketRouteState extends State { TextEditingController _controller = new TextEditingController(); IOWebSocketChannel channel; String _text = \"\"; @override void initState() { //创建websocket连接 channel = new IOWebSocketChannel.connect('ws://echo.websocket.org'); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(\"WebSocket(内容回显)\"), ), body: new Padding( padding: const EdgeInsets.all(20.0), child: new Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ new Form( child: new TextFormField( controller: _controller, decoration: new InputDecoration(labelText: 'Send a message'), ), ), new StreamBuilder( stream: channel.stream, builder: (context, snapshot) { //网络不通会走到这 if (snapshot.hasError) { _text = \"网络不通...\"; } else if (snapshot.hasData) { _text = \"echo: \"+snapshot.data; } return new Padding( padding: const EdgeInsets.symmetric(vertical: 24.0), child: new Text(_text), ); }, ) ], ), ), floatingActionButton: new FloatingActionButton( onPressed: _sendMessage, tooltip: 'Send message', child: new Icon(Icons.send), ), ); } void _sendMessage() { if (_controller.text.isNotEmpty) { channel.sink.add(_controller.text); } } @override void dispose() { channel.sink.close(); super.dispose(); } } 上面的例子比较简单，不再赘述。我们现在思考一个问题，假如我们想通过WebSocket传输二进制数据应该怎么做（比如要从服务器接收一张图片）？我们发现StreamBuilder和Stream都没有指定接收类型的参数，并且在创建WebSocket链接时也没有相应的配置，貌似没有什么办法……其实很简单，要接收二进制数据仍然使用StreamBuilder，因为WebSocket中所有发送的数据使用帧的形式发送，而帧是有固定格式，每一个帧的数据类型都可以通过Opcode字段指定，它可以指定当前帧是文本类型还是二进制类型（还有其它类型），所以客户端在收到帧时就已经知道了其数据类型，所以flutter完全可以在收到数据后解析出正确的类型，所以就无需开发者去关心，当服务器传输的数据是指定为二进制时，StreamBuilder的snapshot.data的类型就是List，是文本时，则为String。 "},"chapter11/socket.html":{"url":"chapter11/socket.html","title":"11.6：使用Socket API","keywords":"","body":"11.6 使用Socket API 我们之前介绍的Http协议和WebSocket协议都属于应用层协议，除了它们，应用层协议还有很多如：SMTP、FTP等，这些应用层协议的实现都是通过Socket API来实现的。其实，操作系统中提供的原生网络请求API是标准的，在C语言的Socket库中，它主要提供了端到端建立链接和发送数据的基础API，而高级编程语言中的Socket库其实都是对操作系统的socket API的一个封装。所以，如果我们需要自定义协议或者想直接来控制管理网络链接、又或者我们觉得自带的HttpClient不好用想重新实现一个，这时我们就需要使用Socket。Flutter的Socket API在dart：io包中，下面我们看一个使用Socket实现简单http请求的示例，以请求百度首页为例： _request() async{ //建立连接 var socket=await Socket.connect(\"baidu.com\", 80); //根据http协议，发送请求头 socket.writeln(\"GET / HTTP/1.1\"); socket.writeln(\"Host:baidu.com\"); socket.writeln(\"Connection:close\"); socket.writeln(); await socket.flush(); //发送 //读取返回内容 _response =await socket.transform(utf8.decoder).join(); await socket.close(); } 可以看到，使用Socket需要我们自己实现Http协议（需要自己实现和服务器的通信过程），本例只是一个简单示例，没有处理重定向、cookie等。本示例完整代码参考示例demo，运行后效果如图11-2所示： 可以看到响应内容分两个部分，第一部分是响应头，第二部分是响应体，服务端可以根据请求信息动态来输出响应体。由于本示例请求头比较简单，所以响应体和浏览器中访问的会有差别，读者可以补充一些请求头(如user-agent)来看看输出的变化。 "},"chapter11/json_model.html":{"url":"chapter11/json_model.html","title":"11.7：Json转Dart Model类","keywords":"","body":"11.7 Json转Dart Model类 在实战中，后台接口往往会返回一些结构化数据，如JSON、XML等，如之前我们请求Github API的示例，它返回的数据就是JSON格式的字符串，为了方便我们在代码中操作JSON，我们先将JSON格式的字符串转为Dart对象，这个可以通过dart:convert中内置的JSON解码器json.decode() 来实现，该方法可以根据JSON字符串具体内容将其转为List或Map，这样我们就可以通过他们来查找所需的值，如： //一个JSON格式的用户列表字符串 String jsonStr='[{\"name\":\"Jack\"},{\"name\":\"Rose\"}]'; //将JSON字符串转为Dart对象(此处是List) List items=json.decode(jsonStr); //输出第一个用户的姓名 print(items[0][\"name\"]); 通过json.decode() 将JSON字符串转为List/Map的方法比较简单，它没有外部依赖或其它的设置，对于小项目很方便。但当项目变大时，这种手动编写序列化逻辑可能变得难以管理且容易出错，例如有如下JSON: { \"name\": \"John Smith\", \"email\": \"john@example.com\" } 我们可以通过调用json.decode方法来解码JSON ，使用JSON字符串作为参数: Map user = json.decode(json); print('Howdy, ${user['name']}!'); print('We sent the verification link to ${user['email']}.'); 由于json.decode()仅返回一个Map，这意味着直到运行时我们才知道值的类型。 通过这种方法，我们失去了大部分静态类型语言特性：类型安全、自动补全和最重要的编译时异常。这样一来，我们的代码可能会变得非常容易出错。例如，当我们访问name或email字段时，我们输入的很快，导致字段名打错了。但由于这个JSON在map结构中，所以编译器不知道这个错误的字段名，所以编译时不会报错。 其实，这个问题在很多平台上都会遇到，而也早就有了好的解决方法即“Json Model化”，具体做法就是，通过预定义一些与Json结构对应的Model类，然后在请求到数据后再动态根据数据创建出Model类的实例。这样一来，在开发阶段我们使用的是Model类的实例，而不再是Map/List，这样访问内部属性时就不会发生拼写错误。例如，我们可以通过引入一个简单的模型类(Model class)来解决前面提到的问题，我们称之为User。在User类内部，我们有： 一个User.fromJson 构造函数, 用于从一个map构造出一个 User实例 map structure 一个toJson 方法, 将 User 实例转化为一个map. 这样，调用代码现在可以具有类型安全、自动补全字段（name和email）以及编译时异常。如果我们将拼写错误字段视为int类型而不是String， 那么我们的代码就不会通过编译，而不是在运行时崩溃。 user.dart class User { final String name; final String email; User(this.name, this.email); User.fromJson(Map json) : name = json['name'], email = json['email']; Map toJson() => { 'name': name, 'email': email, }; } 现在，序列化逻辑移到了模型本身内部。采用这种新方法，我们可以非常容易地反序列化user. Map userMap = json.decode(json); var user = new User.fromJson(userMap); print('Howdy, ${user.name}!'); print('We sent the verification link to ${user.email}.'); 要序列化一个user，我们只是将该User对象传递给该json.encode方法。我们不需要手动调用toJson这个方法，因为`JSON.encode内部会自动调用。 String json = json.encode(user); 这样，调用代码就不用担心JSON序列化了，但是，Model类还是必须的。在实践中，User.fromJson和User.toJson方法都需要单元测试到位，以验证正确的行为。 另外，实际场景中，JSON对象很少会这么简单，嵌套的JSON对象并不罕见，如果有什么能为我们自动处理JSON序列化，那将会非常好。幸运的是，有！ 自动生成Model 尽管还有其他库可用，但在本书中，我们介绍一下官方推荐的json_serializable package包。 它是一个自动化的源代码生成器，可以在开发阶段为我们生成JSON序列化模板，这样一来，由于序列化代码不再由我们手写和维护，我们将运行时产生JSON序列化异常的风险降至最低。 在项目中设置json_serializable 要包含json_serializable到我们的项目中，我们需要一个常规和两个开发依赖项。简而言之，开发依赖项是不包含在我们的应用程序源代码中的依赖项，它是开发过程中的一些辅助工具、脚本，和node中的开发依赖项相似。 pubspec.yaml dependencies: # Your other regular dependencies here json_annotation: ^2.0.0 dev_dependencies: # Your other dev_dependencies here build_runner: ^1.0.0 json_serializable: ^2.0.0 在您的项目根文件夹中运行 flutter packages get (或者在编辑器中点击 “Packages Get”) 以在项目中使用这些新的依赖项. 以json_serializable的方式创建model类 让我们看看如何将我们的User类转换为一个json_serializable。为了简单起见，我们使用前面示例中的简化JSON model。 user.dart import 'package:json_annotation/json_annotation.dart'; // user.g.dart 将在我们运行生成命令后自动生成 part 'user.g.dart'; ///这个标注是告诉生成器，这个类是需要生成Model类的 @JsonSerializable() class User{ User(this.name, this.email); String name; String email; //不同的类使用不同的mixin即可 factory User.fromJson(Map json) => _$UserFromJson(json); Map toJson() => _$UserToJson(this); } 有了上面的设置，源码生成器将生成用于序列化name和email字段的JSON代码。 如果需要，自定义命名策略也很容易。例如，如果我们正在使用的API返回带有snake_case的对象，但我们想在我们的模型中使用lowerCamelCase， 那么我们可以使用@JsonKey标注： //显式关联JSON字段名与Model属性的对应关系 @JsonKey(name: 'registration_date_millis') final int registrationDateMillis; 运行代码生成程序 json_serializable第一次创建类时，您会看到与图11-4类似的错误。 这些错误是完全正常的，这是因为Model类的生成代码还不存在。为了解决这个问题，我们必须运行代码生成器来为我们生成序列化模板。有两种运行代码生成器的方法： 一次性生成 通过在我们的项目根目录下运行: flutter packages pub run build_runner build 这触发了一次性构建，我们可以在需要时为我们的Model生成json序列化代码，它通过我们的源文件，找出需要生成Model类的源文件（包含@JsonSerializable标注的）来生成对应的.g.dart文件。一个好的建议是将所有Model类放在一个单独的目录下，然后在该目录下执行命令。 虽然这非常方便，但如果我们不需要每次在Model类中进行更改时都要手动运行构建命令的话会更好。 持续生成 使用watcher可以使我们的源代码生成的过程更加方便。它会监视我们项目中文件的变化，并在需要时自动构建必要的文件，我们可以通过flutter packages pub run build_runner watch在项目根目录下运行来启动watcher。只需启动一次观察器，然后它就会在后台运行，这是安全的。 自动化生成模板 上面的方法有一个最大的问题就是要为每一个json写模板，这是比较枯燥的。如果有一个工具可以直接根据JSON文本生成模板，那我们就能彻底解放双手了。笔者自己用dart实现了一个脚本，它可以自动生成模板，并直接将JSON转为Model类，下面我们看看怎么做： 定义一个\"模板的模板\"，名为\"template.dart\"： import 'package:json_annotation/json_annotation.dart'; %t part '%s.g.dart'; @JsonSerializable() class %s { %s(); %s factory %s.fromJson(Map json) => _$%sFromJson(json); Map toJson() => _$%sToJson(this); } 模板中的“%t”、“%s”为占位符，将在脚本运行时动态被替换为合适的导入头和类名。 写一个自动生成模板的脚本(mo.dart)，它可以根据指定的JSON目录，遍历生成模板，在生成时我们定义一些规则： 如果JSON文件名以下划线“_”开始，则忽略此JSON文件。 复杂的JSON对象往往会出现嵌套，我们可以通过一个特殊标志来手动指定嵌套的对象（后面举例）。 脚本我们通过Dart来写，源码如下： import 'dart:convert'; import 'dart:io'; import 'package:path/path.dart' as path; const TAG=\"\\$\"; const SRC=\"./json\"; //JSON 目录 const DIST=\"lib/models/\"; //输出model目录 void walk() { //遍历JSON目录生成模板 var src = new Directory(SRC); var list = src.listSync(); var template=new File(\"./template.dart\").readAsStringSync(); File file; list.forEach((f) { if (FileSystemEntity.isFileSync(f.path)) { file = new File(f.path); var paths=path.basename(f.path).split(\".\"); String name=paths.first; if(paths.last.toLowerCase()!=\"json\"||name.startsWith(\"_\")) return ; if(name.startsWith(\"_\")) return; //下面生成模板 var map = json.decode(file.readAsStringSync()); //为了避免重复导入相同的包，我们用Set来保存生成的import语句。 var set= new Set(); StringBuffer attrs= new StringBuffer(); (map as Map).forEach((key, v) { if(key.startsWith(\"_\")) return ; attrs.write(getType(v,set,name)); attrs.write(\" \"); attrs.write(key); attrs.writeln(\";\"); attrs.write(\" \"); }); String className=name[0].toUpperCase()+name.substring(1); var dist=format(template,[name,className,className,attrs.toString(), className,className,className]); var _import=set.join(\";\\r\\n\"); _import+=_import.isEmpty?\"\":\";\"; dist=dist.replaceFirst(\"%t\",_import ); //将生成的模板输出 new File(\"$DIST$name.dart\").writeAsStringSync(dist); } }); } String changeFirstChar(String str, [bool upper=true] ){ return (upper?str[0].toUpperCase():str[0].toLowerCase())+str.substring(1); } //将JSON类型转为对应的dart类型 String getType(v,Set set,String current){ current=current.toLowerCase(); if(v is bool){ return \"bool\"; }else if(v is num){ return \"num\"; }else if(v is Map){ return \"Map\"; }else if(v is List){ return \"List\"; }else if(v is String){ //处理特殊标志 if(v.startsWith(\"$TAG[]\")){ var className=changeFirstChar(v.substring(3),false); if(className.toLowerCase()!=current) { set.add('import \"$className.dart\"'); } return \"List\"; }else if(v.startsWith(TAG)){ var fileName=changeFirstChar(v.substring(1),false); if(fileName.toLowerCase()!=current) { set.add('import \"$fileName.dart\"'); } return changeFirstChar(fileName); } return \"String\"; }else{ return \"String\"; } } //替换模板占位符 String format(String fmt, List params) { int matchIndex = 0; String replace(Match m) { if (matchIndex 写一个shell(mo.sh)，将生成模板和生成model串起来： dart mo.dart flutter packages pub run build_runner build --delete-conflicting-outputs 至此，我们的脚本写好了，我们在根目录下新建一个json目录，然后把user.json移进去，然后在lib目录下创建一个models目录，用于保存最终生成的Model类。现在我们只需要一句命令即可生成Model类了: ./mo.sh 运行后，一切都将自动执行，现在好多了，不是吗？ 嵌套JSON 我们定义一个person.json内容修改为： { \"name\": \"John Smith\", \"email\": \"john@example.com\", \"mother\":{ \"name\": \"Alice\", \"email\":\"alice@example.com\" }, \"friends\":[ { \"name\": \"Jack\", \"email\":\"Jack@example.com\" }, { \"name\": \"Nancy\", \"email\":\"Nancy@example.com\" } ] } 每个Person都有name 、email 、 mother和friends四个字段，由于mother也是一个Person，朋友是多个Person(数组)，所以我们期望生成的Model是下面这样： import 'package:json_annotation/json_annotation.dart'; part 'person.g.dart'; @JsonSerializable() class Person { Person(); String name; String email; Person mother; List friends; factory Person.fromJson(Map json) => _$PersonFromJson(json); Map toJson() => _$PersonToJson(this); } 这时，我们只需要简单修改一下JSON，添加一些特殊标志，重新运行mo.sh即可： { \"name\": \"John Smith\", \"email\": \"john@example.com\", \"mother\":\"$person\", \"friends\":\"$[]person\" } 我们使用美元符“$”作为特殊标志符(如果与内容冲突，可以修改mo.dart中的TAG常量，自定义标志符)，脚本在遇到特殊标志符后会先把相应字段转为相应的对象或对象数组，对象数组需要在标志符后面添加数组符“[]”，符号后面接具体的类型名，此例中是person。其它类型同理，加入我们给User添加一个Person类型的 boss字段： { \"name\": \"John Smith\", \"email\": \"john@example.com\", \"boss\":\"$person\" } 重新运行mo.sh，生成的user.dart如下： import 'package:json_annotation/json_annotation.dart'; import \"person.dart\"; part 'user.g.dart'; @JsonSerializable() class User { User(); String name; String email; Person boss; factory User.fromJson(Map json) => _$UserFromJson(json); Map toJson() => _$UserToJson(this); } 可以看到，boss字段已自动添加，并自动导入了“person.dart”。 Json_model 包 如果每个项目都要构建一个上面这样的脚本显然很麻烦，为此，我们将上面脚本和生成模板封装了一个包,已经发布到了Pub上，包名为Json_model，开发者把该包加入开发依赖后，便可以用一条命令，根据Json文件生成Dart类。另外Json_model 处于迭代中，功能会逐渐完善，所以建议读者直接使用该包（而不是手动复制上面的代码）。 使用IDE插件生成model 目前Android Studio(或IntelliJ)有几个插件，可以将json文件转成Model类，但插件质量参差不齐，甚至还有一些沾染上了抄袭风波，故笔者在此不做优先推荐，读者有兴趣可以自行了解。但是，我们还是要了解一下IDE插件和Json_model的优劣： Json_model需要单独维护一个存放Json文件的文件夹，如果有改动，只需修改Json文件便可重新生成Model类；而IDE插件一般需要用户手动将Json内容拷贝复制到一个输入框中，这样生成之后Json文件没有存档的化，之后要改动就需要手动。 Json_model可以手动指定某个字段引用的其它Model类，可以避免生成重复的类；而IDE插件一般会为每一个Json文件中所有嵌套对象都单独生成一个Model类，即使这些嵌套对象可能在其它Model类中已经生成过。 Json_model 提供了命令行转化方式，可以方便集成到CI等非UI环境的场景。 FAQ 很多人可能会问Flutter中有没有像Java开发中的Gson/Jackson一样的Json序列化类库？答案是没有！因为这样的库需要使用运行时反射，这在Flutter中是禁用的。运行时反射会干扰Dart的tree shaking，使用tree shaking，可以在release版中“去除”未使用的代码，这可以显著优化应用程序的大小。由于反射会默认应用到所有代码，因此tree shaking会很难工作，因为在启用反射时很难知道哪些代码未被使用，因此冗余代码很难剥离，所以Flutter中禁用了Dart的反射功能，而正因如此也就无法实现动态转化Model的功能。 "},"chapter12/":{"url":"chapter12/","title":"第十二章：包与插件","keywords":"","body":"包与插件 12.1：开发package 12.2：平台通道简介 12.3：开发Flutter插件 12.4：插件开发：实现Android端API 12.5：插件开发：实现IOS端API 12.6：Texture和PlatformView "},"chapter12/develop_package.html":{"url":"chapter12/develop_package.html","title":"12.1：开发package","keywords":"","body":"12.1 开发Package 第二章中已经讲过如何使用Package（包），我们知道通过package可以创建共享的模块化代码，本节将重点讲一下如何开发并发布我们自己的Package。一个最小的Package包括： 一个pubspec.yaml文件：声明了Package的名称、版本、作者等的元数据文件。 一个 lib 文件夹：包括包中公开的(public)代码，最少应有一个.dart文件 Flutter Packages分为两类： Dart包：其中一些可能包含Flutter的特定功能，因此对Flutter框架具有依赖性，这种包仅用于Flutter，例如fluro包。 插件包：一种专用的Dart包，其中包含用Dart代码编写的API，以及针对Android（使用Java或Kotlin）和针对iOS（使用OC或Swift）平台的特定实现，也就是说插件包括原生代码，一个具体的例子是battery插件包。 注意，虽然Flutter的Dart运行时和Dart VM运行时不是完全相同，但是如果Package中没有涉及这些存在差异的部分，那么这样的包可以同时支持Flutter和Dart VM，如Dart http网络库dio。 下面我将带领读者一步步来开发一个Dart Package。 第一步：创建Dart包 您可以通过Android Studio：File>New>New Flutter Project 来创建一个Package工程，如图12-1所示： 您也可以通过使用--template=package 来执行 flutter create 命令来创建： flutter create --template=package hello 这将在hello/文件夹下创建一个具有以下专用内容的package工程： lib/hello.dart：Package的Dart代码 test/hello_test.dart：Package的单元测试代码。 实现package 对于纯Dart包，只需在主lib/.dart文件内或lib目录中的文件中添加功能即可 。要测试软件包，请在test目录中添加unit tests。下面我们看看如何组织Package包的代码，我们以shelf Package为例，它的目录结构如图12-2所示： 在lib根目录下的“shelf.dart”中，导出了多个“lib/src”目录下的dart文件： export 'src/cascade.dart'; export 'src/handler.dart'; export 'src/handlers/logger.dart'; export 'src/hijack_exception.dart'; export 'src/middleware.dart'; export 'src/pipeline.dart'; export 'src/request.dart'; export 'src/response.dart'; export 'src/server.dart'; export 'src/server_handler.dart'; 而Package中主要的功能的源码都在src目录下。shelf Package也导出了一个迷你库: shelf_io，它主要是处理HttpRequest的。 导入包 当需要使用这个Package时，我们可以通过\"package:\"指令来指定包的入口文件： import 'package:utilities/utilities.dart'; 同一个包中的源码文件之间也可以使用相对路径来导入。 生成文档 可以使用 dartdoc 工具来为Package生成文档，开发者需要做的就是遵守文档注释语法在代码中添加文档注释，最后使用dartdoc可以直接生成API文档（一个静态网站）。文档注释是使用三斜线\"///\"开始，如： /// The event handler responsible for updating the badge in the UI. void updateBadge() { ... } 详细的文档语法请参考dartdoc 。 处理包的相互依赖 如果我们正在开发一个hello包，它依赖于另一个包，则需要将该依赖包添加到pubspec.yaml文件的dependencies部分。 下面的代码使url_launcher插件的API在hello包中是可用的： 在 hello/pubspec.yaml中: dependencies: url_launcher: ^0.4.2 现在可以在hello中import 'package:url_launcher/url_launcher.dart' 然后调用 launch()方法了。 这与在Flutter应用程序或任何其他Dart项目中引用软件包没有什么不同。 但是，如果hello碰巧是一个插件包，其平台特定的代码需要访问url_launcher公开的特定于平台的API，那么我们还需要为特定于平台的构建文件添加合适的依赖声明，如下所示。 Android 在 hello/android/build.gradle: android { // lines skipped dependencies { provided rootProject.findProject(\":url_launcher\") } } 您现在可以在hello/android/src源码中import io.flutter.plugins.urllauncher.UrlLauncherPlugin访问UrlLauncherPlugin类。 iOS 在hello/ios/hello.podspec: Pod::Spec.new do |s| # lines skipped s.dependency 'url_launcher' 您现在可以在hello/ios/Classes源码中 #import \"UrlLauncherPlugin.h\" 然后访问 UrlLauncherPlugin类。 解决依赖冲突 假设我们想在我们的hello包中使用some_package和other_package，并且这两个包都依赖url_launcher，但是依赖的是url_launcher的不同的版本。 那我们就有潜在的冲突。避免这种情况的最好方法是在指定依赖关系时，程序包作者使用版本范围而不是特定版本。 dependencies: url_launcher: ^0.4.2 # 这样会较好, 任何0.4.x(x >= 2)都可. image_picker: '0.1.1' # 不是很好，只有0.1.1版本. 如果some_package声明了上面的依赖关系,other_package声明了url_launcher版本像’0.4.5’或’^0.4.0’，pub将能够自动解决问题。 即使some_package和other_package声明了不兼容的url_launcher版本，它仍然可能会和url_launcher以兼容的方式正常工作。 你可以通过向hello包的pubspec.yaml文件中添加依赖性覆盖声明来处理冲突，从而强制使用特定版本： 强制使用 0.4.3版本的url_launcher，在 hello/pubspec.yaml中: dependencies: some_package: other_package: dependency_overrides: url_launcher: '0.4.3' 如果冲突的依赖不是一个包，而是一个特定于Android的库，比如guava，那么必须将依赖重写声明添加到Gradle构建逻辑中。 强制使用23.0版本的guava库，在hello/android/build.gradle中： configurations.all { resolutionStrategy { force 'com.google.guava:guava:23.0-android' } } Cocoapods目前不提供依赖覆盖功能。 发布Package 一旦实现了一个包，我们可以在Pub上发布它 ，这样其他开发者就可以轻松使用它。 在发布之前，检查pubspec.yaml、README.md以及CHANGELOG.md文件，以确保其内容的完整性和正确性。然后，运行 dry-run 命令以查看是否都准备OK了: flutter packages pub publish --dry-run 验证无误后，我们就可以运行发布命令了： flutter packages pub publish 如果你遇到包发布失败的情况，先检查是否因为众所周知的网络原因，如果是网络问题，可以使用VPN，这里需要注意的是一些代理只会代理部分APP的网络请求，如浏览器的，它们可能并不能代理dart的网络请求，所以在这种情况下，即使开了代理也依然无法连接到Pub，因此，在发布Pub包时使用全局代理或全局VPN会保险些。如果网络没有问题，以管理员权限(sudo)运行发布命令重试。 "},"chapter12/platform-channel.html":{"url":"chapter12/platform-channel.html","title":"12.2：平台通道简介","keywords":"","body":"12.2 插件开发：平台通道简介 “平台特定”或“特定平台”中的平台指的就是Flutter应用程序运行的平台，如Android或IOS。我们知道一个完整的Flutter应用程序实际上包括原生代码和Flutter代码两部分。由于Flutter本身只是一个UI系统，它本身是无法提供一些系统能力，比如使用蓝牙、相机、GPS等，因此要在Flutter APP中调用这些能力就必须和原生平台进行通信。为此，Flutter中提供了一个平台通道（platform channel），用于Flutter和原生平台的通信。平台通道正是Flutter和原生之间通信的桥梁，它也是Flutter插件的底层基础设施。 Flutter使用了一个灵活的系统，允许您调用特定平台的API，无论在Android上的Java或Kotlin代码中，还是iOS上的ObjectiveC或Swift代码中均可用。 Flutter与原生之间的通信依赖灵活的消息传递方式： 应用的Flutter部分通过平台通道（platform channel）将消息发送到其应用程序的所在的宿主（iOS或Android）应用（原生应用）。 宿主监听平台通道，并接收该消息。然后它会调用该平台的API，并将响应发送回客户端，即应用程序的Flutter部分。 平台通道 使用平台通道在Flutter(client)和原生(host)之间传递消息，如下图所示： 当在Flutter中调用原生方法时，调用信息通过平台通道传递到原生，原生收到调用信息后方可执行指定的操作，如需返回数据，则原生会将数据再通过平台通道传递给Flutter。值得注意的是消息传递是异步的，这确保了用户界面在消息传递时不会被挂起。 在客户端，MethodChannel API 可以发送与方法调用相对应的消息。 在宿主平台上，MethodChannel 在Android API 和 FlutterMethodChannel iOS API可以接收方法调用并返回结果。这些类可以帮助我们用很少的代码就能开发平台插件。 注意: 如果需要，方法调用(消息传递)可以是反向的，即宿主作为客户端调用Dart中实现的API。 quick_actions插件就是一个具体的例子。 平台通道数据类型支持 平台通道使用标准消息编/解码器对消息进行编解码，它可以高效的对消息进行二进制序列化与反序列化。由于Dart与原生平台之间数据类型有所差异，下面我们列出数据类型之间的映射关系。 Dart Android iOS null null nil (NSNull when nested) bool java.lang.Boolean NSNumber numberWithBool: int java.lang.Integer NSNumber numberWithInt: int, 如果不足32位 java.lang.Long NSNumber numberWithLong: int, 如果不足64位 java.math.BigInteger FlutterStandardBigInteger double java.lang.Double NSNumber numberWithDouble: String java.lang.String NSString Uint8List byte[] FlutterStandardTypedData typedDataWithBytes: Int32List int[] FlutterStandardTypedData typedDataWithInt32: Int64List long[] FlutterStandardTypedData typedDataWithInt64: Float64List double[] FlutterStandardTypedData typedDataWithFloat64: List java.util.ArrayList NSArray Map java.util.HashMap NSDictionary 当在发送和接收值时，这些值在消息中的序列化和反序列化会自动进行。 自定义编解码器 除了上面提到的MethodChannel，还可以使用BasicMessageChannel，它支持使用自定义消息编解码器进行基本的异步消息传递。 此外，可以使用专门的BinaryCodec、StringCodec和 JSONMessageCodec类，或创建自己的编解码器。 如何获取平台信息 Flutter 中提供了一个全局变量defaultTargetPlatform来获取当前应用的平台信息，defaultTargetPlatform定义在\"platform.dart\"中，它的类型是TargetPlatform，这是一个枚举类，定义如下： enum TargetPlatform { android, fuchsia, iOS, } 可以看到目前Flutter只支持这三个平台。我们可以通过如下代码判断平台： if(defaultTargetPlatform==TargetPlatform.android){ // 是安卓系统，do something ... } ... 由于不同平台有它们各自的交互规范，Flutter Material库中的一些组件都针对相应的平台做了一些适配，比如路由组件MaterialPageRoute，它在android和ios中会应用各自平台规范的切换动画。那如果我们想让我们的APP在所有平台都表现一致，比如希望在所有平台路由切换动画都按照ios平台一致的左右滑动切换风格该怎么做？Flutter中提供了一种覆盖默认平台的机制，我们可以通过显式指定debugDefaultTargetPlatformOverride全局变量的值来指定应用平台。比如： debugDefaultTargetPlatformOverride=TargetPlatform.iOS; print(defaultTargetPlatform); // 会输出TargetPlatform.iOS 上面代码即在Android中运行后，Flutter APP就会认为是当前系统是iOS，Material组件库中所有组件交互方式都会和iOS平台对齐，defaultTargetPlatform的值也会变为TargetPlatform.iOS。 "},"chapter12/develop_plugin.html":{"url":"chapter12/develop_plugin.html","title":"12.3：开发Flutter插件","keywords":"","body":"12.3 开发Flutter插件 下面我们通过一个获取电池电量的插件来介绍一下Flutter插件的开发流程。该插件中我们在Dart中通过getBatteryLevel 调用Android BatteryManager API和iOS device.batteryLevel API。 创建一个新的应用程序项目 首先创建一个新的应用程序: 在终端中运行：flutter create batterylevel 默认情况下，模板支持使用Java编写Android代码，或使用Objective-C编写iOS代码。要使用Kotlin或Swift，请使用-i和/或-a标志: 在终端中运行: flutter create -i swift -a kotlin batterylevel 创建Flutter平台客户端 该应用的State类拥有当前的应用状态。我们需要延长这一点以保持当前的电量 首先，我们构建通道。我们使用MethodChannel调用一个方法来返回电池电量。 通道的客户端和宿主通过通道构造函数中传递的通道名称进行连接。单个应用中使用的所有通道名称必须是唯一的; 我们建议在通道名称前加一个唯一的“域名前缀”，例如samples.flutter.io/battery。 import 'dart:async'; import 'package:flutter/material.dart'; import 'package:flutter/services.dart'; ... class _MyHomePageState extends State { static const platform = const MethodChannel('samples.flutter.io/battery'); // Get battery level. } 接下来，我们调用通道上的方法，指定通过字符串标识符调用方法getBatteryLevel。 该调用可能失败(平台不支持平台API，例如在模拟器中运行时)，所以我们将invokeMethod调用包装在try-catch语句中。 我们使用返回的结果，在setState中来更新用户界面状态batteryLevel。 // Get battery level. String _batteryLevel = 'Unknown battery level.'; Future _getBatteryLevel() async { String batteryLevel; try { final int result = await platform.invokeMethod('getBatteryLevel'); batteryLevel = 'Battery level at $result % .'; } on PlatformException catch (e) { batteryLevel = \"Failed to get battery level: '${e.message}'.\"; } setState(() { _batteryLevel = batteryLevel; }); } 最后，我们在build创建包含一个小字体显示电池状态和一个用于刷新值的按钮的用户界面。 @override Widget build(BuildContext context) { return new Material( child: new Center( child: new Column( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ new RaisedButton( child: new Text('Get Battery Level'), onPressed: _getBatteryLevel, ), new Text(_batteryLevel), ], ), ), ); } 至此Flutter部分的测试代码写好了，接下来我们需要实现Android和iOS平台下的API，由于平台API实现部分篇幅较大，我们将在接下来的两节中，分别介绍Android和iOS端API的实现。 "},"chapter12/android_implement.html":{"url":"chapter12/android_implement.html","title":"12.4：插件开发：实现Android端API","keywords":"","body":"12.4 插件开发：Android端API实现 本节我们接着上一节\"获取电池电量\"插件的示例，来完成Android端API的实现。以下步骤是使用Java的示例，如果您更喜欢Kotlin，可以直接跳到后面Kotlin部分。 首先在Android Studio中打开您的Flutter应用的Android部分： 启动 Android Studio 选择 File > Open… 定位到您 Flutter app目录, 然后选择里面的 android文件夹，点击 OK 在java目录下打开 MainActivity.java 接下来，在onCreate里创建MethodChannel并设置一个MethodCallHandler。确保使用和Flutter客户端中使用的通道名称相同的名称。 import io.flutter.app.FlutterActivity; import io.flutter.plugin.common.MethodCall; import io.flutter.plugin.common.MethodChannel; import io.flutter.plugin.common.MethodChannel.MethodCallHandler; import io.flutter.plugin.common.MethodChannel.Result; public class MainActivity extends FlutterActivity { private static final String CHANNEL = \"samples.flutter.io/battery\"; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); new MethodChannel(getFlutterView(), CHANNEL).setMethodCallHandler( new MethodCallHandler() { @Override public void onMethodCall(MethodCall call, Result result) { // TODO } }); } } 接下来，我们添加Java代码，使用Android电池API来获取电池电量。此代码和在原生Android应用中编写的代码完全相同。 首先，添加需要导入的依赖。 import android.content.ContextWrapper; import android.content.Intent; import android.content.IntentFilter; import android.os.BatteryManager; import android.os.Build.VERSION; import android.os.Build.VERSION_CODES; import android.os.Bundle; 然后，将下面的新方法添加到activity类中的，位于onCreate 方法下方： private int getBatteryLevel() { int batteryLevel = -1; if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) { BatteryManager batteryManager = (BatteryManager) getSystemService(BATTERY_SERVICE); batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY); } else { Intent intent = new ContextWrapper(getApplicationContext()). registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED)); batteryLevel = (intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100) / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1); } return batteryLevel; } 最后，我们完成之前添加的onMethodCall方法。我们需要处理平台方法名为getBatteryLevel的调用消息，所以我们需要先在call参数判断调用的方法是否为getBatteryLevel。 这个平台方法的实现只需调用我们在前一步中编写的Android代码，并通过result参数返回成功或错误情况的响应信息。如果调用了未定义的API，我们也会通知返回： @Override public void onMethodCall(MethodCall call, Result result) { if (call.method.equals(\"getBatteryLevel\")) { int batteryLevel = getBatteryLevel(); if (batteryLevel != -1) { result.success(batteryLevel); } else { result.error(\"UNAVAILABLE\", \"Battery level not available.\", null); } } else { result.notImplemented(); } } 现在就可以在Android上运行该应用程序了，如果使用的是Android模拟器，则可以通过工具栏中的\"...\"按钮访问Extended Controls面板中的电池电量。 使用Kotlin添加Android平台特定的实现 使用Kotlin和使用Java的步骤类似，首先在Android Studio中打开您的Flutter应用的Android部分： 启动 Android Studio。 选择 the menu item \"File > Open…\"。 定位到 Flutter app目录, 然后选择里面的 android文件夹，点击 OK。 在kotlin目录中打开MainActivity.kt。 接下来，在onCreate里创建MethodChannel并设置一个MethodCallHandler。确保使用与在Flutter客户端使用的通道名称相同。 import android.os.Bundle import io.flutter.app.FlutterActivity import io.flutter.plugin.common.MethodChannel import io.flutter.plugins.GeneratedPluginRegistrant class MainActivity() : FlutterActivity() { private val CHANNEL = \"samples.flutter.io/battery\" override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) GeneratedPluginRegistrant.registerWith(this) MethodChannel(flutterView, CHANNEL).setMethodCallHandler { call, result -> // TODO } } } 接下来，我们添加Kotlin代码，使用Android电池API来获取电池电量，这和原生开发是一样的。 首先，添加需要导入的依赖。 import android.content.Context import android.content.ContextWrapper import android.content.Intent import android.content.IntentFilter import android.os.BatteryManager import android.os.Build.VERSION import android.os.Build.VERSION_CODES 然后，将下面的新方法添加到activity类中的，位于onCreate 方法下方： private fun getBatteryLevel(): Int { val batteryLevel: Int if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) { val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY) } else { val intent = ContextWrapper(applicationContext).registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED)) batteryLevel = intent!!.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100 / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1) } return batteryLevel } 最后，我们完成之前添加的onMethodCall方法。我们需要处理平台方法名为getBatteryLevel的调用消息，所以我们需要先在call参数判断调用的方法是否为getBatteryLevel。 这个平台方法的实现只需调用我们在前一步中编写的Android代码，并通过result参数返回成功或错误情况的响应信息。如果调用了未定义的API，我们也会通知返回： ​ MethodChannel(flutterView, CHANNEL).setMethodCallHandler { call, result -> if (call.method == \"getBatteryLevel\") { val batteryLevel = getBatteryLevel() if (batteryLevel != -1) { result.success(batteryLevel) } else { result.error(\"UNAVAILABLE\", \"Battery level not available.\", null) } } else { result.notImplemented() } } 您现在就可以在Android上运行该应用程序。如果您使用的是Android模拟器，则可以通过工具栏中的\"...\"按钮访问Extended Controls面板中的电池电量。 "},"chapter12/ios_implement.html":{"url":"chapter12/ios_implement.html","title":"12.5：插件开发：实现IOS端API","keywords":"","body":"12.5 插件开发：iOS端API实现 本节我们接着之前\"获取电池电量\"插件的示例，来完成iOS端API的实现。以下步骤使用Objective-C，如果您更喜欢Swift，可以直接跳到后面Swift部分。 首先打开Xcode中Flutter应用程序的iOS部分: 启动 Xcode 选择 File > Open… 定位到您 Flutter app目录, 然后选择里面的 iOS文件夹，点击 OK 确保Xcode项目的构建没有错误。 选择 Runner > Runner ，打开AppDelegate.m 接下来，在application didFinishLaunchingWithOptions:方法内部创建一个FlutterMethodChannel，并添加一个处理方法。 确保与在Flutter客户端使用的通道名称相同。 #import @implementation AppDelegate - (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions { FlutterViewController* controller = (FlutterViewController*)self.window.rootViewController; FlutterMethodChannel* batteryChannel = [FlutterMethodChannel methodChannelWithName:@\"samples.flutter.io/battery\" binaryMessenger:controller]; [batteryChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) { // TODO }]; return [super application:application didFinishLaunchingWithOptions:launchOptions]; } 接下来，我们添加Objective-C代码，使用iOS电池API来获取电池电量，这和原生是相同的。 在AppDelegate类中添加以下新的方法： - (int)getBatteryLevel { UIDevice* device = UIDevice.currentDevice; device.batteryMonitoringEnabled = YES; if (device.batteryState == UIDeviceBatteryStateUnknown) { return -1; } else { return (int)(device.batteryLevel * 100); } } 最后，我们完成之前添加的setMethodCallHandler方法。我们需要处理的平台方法名为getBatteryLevel，所以我们在call参数中需要先判断是否为getBatteryLevel。 这个平台方法的实现只需调用我们在前一步中编写的iOS代码，并使用result参数返回成功或错误的响应。如果调用了未定义的API，我们也会通知返回： [batteryChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) { if ([@\"getBatteryLevel\" isEqualToString:call.method]) { int batteryLevel = [self getBatteryLevel]; if (batteryLevel == -1) { result([FlutterError errorWithCode:@\"UNAVAILABLE\" message:@\"电池信息不可用\" details:nil]); } else { result(@(batteryLevel)); } } else { result(FlutterMethodNotImplemented); } }]; 现在可以在iOS上运行该应用程序了，如果使用的是iOS模拟器，请注意，它不支持电池API，因此应用程序将显示“电池信息不可用”。 使用Swift实现iOS API 以下步骤与上面使用Objective-C相似，首先打开Xcode中Flutter应用程序的iOS部分: 启动 Xcode 选择 File > Open… 定位到您 Flutter app目录, 然后选择里面的 ios文件夹，点击 OK 确保Xcode项目的构建没有错误。 选择 Runner > Runner ，然后打开AppDelegate.swift 接下来，覆盖application方法并创建一个FlutterMethodChannel绑定通道名称samples.flutter.io/battery： @UIApplicationMain @objc class AppDelegate: FlutterAppDelegate { override func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { GeneratedPluginRegistrant.register(with: self); let controller : FlutterViewController = window?.rootViewController as! FlutterViewController; let batteryChannel = FlutterMethodChannel.init(name: \"samples.flutter.io/battery\", binaryMessenger: controller); batteryChannel.setMethodCallHandler({ (call: FlutterMethodCall, result: FlutterResult) -> Void in // Handle battery messages. }); return super.application(application, didFinishLaunchingWithOptions: launchOptions); } } 接下来，我们添加Swift代码，使用iOS电池API来获取电池电量，这和原生开发是相同的。 将以下新方法添加到AppDelegate.swift底部: private func receiveBatteryLevel(result: FlutterResult) { let device = UIDevice.current; device.isBatteryMonitoringEnabled = true; if (device.batteryState == UIDeviceBatteryState.unknown) { result(FlutterError.init(code: \"UNAVAILABLE\", message: \"电池信息不可用\", details: nil)); } else { result(Int(device.batteryLevel * 100)); } } 最后，我们完成之前添加的setMethodCallHandler方法。我们需要处理的平台方法名为getBatteryLevel，所以我们在call参数中需要先判断是否为getBatteryLevel。 这个平台方法的实现只需调用我们在前一步中编写的iOS代码，并使用result参数返回成功或错误的响应。如果调用了未定义的API，我们也会通知返回： batteryChannel.setMethodCallHandler({ (call: FlutterMethodCall, result: FlutterResult) -> Void in if (\"getBatteryLevel\" == call.method) { receiveBatteryLevel(result: result); } else { result(FlutterMethodNotImplemented); } }); 现在可以在iOS上运行应用程序，如果使用的是iOS模拟器，请注意，它不支持电池API，因此应用程序将显示“电池信息不可用”。 "},"chapter12/texture_platformview.html":{"url":"chapter12/texture_platformview.html","title":"12.6：Texture和PlatformView","keywords":"","body":"12.6 Texture和PlatformView 本节主要介绍原生和Flutter之间如何共享图像，以及如何在Flutter中嵌套原生组件。 12.6.1 Texture（示例：使用摄像头） 前面说过Flutter本身只是一个UI系统，对于一些系统能力的调用我们可以通过消息传送机制与原生交互。但是这种消息传送机制并不能覆盖所有的应用场景，比如我们想调用摄像头来拍照或录视频，但在拍照和录视频的过程中我们需要将预览画面显示到我们的Flutter UI中，如果我们要用Flutter定义的消息通道机制来实现这个功能，就需要将摄像头采集的每一帧图片都要从原生传递到Flutter中，这样做代价将会非常大，因为将图像或视频数据通过消息通道实时传输必然会引起内存和CPU的巨大消耗！为此，Flutter提供了一种基于Texture的图片数据共享机制。 Texture可以理解为GPU内保存将要绘制的图像数据的一个对象，Flutter engine会将Texture的数据在内存中直接进行映射（而无需在原生和Flutter之间再进行数据传递），Flutter会给每一个Texture分配一个id，同时Flutter中提供了一个Texture组件，Texture构造函数定义如下： const Texture({ Key key, @required this.textureId, }) Texture 组件正是通过textureId与Texture数据关联起来；在Texture组件绘制时，Flutter会自动从内存中找到相应id的Texture数据，然后进行绘制。可以总结一下整个流程：图像数据先在原生部分缓存，然后在Flutter部分再通过textureId和缓存关联起来，最后绘制由Flutter完成。 如果我们作为一个插件开发者，我们在原生代码中分配了textureId，那么在Flutter侧使用Texture组件时要如何获取textureId呢？这又回到了之前的内容了，textureId完全可以通过MethodChannel来传递。 另外，值得注意的是，当原生摄像头捕获的图像发生变化时，Texture 组件会自动重绘，这不需要我们写任何Dart 代码去控制。 Texture用法 如果我们要手动实现一个相机插件，和前面几节介绍的“获取剩余电量”插件的步骤一样，需要分别实现原生部分和Flutter部分。考虑到大多数读者可能并非同时既了解Android开发，又了解iOS开发，如果我们再花大量篇幅来介绍不同端的实现可能会没什么意义，另外，由于Flutter官方提供的相机（camera）插件和视频播放（video_player）插件都是使用Texture来实现的，它们本身就是Texture非常好的示例，所以在本书中将不会再介绍使用Texture的具体流程了，读者有兴趣查看camera和video_player的实现代码。下面我们重点介绍一下如何使用camera和video_player。 相机示例 下面我们看一下camera包自带的一个示例，它包含如下功能： 可以拍照，也可以拍视频，拍摄完成后可以保存；排号的视频可以播放预览。 可以切换摄像头（前置摄像头、后置摄像头、其它） 可以显示已经拍摄内容的预览图。 下面我们看一下具体代码： 首先，依赖camera插件的最新版，并下载依赖。 dependencies: ... //省略无关代码 camera: ^0.5.2+2 在main方法中获取可用摄像头列表。 void main() async { // 获取可用摄像头列表，cameras为全局变量 cameras = await availableCameras(); runApp(MyApp()); } 构建UI。现在我们构建如图12-4的测试界面： 线面是完整的代码： import 'package:camera/camera.dart'; import 'package:flutter/material.dart'; import '../common.dart'; import 'dart:async'; import 'dart:io'; import 'package:path_provider/path_provider.dart'; import 'package:video_player/video_player.dart'; //用于播放录制的视频 /// 获取不同摄像头的图标（前置、后置、其它） IconData getCameraLensIcon(CameraLensDirection direction) { switch (direction) { case CameraLensDirection.back: return Icons.camera_rear; case CameraLensDirection.front: return Icons.camera_front; case CameraLensDirection.external: return Icons.camera; } throw ArgumentError('Unknown lens direction'); } void logError(String code, String message) => print('Error: $code\\nError Message: $message'); // 示例页面路由 class CameraExampleHome extends StatefulWidget { @override _CameraExampleHomeState createState() { return _CameraExampleHomeState(); } } class _CameraExampleHomeState extends State with WidgetsBindingObserver { CameraController controller; String imagePath; // 图片保存路径 String videoPath; //视频保存路径 VideoPlayerController videoController; VoidCallback videoPlayerListener; bool enableAudio = true; @override void initState() { super.initState(); // 监听APP状态改变，是否在前台 WidgetsBinding.instance.addObserver(this); } @override void dispose() { WidgetsBinding.instance.removeObserver(this); super.dispose(); } @override void didChangeAppLifecycleState(AppLifecycleState state) { // 如果APP不在在前台 if (state == AppLifecycleState.inactive) { controller?.dispose(); } else if (state == AppLifecycleState.resumed) { // 在前台 if (controller != null) { onNewCameraSelected(controller.description); } } } final GlobalKey _scaffoldKey = GlobalKey(); @override Widget build(BuildContext context) { return Scaffold( key: _scaffoldKey, appBar: AppBar( title: const Text('相机示例'), ), body: Column( children: [ Expanded( child: Container( child: Padding( padding: const EdgeInsets.all(1.0), child: Center( child: _cameraPreviewWidget(), ), ), decoration: BoxDecoration( color: Colors.black, border: Border.all( color: controller != null && controller.value.isRecordingVideo ? Colors.redAccent : Colors.grey, width: 3.0, ), ), ), ), _captureControlRowWidget(), _toggleAudioWidget(), Padding( padding: const EdgeInsets.all(5.0), child: Row( mainAxisAlignment: MainAxisAlignment.start, children: [ _cameraTogglesRowWidget(), _thumbnailWidget(), ], ), ), ], ), ); } /// 展示预览窗口 Widget _cameraPreviewWidget() { if (controller == null || !controller.value.isInitialized) { return const Text( '选择一个摄像头', style: TextStyle( color: Colors.white, fontSize: 24.0, fontWeight: FontWeight.w900, ), ); } else { return AspectRatio( aspectRatio: controller.value.aspectRatio, child: CameraPreview(controller), ); } } /// 开启或关闭录音 Widget _toggleAudioWidget() { return Padding( padding: const EdgeInsets.only(left: 25), child: Row( children: [ const Text('开启录音:'), Switch( value: enableAudio, onChanged: (bool value) { enableAudio = value; if (controller != null) { onNewCameraSelected(controller.description); } }, ), ], ), ); } /// 显示已拍摄的图片/视频缩略图。 Widget _thumbnailWidget() { return Expanded( child: Align( alignment: Alignment.centerRight, child: Row( mainAxisSize: MainAxisSize.min, children: [ videoController == null && imagePath == null ? Container() : SizedBox( child: (videoController == null) ? Image.file(File(imagePath)) : Container( child: Center( child: AspectRatio( aspectRatio: videoController.value.size != null ? videoController.value.aspectRatio : 1.0, child: VideoPlayer(videoController)), ), decoration: BoxDecoration( border: Border.all(color: Colors.pink)), ), width: 64.0, height: 64.0, ), ], ), ), ); } /// 相机工具栏 Widget _captureControlRowWidget() { return Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, mainAxisSize: MainAxisSize.max, children: [ IconButton( icon: const Icon(Icons.camera_alt), color: Colors.blue, onPressed: controller != null && controller.value.isInitialized && !controller.value.isRecordingVideo ? onTakePictureButtonPressed : null, ), IconButton( icon: const Icon(Icons.videocam), color: Colors.blue, onPressed: controller != null && controller.value.isInitialized && !controller.value.isRecordingVideo ? onVideoRecordButtonPressed : null, ), IconButton( icon: const Icon(Icons.stop), color: Colors.red, onPressed: controller != null && controller.value.isInitialized && controller.value.isRecordingVideo ? onStopButtonPressed : null, ) ], ); } /// 展示所有摄像头 Widget _cameraTogglesRowWidget() { final List toggles = []; if (cameras.isEmpty) { return const Text('没有检测到摄像头'); } else { for (CameraDescription cameraDescription in cameras) { toggles.add( SizedBox( width: 90.0, child: RadioListTile( title: Icon(getCameraLensIcon(cameraDescription.lensDirection)), groupValue: controller?.description, value: cameraDescription, onChanged: controller != null && controller.value.isRecordingVideo ? null : onNewCameraSelected, ), ), ); } } return Row(children: toggles); } String timestamp() => DateTime.now().millisecondsSinceEpoch.toString(); void showInSnackBar(String message) { _scaffoldKey.currentState.showSnackBar(SnackBar(content: Text(message))); } // 摄像头选中回调 void onNewCameraSelected(CameraDescription cameraDescription) async { if (controller != null) { await controller.dispose(); } controller = CameraController( cameraDescription, ResolutionPreset.high, enableAudio: enableAudio, ); controller.addListener(() { if (mounted) setState(() {}); if (controller.value.hasError) { showInSnackBar('Camera error ${controller.value.errorDescription}'); } }); try { await controller.initialize(); } on CameraException catch (e) { _showCameraException(e); } if (mounted) { setState(() {}); } } // 拍照按钮点击回调 void onTakePictureButtonPressed() { takePicture().then((String filePath) { if (mounted) { setState(() { imagePath = filePath; videoController?.dispose(); videoController = null; }); if (filePath != null) showInSnackBar('图片保存在 $filePath'); } }); } // 开始录制视频 void onVideoRecordButtonPressed() { startVideoRecording().then((String filePath) { if (mounted) setState(() {}); if (filePath != null) showInSnackBar('正在保存视频于 $filePath'); }); } // 终止视频录制 void onStopButtonPressed() { stopVideoRecording().then((_) { if (mounted) setState(() {}); showInSnackBar('视频保存在: $videoPath'); }); } Future startVideoRecording() async { if (!controller.value.isInitialized) { showInSnackBar('请先选择一个摄像头'); return null; } // 确定视频保存的路径 final Directory extDir = await getApplicationDocumentsDirectory(); final String dirPath = '${extDir.path}/Movies/flutter_test'; await Directory(dirPath).create(recursive: true); final String filePath = '$dirPath/${timestamp()}.mp4'; if (controller.value.isRecordingVideo) { // 如果正在录制，则直接返回 return null; } try { videoPath = filePath; await controller.startVideoRecording(filePath); } on CameraException catch (e) { _showCameraException(e); return null; } return filePath; } Future stopVideoRecording() async { if (!controller.value.isRecordingVideo) { return null; } try { await controller.stopVideoRecording(); } on CameraException catch (e) { _showCameraException(e); return null; } await _startVideoPlayer(); } Future _startVideoPlayer() async { final VideoPlayerController vcontroller = VideoPlayerController.file(File(videoPath)); videoPlayerListener = () { if (videoController != null && videoController.value.size != null) { // Refreshing the state to update video player with the correct ratio. if (mounted) setState(() {}); videoController.removeListener(videoPlayerListener); } }; vcontroller.addListener(videoPlayerListener); await vcontroller.setLooping(true); await vcontroller.initialize(); await videoController?.dispose(); if (mounted) { setState(() { imagePath = null; videoController = vcontroller; }); } await vcontroller.play(); } Future takePicture() async { if (!controller.value.isInitialized) { showInSnackBar('错误: 请先选择一个相机'); return null; } final Directory extDir = await getApplicationDocumentsDirectory(); final String dirPath = '${extDir.path}/Pictures/flutter_test'; await Directory(dirPath).create(recursive: true); final String filePath = '$dirPath/${timestamp()}.jpg'; if (controller.value.isTakingPicture) { // A capture is already pending, do nothing. return null; } try { await controller.takePicture(filePath); } on CameraException catch (e) { _showCameraException(e); return null; } return filePath; } void _showCameraException(CameraException e) { logError(e.code, e.description); showInSnackBar('Error: ${e.code}\\n${e.description}'); } } 如果代码运行遇到困难，请直接查看camera官方文档。 12.6.2 PlatformView （示例：WebView） 如果我们在开发过程中需要使用一个原生组件，但这个原生组件在Flutter中很难实现时怎么办（如webview）？这时一个简单的方法就是将需要使用原生组件的页面全部用原生实现，在flutter中需要打开该页面时通过消息通道打开这个原生的页面。但是这种方法有一个最大的缺点，就是原生组件很难和Flutter组件进行组合。 在 Flutter 1.0版本中，Flutter SDK中新增了AndroidView和UIKitView 两个组件，这两个组件的主要功能就是将原生的Android组件和iOS组件嵌入到Flutter的组件树中，这个功能是非常重要的，尤其是对一些实现非常复杂的组件，比如webview，这些组件原生已经有了，如果Flutter中要用，重新实现的话成本将非常高，所以如果有一种机制能让Flutter共享原生组件，这将会非常有用，也正因如此，Flutter才提供了这两个组件。 由于AndroidView和UIKitView 是和具体平台相关的，所以称它们为PlatformView。需要说明的是将来Flutter支持的平台可能会增多，则相应的PlatformView也将会变多。那么如何使用Platform View呢？我们以Flutter官方提供的webview_flutter插件为例： 注意，在本书写作之时，webview_flutter仍处于预览阶段，如您想在项目中使用它，请查看一下webview_flutter插件最新版本及动态。 原生代码中注册要被Flutter嵌入的组件工厂，如webview_flutter插件中Android端注册webview插件代码： public static void registerWith(Registrar registrar) { registrar.platformViewRegistry().registerViewFactory(\"webview\", WebViewFactory(registrar.messenger())); } WebViewFactory的具体实现请参考webview_flutter插件的实现源码，在此不再赘述。 在Flutter中使用；打开Flutter中文社区首页。 class PlatformViewRoute extends StatelessWidget { @override Widget build(BuildContext context) { return WebView( initialUrl: \"https://flutterchina.club\", javascriptMode: JavascriptMode.unrestricted, ); } } 运行效果如图12-5所示： 注意，使用PlatformView的开销是非常大的，因此，如果一个原生组件用Flutter实现的难度不大时，我们应该首选Flutter实现。 另外，PlatformView的相关功能在作者写作时还处于预览阶段，可能还会发生变化，因此，读者如果需要在项目中使用的话，应查看一下最新的文档。 "},"chapter13/":{"url":"chapter13/","title":"第十三章：国际化","keywords":"","body":"本章目录 13.1：让App支持多语言 13.2：实现Localizations 13.3：使用Intl包 13.4：国际化常见问题 "},"chapter13/multi_languages_support.html":{"url":"chapter13/multi_languages_support.html","title":"13.1：让App支持多语言","keywords":"","body":"13.1 让App支持多语言 如果我们的应用要支持多种语言，那么我们需要“国际化”它。这意味着我们在开发时需要为应用程序支持的每种语言环境设置“本地化”的一些值，如文本和布局。Flutter SDK已经提供了一些组件和类来帮助我们实现国际化，下面我们来介绍一下Flutter中实现国际化的步骤。 接下来我们以MaterialApp类为入口的应用来说明如何支持国际化。 大多数应用程序都是通过MaterialApp为入口，但根据低级别的WidgetsApp类为入口编写的应用程序也可以使用相同的类和逻辑进行国际化。MaterialApp实际上也是WidgetsApp的一个包装。 注意，”本地化的值和资源“是指我们针对不同语言准备的不同资源，这些资源一般是指文案（字符串），当然也会有一些其他的资源会根据不同语言地区而不同，比如我们需要显示一个APP上架地的国旗图片，那么不同Locale区域我们就需要提供不同的的国旗图片。 支持国际化 默认情况下，Flutter SDK中的组件仅提供美国英语本地化资源（主要是文本）。要添加对其他语言的支持，应用程序须添加一个名为“flutter_localizations”的包依赖，然后还需要在MaterialApp中进行一些配置。 要使用flutter_localizations包，首先需要添加依赖到pubspec.yaml文件中： dependencies: flutter: sdk: flutter flutter_localizations: sdk: flutter 接下来，下载flutter_localizations库，然后指定MaterialApp的localizationsDelegates和supportedLocales： import 'package:flutter_localizations/flutter_localizations.dart'; new MaterialApp( localizationsDelegates: [ // 本地化的代理类 GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [ const Locale('en', 'US'), // 美国英语 const Locale('zh', 'CN'), // 中文简体 //其它Locales ], // ... ) 基于WidgetsApp的应用程序类似，只是不需要GlobalMaterialLocalizations.delegate。 localizationsDelegates列表中的元素是生成本地化值集合的工厂。GlobalMaterialLocalizations.delegate 为Material 组件库提供的本地化的字符串和其他值，它可以使Material 组件支持多语言。 GlobalWidgetsLocalizations.delegate定义组件默认的文本方向，从左到右或从右到左，这是因为有些语言的阅读习惯并不是从左到右，比如如阿拉伯语就是从右向左的。 supportedLocales也接收一个Locale数组，表示我们的应用支持的语言列表，在本例中我们的应用只支持美国英语和中文简体两种语言。 获取当前区域Locale Locale类是用来标识用户的语言环境的，它包括语言和国家两个标志如： const Locale('zh', 'CN') // 中文简体 我们始终可以通过以下方式来获取应用的当前区域Locale： Locale myLocale = Localizations.localeOf(context); Localizations 组件一般位于widget树中其它业务组件的顶部，它的作用是定义区域Locale以及设置子树依赖的本地化资源。 如果系统的语言环境发生变化，WidgetsApp将创建一个新的Localizations 组件并重建它，这样子树中通过Localizations.localeOf(context) 获取的Locale就会更新。 监听系统语言切换 当我们更改系统语言设置时，APP中的Localizations组件会重新构建，Localizations.localeOf(context) 获取的Locale就会更新，最终界面会重新build达到切换语言的效果。但是这个过程是隐式完成的，我们并没有主动去监听系统语言切换，但是有时我们需要在系统语言发生改变时做一些事，比如系统语言切换为一种我们APP不支持的语言时，我们需要设置一个默认的语言，这时我们就需要监听locale改变事件。 我们可以通过localeResolutionCallback或localeListResolutionCallback回调来监听locale改变的事件，我们先看看localeResolutionCallback的回调函数签名： Locale Function(Locale locale, Iterable supportedLocales) 参数locale的值为当前的当前的系统语言设置，当应用启动时或用户动态改变系统语言设置时此locale即为系统的当前locale。当开发者手动指定APP的locale时，那么此locale参数代表开发者指定的locale，此时将忽略系统locale如： MaterialApp( ... locale: const Locale('en', 'US'), //手动指定locale ... ) 上面的例子中手动指定了应用locale为美国英语，指定后即使设备当前语言是中文简体，应用中的locale也依然是美国英语。如果locale为null，则表示Flutter未能获取到设备的Locale信息，所以我们在使用locale之前一定要先判空。 supportedLocales 为当前应用支持的locale列表，是开发者在MaterialApp中通过supportedLocales属性注册的。 返回值是一个Locale，此Locale为Flutter APP最终使用的Locale。通常在不支持的语言区域时返回一个默认的Locale。 localeListResolutionCallback和localeResolutionCallback唯一的不同就在第一个参数类型，前者接收的是一个Locale列表，而后者接收的是单个Locale。 Locale Function(List locales, Iterable supportedLocales) 在较新的Android系统中，用户可以设置一个语言列表，这样一来，支持多语言的应用就会得到这个列表，应用通常的处理方式就是按照列表的顺序依次尝试加载相应的Locale，如果某一种语言加载成功则会停止。图13-1是Android系统中设置语言列表的截图： 在Flutter中，应该优先使用localeListResolutionCallback，当然你不必担心Android系统的差异性，如果在低版本的Android系统中，Flutter会自动处理这种情况，这时Locale列表只会包含一项。 Localization 组件 Localizations组件用于加载和查找应用当前语言下的本地化值或资源。应用程序通过Localizations.of(context,type)来引用这些对象。 如果设备的Locale区域设置发生更改，则Localizations 组件会自动加载新区域的Locale值，然后重新build使用（依赖）了它们的组件，之所以会这样，是因为Localizations内部使用了InheritedWidget ，我们在介绍该组件时讲过：当子组件的build函数引用了InheritedWidget时，会创建对InheritedWidget的隐式依赖关系。因此，当InheritedWidget发生更改时，即Localizations的Locale设置发生更改时，将重建所有依赖它的子组件。 本地化值由Localizations的 LocalizationsDelegates 列表加载 。 每个委托必须定义一个异步load() 方法，以生成封装了一系列本地化值的对象。通常这些对象为每个本地化值定义一个方法。 在大型应用程序中，不同模块或Package可能会与自己的本地化值捆绑在一起。 这就是为什么要用Localizations 管理对象表的原因。 要使用由LocalizationsDelegate的load方法之一产生的对象，可以指定一个BuildContext和对象的类型来找到它。例如，Material 组件库的本地化字符串由MaterialLocalizations类定义，此类的实例由MaterialApp类提供的LocalizationDelegate创建， 它们可以如下方式获取到： Localizations.of(context, MaterialLocalizations); 这个特殊的Localizations.of()表达式会经常使用，所以MaterialLocalizations类提供了一个便捷方法： static MaterialLocalizations of(BuildContext context) { return Localizations.of(context, MaterialLocalizations); } // 可以直接调用便捷方法 tooltip: MaterialLocalizations.of(context).backButtonTooltip, 使用打包好的LocalizationsDelegates 为了尽可能小而且简单，flutter软件包中仅提供美国英语值的MaterialLocalizations和WidgetsLocalizations接口的实现。 这些实现类分别称为DefaultMaterialLocalizations和DefaultWidgetsLocalizations。flutter_localizations 包包含GlobalMaterialLocalizations和GlobalWidgetsLocalizations的本地化接口的多语言实现， 国际化的应用程序必须按照本节开头说明的那样为这些类指定本地化Delegate。 上述的GlobalMaterialLocalizations和GlobalWidgetsLocalizations只是Material组件库的本地化实现，如果我们要让自己的布局支持多语言，那么就需要实现在即的Localizations，我们将在下一节介绍其具体的实现方式。 "},"chapter13/locallization_implement.html":{"url":"chapter13/locallization_implement.html","title":"13.2：实现Localizations","keywords":"","body":"13.2 实现Localizations 前面讲了Material组件库如何支持国际化，本节我们将介绍一下我们自己的UI中如何支持多语言。根据上节所述，我们需要实现两个类：一个Delegate类一个Localizations类，下面我们通过一个实例说明。 实现Localizations类 我们已经知道Localizations类中主要实现提供了本地化值，如文本： //Locale资源类 class DemoLocalizations { DemoLocalizations(this.isZh); //是否为中文 bool isZh = false; //为了使用方便，我们定义一个静态方法 static DemoLocalizations of(BuildContext context) { return Localizations.of(context, DemoLocalizations); } //Locale相关值，title为应用标题 String get title { return isZh ? \"Flutter应用\" : \"Flutter APP\"; } //... 其它的值 } DemoLocalizations中会根据当前的语言来返回不同的文本，如title，我们可以将所有需要支持多语言的文本都在此类中定义。DemoLocalizations的实例将会在Delegate类的load方法中创建。 实现Delegate类 Delegate类的职责是在Locale改变时加载新的Locale资源，所以它有一个load方法，Delegate类需要继承自LocalizationsDelegate类，实现相应的接口，示例如下： //Locale代理类 class DemoLocalizationsDelegate extends LocalizationsDelegate { const DemoLocalizationsDelegate(); //是否支持某个Local @override bool isSupported(Locale locale) => ['en', 'zh'].contains(locale.languageCode); // Flutter会调用此类加载相应的Locale资源类 @override Future load(Locale locale) { print(\"xxxx$locale\"); return SynchronousFuture( DemoLocalizations(locale.languageCode == \"zh\") ); } @override bool shouldReload(DemoLocalizationsDelegate old) => false; } shouldReload的返回值决定当Localizations组件重新build时，是否调用load方法重新加载Locale资源。一般情况下，Locale资源只应该在Locale切换时加载一次，不需要每次在Localizations重新build时都加载，所以返回false即可。可能有些人会担心返回false的话在APP启动后用户再改变系统语言时load方法将不会被调用，所以Locale资源将不会被加载。事实上，每当Locale改变时Flutter都会再调用load方法加载新的Locale，无论shouldReload返回true还是false。 最后一步：添加多语言支持 和上一节中介绍的相同，我们现在需要先注册DemoLocalizationsDelegate类，然后再通过DemoLocalizations.of(context)来动态获取当前Locale文本。 只需要在MaterialApp或WidgetsApp的localizationsDelegates列表中添加我们的Delegate实例即可完成注册： localizationsDelegates: [ // 本地化的代理类 GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, // 注册我们的Delegate DemoLocalizationsDelegate() ], 接下来我们可以在Widget中使用Locale值： return Scaffold( appBar: AppBar( //使用Locale title title: Text(DemoLocalizations.of(context).title), ), ... //省略无关代码 ） 这样，当在美国英语和中文简体之间切换系统语言时，APP的标题将会分别为“Flutter APP”和“Flutter应用”。 总结 本节我们通过一个简单的示例说明了Flutter应用国际化的基本过程及原理。但是上面的实例还有一个严重的不足就是我们需要在DemoLocalizations类中获取title时手动的判断当前语言Locale，然后返回合适的文本。试想一下，当我们要支持的语言不是两种而是8种甚至20几种时，如果为每个文本属性都要分别去判断到底是哪种Locale从而获取相应语言的文本将会是一件非常复杂的事。还有，通常情况下翻译人员并不是开发人员，能不能像i18n或i10n标准那样可以将翻译单独保存为一个arb文件交由翻译人员去翻译，翻译好之后开发人员再通过工具将arb文件转为代码。答案是肯定的！我们将在下一节介绍如何通过Dart intl包来实现这些。 "},"chapter13/intl.html":{"url":"chapter13/intl.html","title":"13.3：使用Intl包","keywords":"","body":"使用Intl包 使用Intl包我们不仅可以非常轻松的实现国际化，而且也可以将字符串文本分离成单独的文件，方便开发人员和翻译人员分工协作。为了使用Intl包我们需要添加两个依赖： dependencies: #...省略无关项 intl: ^0.15.7 dev_dependencies: #...省略无关项 intl_translation: ^0.17.2 intl_translation 包主要包含了一些工具，它在开发阶段主要主要的作用是从代码中提取要国际化的字符串到单独的arb文件和根据arb文件生成对应语言的dart代码，而intl包主要是引用和加载intl_translation生成后的dart代码。下面我们将一步步来说明如何使用： 第一步：创建必要目录 首先，在项目根目录下创建一个i10n-arb目录，该目录保存我们接下来通过intl_translation命令生成的arb文件。一个简单的arb文件内容如下： { \"@@last_modified\": \"2018-12-10T15:46:20.897228\", \"@@locale\":\"zh_CH\", \"title\": \"Flutter应用\", \"@title\": { \"description\": \"Title for the Demo application\", \"type\": \"text\", \"placeholders\": {} } } 我们根据\"@@locale\"字段可以看出这个arb对应的是中文简体的翻译，里面的title字段对应的正是我们应用标题的中文简体翻译。@title字段是对title的一些描述信息。 接下来，我们在lib目录下创建一个i10n的目录，该目录用于保存从arb文件生成的dart代码文件。 第二步：实现Localizations和Delegate类 和上一节中的步骤类似，我们仍然要实现Localizations和Delegate类，不同的是，现在我们在实现时要使用intl包的一些方法（有些是动态生成的）。 下面我们在lib/i10n目录下新建一个“localization_intl.dart”的文件，文件内容如下： import 'package:flutter/material.dart'; import 'package:intl/intl.dart'; import 'messages_all.dart'; //1 class DemoLocalizations { static Future load(Locale locale) { final String name = locale.countryCode.isEmpty ? locale.languageCode : locale.toString(); final String localeName = Intl.canonicalizedLocale(name); //2 return initializeMessages(localeName).then((b) { Intl.defaultLocale = localeName; return new DemoLocalizations(); }); } static DemoLocalizations of(BuildContext context) { return Localizations.of(context, DemoLocalizations); } String get title { return Intl.message( 'Flutter APP', name: 'title', desc: 'Title for the Demo application', ); } } //Locale代理类 class DemoLocalizationsDelegate extends LocalizationsDelegate { const DemoLocalizationsDelegate(); //是否支持某个Local @override bool isSupported(Locale locale) => ['en', 'zh'].contains(locale.languageCode); // Flutter会调用此类加载相应的Locale资源类 @override Future load(Locale locale) { //3 return DemoLocalizations.load(locale); } // 当Localizations Widget重新build时，是否调用load重新加载Locale资源. @override bool shouldReload(DemoLocalizationsDelegate old) => false; } 注意： 注释1的\"messages_all.dart\"文件是通过intl_translation工具从arb文件生成的代码，所以在第一次运行生成命令之前，此文件不存在。注释2处的initializeMessages()方法和\"messages_all.dart\"文件一样，是同时生成的。 注释3处和上一节示例代码不同，这里我们直接调用DemoLocalizations.load()即可。 第三步：添加需要国际化的属性 现在我们可以在DemoLocalizations类中添加需要国际化的属性或方法，如上面示例代码中的title属性，这时我们就要用到Intl库提供的一些方法，这些方法可以帮我们轻松实现不同语言的一些语法特性，如复数语境，举个例子，比如我们有一个电子邮件列表页，我们需要在顶部显示未读邮件的数量，在未读数量不同事，我们展示的文本可能会不同： 未读邮件数 提示语 0 There are no emails left 1 There is 1 email left n(n>1) There are n emails left 我们可以通过Intl.plural(...)来实现： remainingEmailsMessage(int howMany) => Intl.plural(howMany, zero: 'There are no emails left', one: 'There is $howMany email left', other: 'There are $howMany emails left', name: \"remainingEmailsMessage\", args: [howMany], desc: \"How many emails remain after archiving.\", examples: const {'howMany': 42, 'userName': 'Fred'}); 可以看到通过Intl.plural方法可以在howMany值不同时输出不同的提示信息。 Intl包还有一些其他的方法，读者可以自行查看其文档，本书不在赘述。 第四步：生成arb文件 现在我们可以通intl_translation包的工具来提取代码中的字符串到一个arb文件，运行如下命名： flutter pub pub run intl_translation:extract_to_arb --output-dir=i10n-arb \\ lib/i10n/localization_intl.dart 运行此命令后，会将我们之前通过Intl API标识的属性和字符串提取到“i10n-arb/intl_messages.arb”文件中，我们看看其内容： { \"@@last_modified\": \"2018-12-10T17:37:28.505088\", \"title\": \"Flutter APP\", \"@title\": { \"description\": \"Title for the Demo application\", \"type\": \"text\", \"placeholders\": {} }, \"remainingEmailsMessage\": \"{howMany,plural, =0{There are no emails left}=1{There is {howMany} email left}other{There are {howMany} emails left}}\", \"@remainingEmailsMessage\": { \"description\": \"How many emails remain after archiving.\", \"type\": \"text\", \"placeholders\": { \"howMany\": { \"example\": 42 } } } } 这个是默认的Locale资源文件，如果我们现在要支持中文简体，只需要在该文件同级目录创建一个\"intl_zh_CN.arb\"文件，然后将\"intl_messages.arb\"的内容拷贝到\"intl_zh_CN.arb\"文件，接下来将英文翻译为中文即可，翻译后的\"intl_zh_CN.arb\"文件内容如下： { \"@@last_modified\": \"2018-12-10T15:46:20.897228\", \"@@locale\":\"zh_CH\", \"title\": \"Flutter应用\", \"@title\": { \"description\": \"Title for the Demo application\", \"type\": \"text\", \"placeholders\": {} }, \"remainingEmailsMessage\": \"{howMany,plural, =0{没有未读邮件}=1{有{howMany}封未读邮件}other{有{howMany}封未读邮件}}\", \"@remainingEmailsMessage\": { \"description\": \"How many emails remain after archiving.\", \"type\": \"text\", \"placeholders\": { \"howMany\": { \"example\": 42 } } } } 我们必须要翻译title和remainingEmailsMessage字段，description是该字段的说明，通常给翻译人员看，代码中不会用到。 有两点需要说明： 如果某个特定的arb中缺失某个属性，那么应用将会加载默认的arb文件(intl_messages.arb)中的相应属性，这是Intl的托底策略。 每次运行提取命令时，intl_messages.arb都会根据代码重新生成，但其他arb文件不会，所以当要添加新的字段或方法时，其他arb文件是增量的，不用担心会覆盖。 arb文件是标准的，其格式规范可以自行了解。通常会将arb文件交给翻译人员，当他们完成翻译后，我们再通过下面的步骤根据arb文件生成最终的dart代码。 第五步：生成dart代码 最后一步就是根据arb生成dart文件： flutter pub pub run intl_translation:generate_from_arb --output-dir=lib/i10n --no-use-deferred-loading lib/i10n/localization_intl.dart i10n-arb/intl_*.arb 这句命令在首次运行时会在\"lib/i10n\"目录下生成多个文件，对应多种Locale，这些代码便是最终要使用的dart代码。 总结 至此，我们将使用Intl包对APP进行国际化的流程介绍完了，我们可以发现，其中第一步和第二步只在第一次需要，而我们开发时的主要的工作都是在第三步。由于最后两步在第三步完成后每次也都需要，所以我们可以将最后两步放在一个shell脚本里，当我们完成第三步或完成arb文件翻译后只需要分别执行该脚本即可。我们在根目录下创建一个intl.sh的脚本，内容为： flutter pub pub run intl_translation:extract_to_arb --output-dir=i10n-arb lib/i10n/localization_intl.dart flutter pub pub run intl_translation:generate_from_arb --output-dir=lib/i10n --no-use-deferred-loading lib/i10n/localization_intl.dart i10n-arb/intl_*.arb 然后授予执行权限： chmod +x intl.sh 执行intl.sh ./intl.sh "},"chapter13/faq.html":{"url":"chapter13/faq.html","title":"13.4：国际化常见问题","keywords":"","body":"13.4 国际化常见问题 本节主要解答一下在国际化中常见的问题。 默认语言区域不对 在一些非大陆行货渠道买的一些Android和iOS设备，会出现默认的Locale不是中文简体的情况。这属于正常现象，但是为了防止设备获取的Locale与实际的地区不一致，所有的支持多语言的APP都必须提供一个手动选择语言的入口。 如何对应用标题进行国际化 MaterialApp有一个title属性，用于指定APP的标题。在Android系统中，APP的标题会出现在任务管理器中。所以也需要对title进行国际化。但是问题是很多国际化的配置都是在MaterialApp上设置的，我们无法在构建MaterialApp时通过Localizations.of来获取本地化资源，如： MaterialApp( title: DemoLocalizations.of(context).title, //不能正常工作！ localizationsDelegates: [ // 本地化的代理类 GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, DemoLocalizationsDelegate() // 设置Delegate ], ); 上面代码运行后，DemoLocalizations.of(context).title 是会报错的，原因是Localizations.of会从当前的context沿着widget树向顶部查找DemoLocalizations，但是我们在MaterialApp中设置完DemoLocalizationsDelegate后，实际上DemoLocalizations是在当前context的子树中的，所以DemoLocalizations.of(context)会返回null，报错。那么我们该如何处理这种情况呢？其实很简单，我们只需要设置一个onGenerateTitle回调即可： MaterialApp( onGenerateTitle: (context){ // 此时context在Localizations的子树中 return DemoLocalizations.of(context).title; }, localizationsDelegates: [ DemoLocalizationsDelegate(), ... ], ); 如何为英语系的国家指定同一个locale 英语系的国家非常多，如美国、英国、澳大利亚等，这些英语系国家虽然说的都是英语，但也会有一些区别。如果我们的APP只想提供一种英语（如美国英语）供所有英语系国家使用，我们可以在前面介绍的localeListResolutionCallback中来做兼容： localeListResolutionCallback: (List locales, Iterable supportedLocales) { // 判断当前locale是否为英语系国家，如果是直接返回Locale('en', 'US') } "},"chapter14/":{"url":"chapter14/","title":"第十四章：Flutter核心原理","keywords":"","body":"本章目录 Flutter UI系统 Element和BuildContext RenderObject和RenderBox Flutter从启动到显示 "},"chapter14/flutter_ui_system.html":{"url":"chapter14/flutter_ui_system.html","title":"14.1：Flutter UI系统","keywords":"","body":"14.1 Flutter UI系统 在本书的前面章节中，我们多次提到\"UI系统\"这个概念，本书中所指的UI系统特指：基于一个平台，在此平台上实现GUI的一个系统，这里的平台特指操作系统，如Android、iOS或者Windows、macOS。我们说过各个平台UI系统的原理是相通的，也就是说无论是Android还是iOS，他们将一个用户界面展示到屏幕的流程是相似的，所以，在介绍Flutter UI系统之前，我们先看看UI系统的基本原理，这样可以帮助读者对操作系统和系统底层UI逻辑有一个清晰的认识。 硬件绘图基本原理 提到原理，我们要从屏幕显示图像的基本原理谈起。我们知道显示器（屏幕）是由一个个物理显示单元组成，每一个单元我们可以称之为一个物理像素点，而每一个像素点可以发出多种颜色，显示器成相的原理就是在不同的物理像素点上显示不同的颜色，最终构成完整的图像。 一个像素点能发出的所有颜色总数是显示器的一个重要指标，比如我们所说的1600万色的屏幕就是指一个像素点可以显示出1600万种颜色，而显示器颜色是有RGB三基色组成，所以1600万即2的24次方，即每个基本色（R、G、B）深度扩展至8 bit(位)，颜色深度越深，所能显示的色彩更加丰富靓丽。 为了更新显示画面，显示器是以固定的频率刷新（从GPU取数据），比如有一部手机屏幕的刷新频率是 60Hz。当一帧图像绘制完毕后准备绘制下一帧时，显示器会发出一个垂直同步信号（如VSync）， 60Hz的屏幕就会一秒内发出 60次这样的信号。而这个信号主要是用于同步CPU、GPU和显示器的。一般地来说，计算机系统中，CPU、GPU和显示器以一种特定的方式协作：CPU将计算好的显示内容提交给 GPU，GPU渲染后放入帧缓冲区，然后视频控制器按照同步信号从帧缓冲区取帧数据传递给显示器显示。 CPU和GPU的任务是各有偏重的，CPU主要用于基本数学和逻辑计算，而GPU主要执行和图形处理相关的复杂的数学，如矩阵变化和几何计算，GPU的主要作用就是确定最终输送给显示器的各个像素点的色值。 操作系统绘制API的封装 由于最终的图形计算和绘制都是由相应的硬件来完成，而直接操作硬件的指令通常都会有操作系统屏蔽，应用开发者通常不会直接面对硬件，操作系统屏蔽了这些底层硬件操作后会提供一些封装后的API供操作系统之上的应用调用，但是对于应用开发者来说，直接调用这些操作系统提供的API是比较复杂和低效的，因为操作系统提供的API往往比较基础，直接调用需要了解API的很多细节。正是因为这个原因，几乎所有用于开发GUI程序的编程语言都会在操作系统之上再封装一层，将操作系统原生API封装在一个编程框架和模型中，然后定义一种简单的开发规则来开发GUI应用程序，而这一层抽象，正是我们所说的“UI”系统，如Android SDK正是封装了Android操作系统API，提供了一个“UI描述文件XML+Java操作DOM”的UI系统，而iOS的UIKit 对View的抽象也是一样的，他们都将操作系统API抽象成一个基础对象（如用于2D图形绘制的Canvas），然后再定义一套规则来描述UI，如UI树结构，UI操作的单线程原则等。 Flutter UI系统 我们可以看到，无论是Android SDK还是iOS的UIKit 的职责都是相同的，它们只是语言载体和底层的系统不同而已。那么可不可以实现这么一个UI系统：可以使用同一种编程语言开发，然后针对不同操作系统API抽象一个对上接口一致，对下适配不同操作系统的的中间层，然后在打包编译时再使用相应的中间层代码？如果可以做到，那么我们就可以使用同一套代码编写跨平台的应用了。而Flutter的原理正是如此，它提供了一套Dart API，然后在底层通过OpenGL这种跨平台的绘制库（内部会调用操作系统API）实现了一套代码跨多端。由于Dart API也是调用操作系统API，所以它的性能接近原生。 注意，虽然Dart是先调用了OpenGL，OpenGL才会调用操作系统API，但是这仍然是原生渲染，因为OpenGL只是操作系统API的一个封装库，它并不像WebView渲染那样需要JavaScript运行环境和CSS渲染器，所以不会有性能损失。 至此，我们已经介绍了Flutter UI系统和操作系统交互的这一部分原理，现在需要说一些它对应用开发者定义的开发标准。其实在前面的章节中，我们已经对这个标准非常熟悉了, 简单概括就是：组合和响应式。我们要开发一个UI界面，需要通过组合其它Widget来实现，Flutter中，一切都是Widget，当UI要发生变化时，我们不去直接修改DOM，而是通过更新状态，让Flutter UI系统来根据新的状态来重新构建UI。 讲到这里，读者可能发现Flutter UI系统和Flutter Framework的概念是差不多的，的确如此，之所以用“UI系统”，是因为其他平台中可能不这么叫，我们只是为了概念统一，便于描述，读者不必纠结于概念本身。 在接下来的小节中，我们先详细介绍一下Element、RenderObject，它们是组成Flutter UI系统的基石。最后我们在分析一下Flutter应用启动和运行的整体过程。 "},"chapter14/element_buildcontext.html":{"url":"chapter14/element_buildcontext.html","title":"14.2：Element和BuildContext","keywords":"","body":"14.2 Element与BuildContext 14.2.1 Element 在“Widget简介”一节，我们介绍了Widget和Element的关系，我们知道最终的UI树其实是由一个个独立的Element节点构成。我们也知道了组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。 Element就是Widget在UI树具体位置的一个实例化对象，大多数Element只有唯一的renderObject，但还有一些Element会有多个子节点，如继承自RenderObjectElement的一些类，比如MultiChildRenderObjectElement。最终所有Element的RenderObject构成一棵树，我们称之为渲染树，即render tree。 Element的生命周期如下： Framework 调用Widget.createElement 创建一个Element实例，记为element Framework 调用 element.mount(parentElement,newSlot) ，mount方法中首先调用element所对应Widget的createRenderObject方法创建与element相关联的RenderObject对象，然后调用element.attachRenderObject方法将element.renderObject添加到渲染树中插槽指定的位置（这一步不是必须的，一般发生在Element树结构发生变化时才需要重新attach）。插入到渲染树后的element就处于“active”状态，处于“active”状态后就可以显示在屏幕上了（可以隐藏）。 当有父Widget的配置数据改变时，同时其State.build返回的Widget结构与之前不同，此时就需要重新构建对应的Element树。为了进行Element复用，在Element重新构建前会先尝试是否可以复用旧树上相同位置的element，element节点在更新前都会调用其对应Widget的canUpdate方法，如果返回true，则复用旧Element，旧的Element会使用新Widget配置数据更新，反之则会创建一个新的Element。Widget.canUpdate主要是判断newWidget与oldWidget的runtimeType和key是否同时相等，如果同时相等就返回true，否则就会返回false。根据这个原理，当我们需要强制更新一个Widget时，可以通过指定不同的Key来避免复用。 当有祖先Element决定要移除element 时（如Widget树结构发生了变化，导致element对应的Widget被移除），这时该祖先Element就会调用deactivateChild 方法来移除它，移除后element.renderObject也会被从渲染树中移除，然后Framework会调用element.deactivate 方法，这时element状态变为“inactive”状态。 “inactive”态的element将不会再显示到屏幕。为了避免在一次动画执行过程中反复创建、移除某个特定element，“inactive”态的element在当前动画最后一帧结束前都会保留，如果在动画执行结束后它还未能重新变成”active“状态，Framework就会调用其unmount方法将其彻底移除，这时element的状态为defunct,它将永远不会再被插入到树中。 如果element要重新插入到Element树的其它位置，如element或element的祖先拥有一个GlobalKey（用于全局复用元素），那么Framework会先将element从现有位置移除，然后再调用其activate方法，并将其renderObject重新attach到渲染树。 看完Element的生命周期，可能有些读者会有疑问，开发者会直接操作Element树吗？其实对于开发者来说，大多数情况下只需要关注Widget树就行，Flutter框架已经将对Widget树的操作映射到了Element树上，这可以极大的降低复杂度，提高开发效率。但是了解Element对理解整个Flutter UI框架是至关重要的，Flutter正是通过Element这个纽带将Widget和RenderObject关联起来，了解Element层不仅会帮助读者对Flutter UI框架有个清晰的认识，而且也会提高自己的抽象能力和设计能力。另外在有些时候，我们必须得直接使用Element对象来完成一些操作，比如获取主题Theme数据，具体细节将在下文介绍。 14.2.2 BuildContext 我们已经知道，StatelessWidget和StatefulWidget的build方法都会传一个BuildContext对象： Widget build(BuildContext context) {} 我们也知道，在很多时候我们都需要使用这个context 做一些事，比如： Theme.of(context) //获取主题 Navigator.push(context, route) //入栈新路由 Localizations.of(context, type) //获取Local context.size //获取上下文大小 context.findRenderObject() //查找当前或最近的一个祖先RenderObject 那么BuildContext到底是什么呢，查看其定义，发现其是一个抽象接口类： abstract class BuildContext { ... } 那这个context对象对应的实现类到底是谁呢？我们顺藤摸瓜，发现build调用是发生在StatelessWidget和StatefulWidget对应的StatelessElement和StatefulElement的build方法中，以StatelessElement为例： class StatelessElement extends ComponentElement { ... @override Widget build() => widget.build(this); ... } 发现build传递的参数是this，很明显！这个BuildContext就是StatelessElement。同样，我们同样发现StatefulWidget的context是StatefulElement。但StatelessElement和StatefulElement本身并没有实现BuildContext接口，继续跟踪代码，发现它们间接继承自Element类，然后查看Element类定义，发现Element类果然实现了BuildContext接口: class Element extends DiagnosticableTree implements BuildContext { ... } 至此真相大白，BuildContext就是widget对应的Element，所以我们可以通过context在StatelessWidget和StatefulWidget的build方法中直接访问Element对象。我们获取主题数据的代码Theme.of(context)内部正是调用了Element的inheritFromWidgetOfExactType()方法。 思考题：为什么build方法的参数不定义成Element对象，而要定义成BuildContext ? 进阶 我们可以看到Element是Flutter UI框架内部连接widget和RenderObject的纽带，大多数时候开发者只需要关注widget层即可，但是widget层有时候并不能完全屏蔽Element细节，所以Framework在StatelessWidget和StatefulWidget中通过build方法参数又将Element对象也传递给了开发者，这样一来，开发者便可以在需要时直接操作Element对象。那么现在笔者提两个问题，请读者先自己思考一下： 如果没有widget层，单靠Element层是否可以搭建起一个可用的UI框架？如果可以应该是什么样子？ Flutter UI框架能不做成响应式吗？ 对于问题1，答案当然是肯定的，因为我们之前说过widget树只是Element树的映射，我们完全可以直接通过Element来搭建一个UI框架。下面举一个例子： 我们通过纯粹的Element来模拟一个StatefulWidget的功能，假设有一个页面，该页面有一个按钮，按钮的文本是一个9位数，点击一次按钮，则对9个数随机排一次序，代码如下： class HomeView extends ComponentElement{ HomeView(Widget widget) : super(widget); String text = \"123456789\"; @override Widget build() { Color primary=Theme.of(this).primaryColor; //1 return GestureDetector( child: Center( child: FlatButton( child: Text(text, style: TextStyle(color: primary),), onPressed: () { var t = text.split(\"\")..shuffle(); text = t.join(); markNeedsBuild(); //点击后将该Element标记为dirty，Element将会rebuild }, ), ), ); } } 上面build方法不接收参数，这一点和在StatelessWidget和StatefulWidget中build(BuildContext)方法不同。代码中需要用到BuildContext的地方直接用this代替即可，如代码注释1处Theme.of(this)参数直接传this即可，因为当前对象本身就是Element实例。 当text发生改变时，我们调用markNeedsBuild()方法将当前Element标记为dirty即可，标记为dirty的Element会在下一帧中重建。实际上，State.setState()在内部也是调用的markNeedsBuild()方法。 上面代码中build方法返回的仍然是一个widget，这是由于Flutter框架中已经有了widget这一层，并且组件库都已经是以widget的形式提供了，如果在Flutter框架中所有组件都像示例的HomeView一样以Element形式提供，那么就可以用纯Element来构建UI了HomeView的build方法返回值类型就可以是Element了。 如果我们需要将上面代码在现有Flutter框架中跑起来，那么还是得提供一个”适配器“widget将HomeView结合到现有框架中，下面CustomHome就相当于”适配器“： class CustomHome extends Widget { @override Element createElement() { return HomeView(this); } } 现在就可以将CustomHome添加到widget树了，我们在一个新路由页创建它，最终效果如下如图14-1和14-2（点击后）所示： 点击按钮则按钮文本会随机排序。 对于问题2，答案当然也是肯定的，Flutter engine提供的dart API是原始且独立的，这个与操作系统提供的API类似，上层UI框架设计成什么样完全取决于设计者，完全可以将UI框架设计成Android风格或iOS风格，但这些事Google不会再去做，我们也没必要再去搞这一套，这是因为响应式的思想本身是很棒的，之所以提出这个问题，是因为笔者认为做与不做是一回事，但知道能不能做是另一回事，这能反映出我们对知识的理解程度。 总结 本节详细的介绍了Element的生命周期，以及它Widget、BuildContext的关系，也介绍了Element在Flutter UI系统中的角色和作用，我们将在下一节介绍Flutter UI系统中另一个重要的角色RenderObject。 "},"chapter14/render_object.html":{"url":"chapter14/render_object.html","title":"14.3：RenderObject与RenderBox","keywords":"","body":"14.3 RenderObject和RenderBox 在上一节我们说过每个Element都对应一个RenderObject，我们可以通过Element.renderObject 来获取。并且我们也说过RenderObject的主要职责是Layout和绘制，所有的RenderObject会组成一棵渲染树Render Tree。本节我们将重点介绍一下RenderObject的作用。 RenderObject就是渲染树中的一个对象，它拥有一个parent和一个parentData 插槽（slot），所谓插槽，就是指预留的一个接口或位置，这个接口和位置是由其它对象来接入或占据的，这个接口或位置在软件中通常用预留变量来表示，而parentData正是一个预留变量，它正是由parent 来赋值的，parent通常会通过子RenderObject的parentData存储一些和子元素相关的数据，如在Stack布局中，RenderStack就会将子元素的偏移数据存储在子元素的parentData中（具体可以查看Positioned实现）。 RenderObject类本身实现了一套基础的layout和绘制协议，但是并没有定义子节点模型（如一个节点可以有几个子节点，没有子节点？一个？两个？或者更多？）。 它也没有定义坐标系统（如子节点定位是在笛卡尔坐标中还是极坐标？）和具体的布局协议（是通过宽高还是通过constraint和size?，或者是否由父节点在子节点布局之前或之后设置子节点的大小和位置等）。为此，Flutter提供了一个RenderBox类，它继承自`RenderObject，布局坐标系统采用笛卡尔坐标系，这和Android和iOS原生坐标系是一致的，都是屏幕的top、left是原点，然后分宽高两个轴，大多数情况下，我们直接使用RenderBox就可以了，除非遇到要自定义布局模型或坐标系统的情况，下面我们重点介绍一下RenderBox。 14.3.1 布局过程 Constraints 在RenderBox 中，有个size属性用来保存控件的宽和高。RenderBox的layout是通过在组件树中从上往下传递BoxConstraints对象的实现的。BoxConstraints对象可以限制子节点的最大和最小宽高，子节点必须遵守父节点给定的限制条件。 在布局阶段，父节点会调用子节点的layout()方法，下面我们看看RenderObject中layout()方法的大致实现（删掉了一些无关代码和异常捕获）: void layout(Constraints constraints, { bool parentUsesSize = false }) { ... RenderObject relayoutBoundary; if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) { relayoutBoundary = this; } else { final RenderObject parent = this.parent; relayoutBoundary = parent._relayoutBoundary; } ... if (sizedByParent) { performResize(); } performLayout(); ... } 可以看到layout方法需要传入两个参数，第一个为constraints，即 父节点对子节点大小的限制，该值根据父节点的布局逻辑确定。另外一个参数是 parentUsesSize，该值用于确定 relayoutBoundary，该参数表示子节点布局变化是否影响父节点，如果为true，当子节点布局发生变化时父节点都会标记为需要重新布局，如果为false，则子节点布局发生变化后不会影响父节点。 relayoutBoundary 上面layout()源码中定义了一个relayoutBoundary变量，什么是 relayoutBoundary？在前面介绍Element时，我们讲过当一个Element标记为 dirty 时便会重新build，这时RenderObject便会重新布局，我们是通过调用 markNeedsBuild() 来标记Element为dirty的。在RenderObject中有一个类似的markNeedsLayout()方法，它会将RenderObject的布局状态标记为 dirty，这样在下一个frame中便会重新layout，我们看看RenderObject的markNeedsLayout()的部分源码： void markNeedsLayout() { ... assert(_relayoutBoundary != null); if (_relayoutBoundary != this) { markParentNeedsLayout(); } else { _needsLayout = true; if (owner != null) { ... owner._nodesNeedingLayout.add(this); owner.requestVisualUpdate(); } } } 代码大致逻辑是先判断自身是不是relayoutBoundary，如果不是就继续向parent 查找，一直向上查找到是 relayoutBoundary 的 RenderObject为止，然后再将其标记为 dirty 的。这样来看它的作用就比较明显了，意思就是当一个控件的大小被改变时可能会影响到它的 parent，因此 parent 也需要被重新布局，那么到什么时候是个头呢？答案就是 relayoutBoundary，如果一个 RenderObject 是 relayoutBoundary，就表示它的大小变化不会再影响到 parent 的大小了，于是 parent 也就不用重新布局了。 performResize 和 performLayout RenderBox实际的测量和布局逻辑是在performResize() 和 performLayout()两个方法中，RenderBox子类需要实现这两个方法来定制自身的布局逻辑。根据layout() 源码可以看出只有 sizedByParent 为 true 时，performResize() 才会被调用，而 performLayout() 是每次布局都会被调用的。sizedByParent 意为该节点的大小是否仅通过 parent 传给它的 constraints 就可以确定了，即该节点的大小与它自身的属性和其子节点无关，比如如果一个控件永远充满 parent 的大小，那么 sizedByParent就应该返回true，此时其大小在 performResize() 中就确定了，在后面的 performLayout() 方法中将不会再被修改了，这种情况下 performLayout() 只负责布局子节点。 在 performLayout() 方法中除了完成自身布局，也必须完成子节点的布局，这是因为只有父子节点全部完成后布局流程才算真正完成。所以最终的调用栈将会变成：layout() > performResize()/performLayout() > child.layout() > ... ，如此递归完成整个UI的布局。 RenderBox子类要定制布局算法不应该重写layout()方法，因为对于任何RenderBox的子类来说，它的layout流程基本是相同的，不同之处只在具体的布局算法，而具体的布局算法子类应该通过重写performResize() 和 performLayout()两个方法来实现，他们会在layout()中被调用。 ParentData 当layout结束后，每个节点的位置（相对于父节点的偏移）就已经确定了，RenderObject就可以根据位置信息来进行最终的绘制。但是在layout过程中，节点的位置信息怎么保存？对于大多数RenderBox子类来说如果子类只有一个子节点，那么子节点偏移一般都是Offset.zero ，如果有多个子节点，则每个子节点的偏移就可能不同。而子节点在父节点的偏移数据正是通过RenderObject的parentData属性来保存的。在RenderBox中，其parentData属性默认是一个BoxParentData对象，该属性只能通过父节点的setupParentData()方法来设置： abstract class RenderBox extends RenderObject { @override void setupParentData(covariant RenderObject child) { if (child.parentData is! BoxParentData) child.parentData = BoxParentData(); } ... } BoxParentData定义如下： /// Parentdata 会被RenderBox和它的子类使用. class BoxParentData extends ParentData { /// offset表示在子节点在父节点坐标系中的绘制偏移 Offset offset = Offset.zero; @override String toString() => 'offset=$offset'; } 一定要注意，RenderObject的parentData 只能通过父元素设置. 当然，ParentData并不仅仅可以用来存储偏移信息，通常所有和子节点特定的数据都可以存储到子节点的ParentData中，如ContainerBox的ParentData就保存了指向兄弟节点的previousSibling和nextSibling，Element.visitChildren()方法也正是通过它们来实现对子节点的遍历。再比如KeepAlive 组件，它使用KeepAliveParentDataMixin（继承自ParentData） 来保存子节的keepAlive状态。 14.3.2 绘制过程 RenderObject可以通过paint()方法来完成具体绘制逻辑，流程和布局流程相似，子类可以实现paint()方法来完成自身的绘制逻辑，paint()签名如下： void paint(PaintingContext context, Offset offset) { } 通过context.canvas可以取到Canvas对象，接下来就可以调用Canvas API来实现具体的绘制逻辑。 如果节点有子节点，它除了完成自身绘制逻辑之外，还要调用子节点的绘制方法。我们以RenderFlex对象为例说明： @override void paint(PaintingContext context, Offset offset) { // 如果子元素未超出当前边界，则绘制子元素 if (_overflow 代码很简单，首先判断有无溢出，如果没有则调用defaultPaint(context, offset)来完成绘制，该方法源码如下： void defaultPaint(PaintingContext context, Offset offset) { ChildType child = firstChild; while (child != null) { final ParentDataType childParentData = child.parentData; //绘制子节点， context.paintChild(child, childParentData.offset + offset); child = childParentData.nextSibling; } } 很明显，由于Flex本身没有需要绘制的东西，所以直接遍历其子节点，然后调用paintChild()来绘制子节点，同时将子节点ParentData中在layout阶段保存的offset加上自身偏移作为第二个参数传递给paintChild()。而如果子节点还有子节点时，paintChild()方法还会调用子节点的paint()方法，如此递归完成整个节点树的绘制，最终调用栈为： paint() > paintChild() > paint() ... 。 当需要绘制的内容大小溢出当前空间时，将会执行paintOverflowIndicator() 来绘制溢出部分提示，这个就是我们经常看到的溢出提示，如图14-3所示： RepaintBoundary 我们已经在CustomPaint一节中介绍过RepaintBoundary，现在我们深入的了解一些。与 RelayoutBoundary 相似，RepaintBoundary是用于在确定重绘边界的，与RelayoutBoundary不同的是，这个绘制边界需要由开发者通过RepaintBoundary 组件自己指定，如： CustomPaint( size: Size(300, 300), //指定画布大小 painter: MyPainter(), child: RepaintBoundary( child: Container(...), ), ), 下面我们看看RepaintBoundary的原理，RenderObject有一个isRepaintBoundary属性，该属性决定这个RenderObject重绘时是否独立于其父元素，如果该属性值为true ，则独立绘制，反之则一起绘制。那独立绘制是怎么实现的呢？ 答案就在paintChild()源码中： void paintChild(RenderObject child, Offset offset) { ... if (child.isRepaintBoundary) { stopRecordingIfNeeded(); _compositeChild(child, offset); } else { child._paintWithContext(this, offset); } ... } 我们可以看到，在绘制子节点时，如果child.isRepaintBoundary 为 true则会调用_compositeChild()方法，_compositeChild()源码如下： void _compositeChild(RenderObject child, Offset offset) { // 给子节点创建一个layer ，然后再上面绘制子节点 if (child._needsPaint) { repaintCompositedChild(child, debugAlsoPaintedParent: true); } else { ... } assert(child._layer != null); child._layer.offset = offset; appendLayer(child._layer); } 很明显了，独立绘制是通过在不同的layer（层）上绘制的。所以，很明显，正确使用isRepaintBoundary属性可以提高绘制效率，避免不必要的重绘。具体原理是：和触发重新build和layout类似，RenderObject也提供了一个markNeedsPaint()方法，其源码如下： void markNeedsPaint() { ... //如果RenderObject.isRepaintBoundary 为true,则该RenderObject拥有layer，直接绘制 if (isRepaintBoundary) { ... if (owner != null) { //找到最近的layer，绘制 owner._nodesNeedingPaint.add(this); owner.requestVisualUpdate(); } } else if (parent is RenderObject) { // 没有自己的layer, 会和一个祖先节点共用一个layer assert(_layer == null); final RenderObject parent = this.parent; // 向父级递归查找 parent.markNeedsPaint(); assert(parent == this.parent); } else { // 如果直到根节点也没找到一个Layer，那么便需要绘制自身，因为没有其它节点可以绘制根节点。 if (owner != null) owner.requestVisualUpdate(); } } 可以看出，当调用 markNeedsPaint() 方法时，会从当前 RenderObject 开始一直向父节点查找，直到找到 一个isRepaintBoundary 为 true的RenderObject 时，才会触发重绘，这样便可以实现局部重绘。当 有RenderObject 绘制的很频繁或很复杂时，可以通过RepaintBoundary Widget来指定isRepaintBoundary 为 true，这样在绘制时仅会重绘自身而无需重绘它的 parent，如此便可提高性能。 还有一个问题，通过RepaintBoundary 如何设置isRepaintBoundary属性呢？其实，如果使用了RepaintBoundary，其对应的RenderRepaintBoundary会自动将isRepaintBoundary设为true的： class RenderRepaintBoundary extends RenderProxyBox { /// Creates a repaint boundary around [child]. RenderRepaintBoundary({ RenderBox child }) : super(child); @override bool get isRepaintBoundary => true; } 14.3.3 命中测试 我们在”事件处理与通知“一章中已经讲过Flutter事件机制和命中测试流程，本节我们看一下其内部实现原理。 一个对象是否可以响应事件，取决于其对命中测试的返回，当发生用户事件时，会从根节点（RenderView）开始进行命中测试，下面是RenderView的hitTest()源码： bool hitTest(HitTestResult result, { Offset position }) { if (child != null) child.hitTest(result, position: position); //递归子RenderBox进行命中测试 result.add(HitTestEntry(this)); //将测试结果添加到result中 return true; } 我们再看看RenderBox默认的hitTest()实现： bool hitTest(HitTestResult result, { @required Offset position }) { ... if (_size.contains(position)) { if (hitTestChildren(result, position: position) || hitTestSelf(position)) { result.add(BoxHitTestEntry(this, position)); return true; } } return false; } 我们看到默认的实现里调用了hitTestSelf()和hitTestChildren()两个方法，这两个方法默认实现如下： @protected bool hitTestSelf(Offset position) => false; @protected bool hitTestChildren(HitTestResult result, { Offset position }) => false; hitTest 方法用来判断该RenderObject 是否在被点击的范围内，同时负责将被点击的 RenderBox 添加到 HitTestResult 列表中，参数 position 为事件触发的坐标（如果有的话），返回 true 则表示有RenderBox 通过了命中测试，需要响应事件，反之则认为当前RenderBox没有命中。在继承RenderBox时，可以直接重写hitTest()方法，也可以重写 hitTestSelf() 或 hitTestChildren(), 唯一不同的是 hitTest()中需要将通过命中测试的节点信息添加到命中测试结果列表中，而 hitTestSelf() 和 hitTestChildren()则只需要简单的返回true或false。 14.3.4 语义化 语义化即Semantics，主要是提供给读屏软件的接口，也是实现辅助功能的基础，通过语义化接口可以让机器理解页面上的内容，对于有视力障碍用户可以使用读屏软件来理解UI内容。如果一个RenderObject要支持语义化接口，可以实现 describeApproximatePaintClip和 visitChildrenForSemantics方法和semanticsAnnotator getter。更多关于语义化的信息可以查看API文档。 14.3.5 总结 本节我们介绍了RenderObject主要的功能和方法，理解这些内容可以帮助我们更好的理解Flutter UI底层原理。我们也可以看到，如果要从头到尾实现一个RenderObject是比较麻烦的，我们必须去实现layout、绘制和命中测试逻辑，但是值得庆幸的是，大多数时候我们可以直接在Widget层通过组合或者CustomPaint完成自定义UI。如果遇到只能定义一个新RenderObject的场景时（如要实现一个新的layout算法的布局容器），可以直接继承自RenderBox，这样可以帮我们减少一部分工作。 "},"chapter14/flutter_app_startup.html":{"url":"chapter14/flutter_app_startup.html","title":"14.4：Flutter从启动到显示","keywords":"","body":"14.4 Flutter运行机制-从启动到显示 本节我们主要介绍一下Flutter从启动到显示的过程。 启动 Flutter的入口在\"lib/main.dart\"的main()函数中，它是Dart应用程序的起点。在Flutter应用中，main()函数最简单的实现如下： void main() { runApp(MyApp()); } 可以看main()函数只调用了一个runApp()方法，我们看看runApp()方法中都做了什么： void runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() ..attachRootWidget(app) ..scheduleWarmUpFrame(); } 参数app是一个widget，它是Flutter应用启动后要展示的第一个Widget。而WidgetsFlutterBinding正是绑定widget 框架和Flutter engine的桥梁，定义如下： class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { static WidgetsBinding ensureInitialized() { if (WidgetsBinding.instance == null) WidgetsFlutterBinding(); return WidgetsBinding.instance; } } 可以看到WidgetsFlutterBinding继承自BindingBase 并混入了很多Binding，在介绍这些Binding之前我们先介绍一下Window，下面是Window的官方解释： The most basic interface to the host operating system's user interface. 很明显，Window正是Flutter Framework连接宿主操作系统的接口。我们看一下Window类的部分定义： class Window { // 当前设备的DPI，即一个逻辑像素显示多少物理像素，数字越大，显示效果就越精细保真。 // DPI是设备屏幕的固件属性，如Nexus 6的屏幕DPI为3.5 double get devicePixelRatio => _devicePixelRatio; // Flutter UI绘制区域的大小 Size get physicalSize => _physicalSize; // 当前系统默认的语言Locale Locale get locale; // 当前系统字体缩放比例。 double get textScaleFactor => _textScaleFactor; // 当绘制区域大小改变回调 VoidCallback get onMetricsChanged => _onMetricsChanged; // Locale发生变化回调 VoidCallback get onLocaleChanged => _onLocaleChanged; // 系统字体缩放变化回调 VoidCallback get onTextScaleFactorChanged => _onTextScaleFactorChanged; // 绘制前回调，一般会受显示器的垂直同步信号VSync驱动，当屏幕刷新时就会被调用 FrameCallback get onBeginFrame => _onBeginFrame; // 绘制回调 VoidCallback get onDrawFrame => _onDrawFrame; // 点击或指针事件回调 PointerDataPacketCallback get onPointerDataPacket => _onPointerDataPacket; // 调度Frame，该方法执行后，onBeginFrame和onDrawFrame将紧接着会在合适时机被调用， // 此方法会直接调用Flutter engine的Window_scheduleFrame方法 void scheduleFrame() native 'Window_scheduleFrame'; // 更新应用在GPU上的渲染,此方法会直接调用Flutter engine的Window_render方法 void render(Scene scene) native 'Window_render'; // 发送平台消息 void sendPlatformMessage(String name, ByteData data, PlatformMessageResponseCallback callback) ; // 平台通道消息处理回调 PlatformMessageCallback get onPlatformMessage => _onPlatformMessage; ... //其它属性及回调 } 可以看到Window类包含了当前设备和系统的一些信息以及Flutter Engine的一些回调。现在我们再回来看看WidgetsFlutterBinding混入的各种Binding。通过查看这些 Binding的源码，我们可以发现这些Binding中基本都是监听并处理Window对象的一些事件，然后将这些事件按照Framework的模型包装、抽象然后分发。可以看到WidgetsFlutterBinding正是粘连Flutter engine与上层Framework的”胶水“。 GestureBinding：提供了window.onPointerDataPacket 回调，绑定Framework手势子系统，是Framework事件模型与底层事件的绑定入口。 ServicesBinding：提供了window.onPlatformMessage 回调， 用于绑定平台消息通道（message channel），主要处理原生和Flutter通信。 SchedulerBinding：提供了window.onBeginFrame和window.onDrawFrame回调，监听刷新事件，绑定Framework绘制调度子系统。 PaintingBinding：绑定绘制库，主要用于处理图片缓存。 SemanticsBinding：语义化层与Flutter engine的桥梁，主要是辅助功能的底层支持。 RendererBinding: 提供了window.onMetricsChanged 、window.onTextScaleFactorChanged 等回调。它是渲染树与Flutter engine的桥梁。 WidgetsBinding：提供了window.onLocaleChanged、onBuildScheduled 等回调。它是Flutter widget层与engine的桥梁。 WidgetsFlutterBinding.ensureInitialized()负责初始化一个WidgetsBinding的全局单例，紧接着会调用WidgetsBinding的attachRootWidget方法，该方法负责将根Widget添加到RenderView上，代码如下： void attachRootWidget(Widget rootWidget) { _renderViewElement = RenderObjectToWidgetAdapter( container: renderView, debugShortDescription: '[root]', child: rootWidget ).attachToRenderTree(buildOwner, renderViewElement); } 注意，代码中的有renderView和renderViewElement两个变量，renderView是一个RenderObject，它是渲染树的根，而renderViewElement是renderView对应的Element对象，可见该方法主要完成了根widget到根 RenderObject再到根Element的整个关联过程。我们看看attachToRenderTree的源码实现： RenderObjectToWidgetElement attachToRenderTree(BuildOwner owner, [RenderObjectToWidgetElement element]) { if (element == null) { owner.lockState(() { element = createElement(); assert(element != null); element.assignOwner(owner); }); owner.buildScope(element, () { element.mount(null, null); }); } else { element._newWidget = this; element.markNeedsBuild(); } return element; } 该方法负责创建根element，即RenderObjectToWidgetElement，并且将element与widget 进行关联，即创建出 widget树对应的element树。如果element 已经创建过了，则将根element 中关联的widget 设为新的，由此可以看出element 只会创建一次，后面会进行复用。那么BuildOwner是什么呢？其实他就是widget framework的管理类，它跟踪哪些widget需要重新构建。 渲染 回到runApp的实现中，当调用完attachRootWidget后，最后一行会调用 WidgetsFlutterBinding 实例的 scheduleWarmUpFrame() 方法，该方法的实现在SchedulerBinding 中，它被调用后会立即进行一次绘制（而不是等待\"vsync\" 信号），在此次绘制结束前，该方法会锁定事件分发，也就是说在本次绘制结束完成之前Flutter将不会响应各种事件，这可以保证在绘制过程中不会再触发新的重绘。下面是scheduleWarmUpFrame() 方法的部分实现(省略了无关代码)： void scheduleWarmUpFrame() { ... Timer.run(() { handleBeginFrame(null); }); Timer.run(() { handleDrawFrame(); resetEpoch(); }); // 锁定事件 lockEvents(() async { await endOfFrame; Timeline.finishSync(); }); ... } 可以看到该方法中主要调用了handleBeginFrame() 和 handleDrawFrame() 两个方法，在看这两个方法之前我们首先了解一下Frame 和 FrameCallback 的概念： Frame: 一次绘制过程，我们称其为一帧。Flutter engine受显示器垂直同步信号\"VSync\"的趋势不断的触发绘制。我们之前说的Flutter可以实现60fps（Frame Per-Second），就是指一秒钟可以触发60次重绘，FPS值越大，界面就越流畅。 FrameCallback：SchedulerBinding 类中有三个FrameCallback回调队列， 在一次绘制过程中，这三个回调队列会放在不同时机被执行： transientCallbacks：用于存放一些临时回调，一般存放动画回调。可以通过SchedulerBinding.instance.scheduleFrameCallback 添加回调。 persistentCallbacks：用于存放一些持久的回调，不能在此类回调中再请求新的绘制帧，持久回调一经注册则不能移除。SchedulerBinding.instance.addPersitentFrameCallback()，这个回调中处理了布局与绘制工作。 postFrameCallbacks：在Frame结束时只会被调用一次，调用后会被系统移除，可由 SchedulerBinding.instance.addPostFrameCallback() 注册，注意，不要在此类回调中再触发新的Frame，这可以会导致循环刷新。 现在请读者自行查看handleBeginFrame() 和 handleDrawFrame() 两个方法的源码，可以发现前者主要是执行了transientCallbacks队列，而后者执行了 persistentCallbacks 和 postFrameCallbacks 队列。 绘制 渲染和绘制逻辑在RendererBinding中实现，查看其源发，发现在其initInstances()方法中有如下代码： void initInstances() { ... //省略无关代码 //监听Window对象的事件 ui.window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; //添加PersistentFrameCallback addPersistentFrameCallback(_handlePersistentFrameCallback); } 我们看最后一行，通过addPersistentFrameCallback 向persistentCallbacks队列添加了一个回调 _handlePersistentFrameCallback: void _handlePersistentFrameCallback(Duration timeStamp) { drawFrame(); } 该方法直接调用了RendererBinding的drawFrame()方法： void drawFrame() { assert(renderView != null); pipelineOwner.flushLayout(); //布局 pipelineOwner.flushCompositingBits(); //重绘之前的预处理操作，检查RenderObject是否需要重绘 pipelineOwner.flushPaint(); // 重绘 renderView.compositeFrame(); // 将需要绘制的比特数据发给GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS. } 我们看看这些方法分别做了什么： flushLayout() void flushLayout() { ... while (_nodesNeedingLayout.isNotEmpty) { final List dirtyNodes = _nodesNeedingLayout; _nodesNeedingLayout = []; for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => a.depth - b.depth)) { if (node._needsLayout && node.owner == this) node._layoutWithoutResize(); } } } } 源码很简单，该方法主要任务是更新了所有被标记为“dirty”的RenderObject的布局信息。主要的动作发生在node._layoutWithoutResize()方法中，该方法中会调用performLayout()进行重新布局。 flushCompositingBits() void flushCompositingBits() { _nodesNeedingCompositingBitsUpdate.sort( (RenderObject a, RenderObject b) => a.depth - b.depth ); for (RenderObject node in _nodesNeedingCompositingBitsUpdate) { if (node._needsCompositingBitsUpdate && node.owner == this) node._updateCompositingBits(); //更新RenderObject.needsCompositing属性值 } _nodesNeedingCompositingBitsUpdate.clear(); } 检查RenderObject是否需要重绘，然后更新RenderObject.needsCompositing属性，如果该属性值被标记为true则需要重绘。 flushPaint() void flushPaint() { ... try { final List dirtyNodes = _nodesNeedingPaint; _nodesNeedingPaint = []; // 反向遍历需要重绘的RenderObject for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => b.depth - a.depth)) { if (node._needsPaint && node.owner == this) { if (node._layer.attached) { // 真正的绘制逻辑 PaintingContext.repaintCompositedChild(node); } else { node._skippedPaintingOnLayer(); } } } } } 该方法进行了最终的绘制，可以看出它不是重绘了所有 RenderObject，而是只重绘了需要重绘的 RenderObject。真正的绘制是通过PaintingContext.repaintCompositedChild()来绘制的，该方法最终会调用Flutter engine提供的Canvas API来完成绘制。 compositeFrame() void compositeFrame() { ... try { final ui.SceneBuilder builder = ui.SceneBuilder(); final ui.Scene scene = layer.buildScene(builder); if (automaticSystemUiAdjustment) _updateSystemChrome(); ui.window.render(scene); //调用Flutter engine的渲染API scene.dispose(); } finally { Timeline.finishSync(); } } 这个方法中有一个Scene对象，Scene对象是一个数据结构，保存最终渲染后的像素信息。这个方法将Canvas画好的Scene传给window.render()方法，该方法会直接将scene信息发送给Flutter engine，最终由engine将图像画在设备屏幕上。 最后 需要注意的是：由于RendererBinding只是一个mixin，而with它的是WidgetsBinding，所以我们需要看看WidgetsBinding中是否重写该方法，查看WidgetsBinding的drawFrame()方法源码： @override void drawFrame() { ...//省略无关代码 try { if (renderViewElement != null) buildOwner.buildScope(renderViewElement); super.drawFrame(); //调用RendererBinding的drawFrame()方法 buildOwner.finalizeTree(); } } 我们发现在调用RendererBinding.drawFrame()方法前会调用 buildOwner.buildScope() （非首次绘制），该方法会将被标记为“dirty” 的 element 进行 rebuild() 。 总结 本节介绍了Flutter APP从启动到显示到屏幕上的主流程，读者可以结合前面章节对Widget、Element以及RenderObject的介绍来加强细节理解。 "},"chapter14/image_and_cache.html":{"url":"chapter14/image_and_cache.html","title":"14.5：Flutter图片加载与缓存","keywords":"","body":"14.5 图片加载原理与缓存 在本书前面章节已经介绍过Image 组件，并提到Flutter框架对加载过的图片是有缓存的（内存），默认最大缓存数量是1000，最大缓存空间为100M。本节便详细介绍Image的原理及图片缓存机制，下面我们先看看ImageProvider 类。 14.5.1 ImageProvider 我们已经知道Image 组件的image 参数是一个必选参数，它是ImageProvider类型。下面我们便详细介绍一下ImageProvider，ImageProvider是一个抽象类，定义了图片数据获取和加载的相关接口。它的主要职责有两个： 提供图片数据源 缓存图片 我们看看ImageProvider抽象类的详细定义： abstract class ImageProvider { ImageStream resolve(ImageConfiguration configuration) { // 实现代码省略 } Future evict({ ImageCache cache, ImageConfiguration configuration = ImageConfiguration.empty }) async { // 实现代码省略 } Future obtainKey(ImageConfiguration configuration); @protected ImageStreamCompleter load(T key); // 需子类实现 } load(T key)方法 加载图片数据源的接口，不同的数据源的加载方法不同，每个ImageProvider的子类必须实现它。比如NetworkImage类和AssetImage类，它们都是ImageProvider的子类，但它们需要从不同的数据源来加载图片数据：NetworkImage是从网络来加载图片数据，而AssetImage则是从最终的应用包里来加载（加载打到应用安装包里的资源图片）。 我们以NetworkImage为例，看看其load方法的实现： @override ImageStreamCompleter load(image_provider.NetworkImage key) { final StreamController chunkEvents = StreamController(); return MultiFrameImageStreamCompleter( codec: _loadAsync(key, chunkEvents), //调用 chunkEvents: chunkEvents.stream, scale: key.scale, ... //省略无关代码 ); } 我们看到，load方法的返回值类型是ImageStreamCompleter ，它是一个抽象类，定义了管理图片加载过程的一些接口，Image Widget中正是通过它来监听图片加载状态的（我们将在下面介绍Image 原理时详细介绍）。 MultiFrameImageStreamCompleter 是 ImageStreamCompleter的一个子类，是flutter sdk预置的类，通过该类，我们以方便、轻松地创建出一个ImageStreamCompleter实例来做为load方法的返回值。 我们可以看到，MultiFrameImageStreamCompleter 需要一个codec参数，该参数类型为Future。Codec 是处理图片编解码的类的一个handler，实际上，它只是一个flutter engine API 的包装类，也就是说图片的编解码逻辑不是在Dart 代码部分实现，而是在flutter engine中实现的。Codec类部分定义如下： @pragma('vm:entry-point') class Codec extends NativeFieldWrapperClass2 { // 此类由flutter engine创建，不应该手动实例化此类或直接继承此类。 @pragma('vm:entry-point') Codec._(); /// 图片中的帧数(动态图会有多帧) int get frameCount native 'Codec_frameCount'; /// 动画重复的次数 /// * 0 表示只执行一次 /// * -1 表示循环执行 int get repetitionCount native 'Codec_repetitionCount'; /// 获取下一个动画帧 Future getNextFrame() { return _futurize(_getNextFrame); } String _getNextFrame(_Callback callback) native 'Codec_getNextFrame'; 我们可以看到Codec最终的结果是一个或多个（动图）帧，而这些帧最终会绘制到屏幕上。 MultiFrameImageStreamCompleter 的 codec参数值为_loadAsync方法的返回值，我们继续看_loadAsync方法的实现： Future _loadAsync( NetworkImage key, StreamController chunkEvents, ) async { try { //下载图片 final Uri resolved = Uri.base.resolve(key.url); final HttpClientRequest request = await _httpClient.getUrl(resolved); headers?.forEach((String name, String value) { request.headers.add(name, value); }); final HttpClientResponse response = await request.close(); if (response.statusCode != HttpStatus.ok) throw Exception(...); // 接收图片数据 final Uint8List bytes = await consolidateHttpClientResponseBytes( response, onBytesReceived: (int cumulative, int total) { chunkEvents.add(ImageChunkEvent( cumulativeBytesLoaded: cumulative, expectedTotalBytes: total, )); }, ); if (bytes.lengthInBytes == 0) throw Exception('NetworkImage is an empty file: $resolved'); // 对图片数据进行解码 return PaintingBinding.instance.instantiateImageCodec(bytes); } finally { chunkEvents.close(); } } 可以看到_loadAsync方法主要做了两件事： 下载图片。 对下载的图片数据进行解码。 下载逻辑比较简单：通过HttpClient从网上下载图片，另外下载请求会设置一些自定义的header，开发者可以通过NetworkImage的headers命名参数来传递。 在图片下载完成后调用了PaintingBinding.instance.instantiateImageCodec(bytes)对图片进行解码，值得注意的是instantiateImageCodec(...)也是一个Native API的包装，实际上会调用Flutter engine的instantiateImageCodec方法，源码如下： String _instantiateImageCodec(Uint8List list, _Callback callback, _ImageInfo imageInfo, int targetWidth, int targetHeight) native 'instantiateImageCodec'; obtainKey(ImageConfiguration)方法 该接口主要是为了配合实现图片缓存，ImageProvider从数据源加载完数据后，会在全局的ImageCache中缓存图片数据，而图片数据缓存是一个Map，而Map的key便是调用此方法的返回值，不同的key代表不同的图片数据缓存。 resolve(ImageConfiguration) 方法 resolve方法是ImageProvider的暴露的给Image的主入口方法，它接受一个ImageConfiguration参数，返回ImageStream，即图片数据流。我们重点看一下resolve执行流程： ImageStream resolve(ImageConfiguration configuration) { ... //省略无关代码 final ImageStream stream = ImageStream(); T obtainedKey; // //定义错误处理函数 Future handleError(dynamic exception, StackTrace stack) async { ... //省略无关代码 stream.setCompleter(imageCompleter); imageCompleter.setError(...); } // 创建一个新Zone，主要是为了当发生错误时不会干扰MainZone final Zone dangerZone = Zone.current.fork(...); dangerZone.runGuarded(() { Future key; // 先验证是否已经有缓存 try { // 生成缓存key，后面会根据此key来检测是否有缓存 key = obtainKey(configuration); } catch (error, stackTrace) { handleError(error, stackTrace); return; } key.then((T key) { obtainedKey = key; // 缓存的处理逻辑在这里，记为A，下面详细介绍 final ImageStreamCompleter completer = PaintingBinding.instance .imageCache.putIfAbsent(key, () => load(key), onError: handleError); if (completer != null) { stream.setCompleter(completer); } }).catchError(handleError); }); return stream; } ImageConfiguration 包含图片和设备的相关信息，如图片的大小、所在的AssetBundle(只有打到安装包的图片存在)以及当前的设备平台、devicePixelRatio（设备像素比等）。Flutter SDK提供了一个便捷函数createLocalImageConfiguration来创建ImageConfiguration 对象： ImageConfiguration createLocalImageConfiguration(BuildContext context, { Size size }) { return ImageConfiguration( bundle: DefaultAssetBundle.of(context), devicePixelRatio: MediaQuery.of(context, nullOk: true)?.devicePixelRatio ?? 1.0, locale: Localizations.localeOf(context, nullOk: true), textDirection: Directionality.of(context), size: size, platform: defaultTargetPlatform, ); } 我们可以发现这些信息基本都是通过Context来获取。 上面代码A处就是处理缓存的主要代码，这里的PaintingBinding.instance.imageCache 是 ImageCache的一个实例，它是PaintingBinding的一个属性，而Flutter框架中的PaintingBinding.instance是一个单例，imageCache事实上也是一个单例，也就是说图片缓存是全局的，统一由PaintingBinding.instance.imageCache 来管理。 下面我们看看ImageCache类定义： const int _kDefaultSize = 1000; const int _kDefaultSizeBytes = 100 _pendingImages = {}; // 缓存队列 final Map _cache = {}; // 缓存数量上限(1000) int _maximumSize = _kDefaultSize; // 缓存容量上限 (100 MB) int _maximumSizeBytes = _kDefaultSizeBytes; // 缓存上限设置的setter set maximumSize(int value) {...} set maximumSizeBytes(int value) {...} ... // 省略部分定义 // 清除所有缓存 void clear() { // ...省略具体实现代码 } // 清除指定key对应的图片缓存 bool evict(Object key) { // ...省略具体实现代码 } ImageStreamCompleter putIfAbsent(Object key, ImageStreamCompleter loader(), { ImageErrorListener onError }) { assert(key != null); assert(loader != null); ImageStreamCompleter result = _pendingImages[key]?.completer; // 图片还未加载成功，直接返回 if (result != null) return result; // 有缓存，继续往下走 // 先移除缓存，后再添加，可以让最新使用过的缓存在_map中的位置更近一些，清理时会LRU来清除 final _CachedImage image = _cache.remove(key); if (image != null) { _cache[key] = image; return image.completer; } try { result = loader(); } catch (error, stackTrace) { if (onError != null) { onError(error, stackTrace); return null; } else { rethrow; } } void listener(ImageInfo info, bool syncCall) { final int imageSize = info?.image == null ? 0 : info.image.height * info.image.width * 4; final _CachedImage image = _CachedImage(result, imageSize); // 下面是缓存处理的逻辑 if (maximumSizeBytes > 0 && imageSize > maximumSizeBytes) { _maximumSizeBytes = imageSize + 1000; } _currentSizeBytes += imageSize; final _PendingImage pendingImage = _pendingImages.remove(key); if (pendingImage != null) { pendingImage.removeListener(); } _cache[key] = image; _checkCacheSize(); } if (maximumSize > 0 && maximumSizeBytes > 0) { final ImageStreamListener streamListener = ImageStreamListener(listener); _pendingImages[key] = _PendingImage(result, streamListener); // Listener is removed in [_PendingImage.removeListener]. result.addListener(streamListener); } return result; } // 当缓存数量超过最大值或缓存的大小超过最大缓存容量，会调用此方法清理到缓存上限以内 void _checkCacheSize() { while (_currentSizeBytes > _maximumSizeBytes || _cache.length > _maximumSize) { final Object key = _cache.keys.first; final _CachedImage image = _cache[key]; _currentSizeBytes -= image.sizeBytes; _cache.remove(key); } ... //省略无关代码 } } 有缓存则使用缓存，没有缓存则调用load方法加载图片，加载成功后: 先判断图片数据有缓存，如果有，则直接返回ImageStream。 如果没有缓存，则调用load(T key)方法从数据源加载图片数据，加载成功后先缓存，然后返回ImageStream。 另外，我们可以看到ImageCache类中有设置缓存上限的setter，所以，如果我们可以自定义缓存上限： PaintingBinding.instance.imageCache.maximumSize=2000; //最多2000张 PaintingBinding.instance.imageCache.maximumSizeBytes = 200 现在我们看一下缓存的key，因为Map中相同key的值会被覆盖，也就是说key是图片缓存的一个唯一标识，只要是不同key，那么图片数据就会分别缓存（即使事实上是同一张图片）。那么图片的唯一标识是什么呢？跟踪源码，很容易发现key正是ImageProvider.obtainKey()方法的返回值，而此方法需要ImageProvider子类去重写，这也就意味着不通的ImageProvider对key的定义逻辑会不同。其实也很好理解，比如对于NetworkImage，将图片的url作为key会很合适，而对于AssetImage，则应该将“包名+路径”作为唯一的key。下面我们以NetworkImage为例，看一下它的obtainKey()实现： @override Future obtainKey(image_provider.ImageConfiguration configuration) { return SynchronousFuture(this); } 代码很简单，创建了一个同步的future，然后直接将自身做为key返回。因为Map中在判断key（此时是NetworkImage对象）是否相等时会使用“==”运算符，那么定义key的逻辑就是NetworkImage的“==”运算符： @override bool operator ==(dynamic other) { ... //省略无关代码 final NetworkImage typedOther = other; return url == typedOther.url && scale == typedOther.scale; } 很清晰，对于网络图片来说，会将其“url+缩放比例”作为缓存的key。也就是说如果两张图片的url或scale只要有一个不同，便会重新下载并分别缓存。 另外，我们需要注意的是，图片缓存是在内存中，并没有进行本地文件持久化存储，这也是为什么网络图片在应用重启后需要重新联网下载的原因。 同时也意味着在应用生命周期内，如果缓存没有超过上限，相同u的图片只会被下载一次。 总结 上面主要结合源码，探索了ImageProvider的主要功能和原理，如果要用一句话来总结ImageProvider功能，那么应该是：加载图片数据并进行缓存、解码。在此再次提醒读者，Flutter的源码是非常好的第一手资料，建议读者多多探索，另外，在阅读源码学西的同时一定要有总结，这样才不至于在源码中迷失。 14.5.2 Image组件原理 前面章节中我们介绍过Image的基础用法，现在我们更深入一些，研究一下Image是如何和ImageProvider配合来获取最终解码后的数据，然后又如何将图片绘制到屏幕上的。 本节换一个思路，我们先不去直接看Image的源码，而根据已经掌握的知识来实现一个简版的“Image组件” MyImage，代码大致如下： class MyImage extends StatefulWidget { const MyImage({ Key key, @required this.imageProvider, }) : assert(imageProvider != null), super(key: key); final ImageProvider imageProvider; @override _MyImageState createState() => _MyImageState(); } class _MyImageState extends State { ImageStream _imageStream; ImageInfo _imageInfo; @override void didChangeDependencies() { super.didChangeDependencies(); // 依赖改变时，图片的配置信息可能会发生改变 _getImage(); } @override void didUpdateWidget(MyImage oldWidget) { super.didUpdateWidget(oldWidget); if (widget.imageProvider != oldWidget.imageProvider) _getImage(); } void _getImage() { final ImageStream oldImageStream = _imageStream; // 调用imageProvider.resolve方法，获得ImageStream。 _imageStream = widget.imageProvider.resolve(createLocalImageConfiguration(context)); //判断新旧ImageStream是否相同，如果不同，则需要调整流的监听器 if (_imageStream.key != oldImageStream?.key) { final ImageStreamListener listener = ImageStreamListener(_updateImage); oldImageStream?.removeListener(listener); _imageStream.addListener(listener); } } void _updateImage(ImageInfo imageInfo, bool synchronousCall) { setState(() { // Trigger a build whenever the image changes. _imageInfo = imageInfo; }); } @override void dispose() { _imageStream.removeListener(ImageStreamListener(_updateImage)); super.dispose(); } @override Widget build(BuildContext context) { return RawImage( image: _imageInfo?.image, // this is a dart:ui Image object scale: _imageInfo?.scale ?? 1.0, ); } } 上面代码流程如下： 通过imageProvider.resolve方法可以得到一个ImageStream（图片数据流），然后监听ImageStream的变化。当图片数据源发生变化时，ImageStream会触发相应的事件，而本例中我们只设置了图片成功的监听器_updateImage，而_updateImage中只更新了_imageInfo。值得注意的是，如果是静态图，ImageStream只会触发一次时间，如果是动态图，则会触发多次事件，每一次都会有一个解码后的图片帧。 _imageInfo 更新后会rebuild，此时会创建一个RawImage Widget。RawImage最终会通过RenderImage来将图片绘制在屏幕上。如果继续跟进RenderImage类，我们会发现RenderImage的paint 方法中调用了paintImage方法，而paintImage方法中通过Canvas的drawImageRect(…)、drawImageNine(...)等方法来完成最终的绘制。 最终的绘制由RawImage来完成。 下面测试一下MyImage： class ImageInternalTestRoute extends StatelessWidget { @override Widget build(BuildContext context) { return Column( children: [ MyImage( imageProvider: NetworkImage( \"https://avatars2.githubusercontent.com/u/20411648?s=460&v=4\", ), ) ], ); } } 运行效果如图14-4所示： 成功了！ 现在，想必Image Widget的源码已经没必要在花费篇章去介绍了，读者有兴趣可以自行去阅读。 总结 本节主要介绍了Flutter 图片的加载、缓存和绘制流程。其中ImageProvider主要负责图片数据的加载和缓存，而绘制部分逻辑主要是由RawImage来完成。 而Image正是连接起ImageProvider和RawImage 的桥梁。 "},"chapter15/intro.html":{"url":"chapter15/intro.html","title":"第十五章：一个完整的Flutter应用","keywords":"","body":"15.1 Github客户端示例 本章新建一个Flutter工程，实现一个简单的Github客户端。这个实例的主要目标有两个： 带领读者了解如何使用Flutter来开发一个完整APP，了解Flutter应用开发流程及工程结构等。 对前面章节所学内容的一个应用及总结。 需要注意的是，由于Github本身功能非常多，我们的焦点并不是去实现Github的所有业务功能。因此，我们只需要实现一个APP的骨架，能达到上面这两点即可。下面对我们要实现的功能如下： 实现Github账号登录、退出登录功能 登录后可以查看自己的项目主页 支持换肤 支持多语言 登录状态可以持久化； 要实现上面这些功能会涉及到如下技术点： 网络请求；需要请求Github API。 Json转Dart Model类； 全局状态管理；语言、主题、登录态等都需要全局共享。 持久化存储；保存登录信息，用户信息等。 支持国际化、Intl包的使用 现在，目前已经确定，在接下来章节中，我们将分模块一步一步实现上述功能。 "},"chapter15/code_structure.html":{"url":"chapter15/code_structure.html","title":"15.2：APP代码结构","keywords":"","body":"15.2 Flutter APP代码结构 我们先来创建一个全新的Flutter工程，命名为\"github_client_app\"；创建新工程的步骤视读者使用的编辑器而定，都比较简单，在此不再赘述。创建完成后，工程结构如下： github_client_app ├── android ├── ios ├── lib └── test 由于我们需要使用外部图片和Icon资源，所以我们在项目根目录下分别创建”imgs“和”fonts“文件件，前者用于保存图片，后者用于保存Icon文件。关于图片和Icon，读者可以参考第三章中相应的内容。 由于在网络数据传输和持久化时，我们需要通过Json来传输、保存数据；但是在应用开发时我们又需要将Json转成Dart Model类，现在我们使用在第十一章中”Json转Model“小节中介绍的方案，所以，我们需要在根目录下再创建一个用于保存Json文件的”jsons“文件夹。 多语言支持我们使用第十三章”国际化“中介绍的方案，所以还需要在根目录下创建一个\"i10n\"文件夹，用于保存各国语言对应的arb文件。 现在工程目录变为： github_client_app ├── android ├── fonts ├── i10n-arb ├── imgs ├── ios ├── jsons ├── lib └── test 由于我们的Dart代码都在“lib”文件夹下，笔者根据技术选型和经验在lib文件下创建了如下目录： lib ├── common ├── i10n ├── models ├── states ├── routes └── widgets 文件夹 作用 common 一些工具类，如通用方法类、网络接口类、保存全局变量的静态类等 i10n 国际化相关的类都在此目录下 models Json文件对应的Dart Model类会在此目录下 states 保存APP中需要跨组件共享的状态类 routes 存放所有路由页面类 widgets APP内封装的一些Widget组件都在该目录下 注意，使用不同的框架或技术选型会对代码有不同的组织方式，因此，本节介绍的代码组织结构并不是固定或者“最佳”的，在实战中，读者可以自己根据情况调整源码结构。但是无论采取何种源码组织结构，但清晰和解耦是一个通用原则，我们应该让自己的代码结构清晰，以便交流和维护。 "},"chapter15/models.html":{"url":"chapter15/models.html","title":"15.3：Model类定义","keywords":"","body":"15.3 Model类定义 本节我们先梳理一下APP中将用到的数据，然后生成相应的Dart Model类。Json文件转Dart Model的方案采用前面介绍过的 json_model 包方案 Github账号信息 登录Github后，我们需要获取当前登录者的Github账号信息，Github API接口返回Json结构如下： { \"login\": \"octocat\", //用户登录名 \"avatar_url\": \"https://github.com/images/error/octocat_happy.gif\", //用户头像地址 \"type\": \"User\", //用户类型，可能是组织 \"name\": \"monalisa octocat\", //用户名字 \"company\": \"GitHub\", //公司 \"blog\": \"https://github.com/blog\", //博客地址 \"location\": \"San Francisco\", // 用户所处地理位置 \"email\": \"octocat@github.com\", // 邮箱 \"hireable\": false, \"bio\": \"There once was...\", // 用户简介 \"public_repos\": 2, // 公开项目数 \"followers\": 20, //关注该用户的人数 \"following\": 0, // 该用户关注的人数 \"created_at\": \"2008-01-14T04:33:35Z\", // 账号创建时间 \"updated_at\": \"2008-01-14T04:33:35Z\", // 账号信息更新时间 \"total_private_repos\": 100, //该用户总的私有项目数(包括参与的其它组织的私有项目) \"owned_private_repos\": 100 //该用户自己的私有项目数 ... //省略其它字段 } 我们在“jsons”目录下创建一个“user.json”文件保存上述信息。 API缓存策略信息 由于Github服务器在国内访问速度较慢，我们对Github API应用一些简单的缓存策略。我们在“jsons”目录下创建一个“cacheConfig.json”文件缓存策略信息，定义如下： { \"enable\":true, // 是否启用缓存 \"maxAge\":1000, // 缓存的最长时间，单位（秒） \"maxCount\":100 // 最大缓存数 } 用户信息 用户信息(Profile)应包括如下信息： Github账号信息；由于我们的APP可以切换账号登录，且登录后再次打开则不需要登录，所以我们需要对用户账号信息和登录状态进行持久化。 应用使用配置信息；没一个用户都应有自己的APP配置信息，如主题、语言、以及数据缓存策略等。 用户注销登录后，为了便于用户在退出APP前再次登录，我们需要记住上次登录的用户名。 需要注意的是，目前Github有三种登录方式，分别是账号密码登录、oauth授权登录、二次认证登录；这三种登录方式的安全性依次加强，但是在本示例中，为了简单起见，我们使用账号密码登录，因此我们需要保存用户的密码。 注意：在这里需要提醒读者，在登录场景中，保护用户账号安全是一个非常重要且永恒的话题，在实际开发中应严格杜绝直接明文存储用户账密的行为。 我们在“jsons”目录下创建一个“profile.json”文件，结构如下： { \"user\":\"$user\", //Github账号信息，结构见\"user.json\" \"token\":\"\", // 登录用户的token(oauth)或密码 \"theme\":5678, //主题色值 \"cache\":\"$cacheConfig\", // 缓存策略信息，结构见\"cacheConfig.json\" \"lastLogin\":\"\", //最近一次的注销登录的用户名 \"locale\":\"\" // APP语言信息 } 项目信息 由于APP主页要显示其所有项目信息，我们在“jsons”目录下创建一个“repo.json”文件保存项目信息。通过参考Github 获取项目信息的API文档，定义出最终的“repo.json”文件结构，如下： { \"id\": 1296269, \"name\": \"Hello-World\", //项目名称 \"full_name\": \"octocat/Hello-World\", //项目完成名称 \"owner\": \"$user\", // 项目拥有者，结构见\"user.json\" \"parent\":\"$repo\", // 如果是fork的项目，则此字段表示fork的父项目信息 \"private\": false, // 是否私有项目 \"description\": \"This your first repo!\", //项目描述 \"fork\": false, // 该项目是否为fork的项目 \"language\": \"JavaScript\",//该项目的主要编程语言 \"forks_count\": 9, // fork了该项目的数量 \"stargazers_count\": 80, //该项目的star数量 \"size\": 108, // 项目占用的存储大小 \"default_branch\": \"master\", //项目的默认分支 \"open_issues_count\": 2, //该项目当前打开的issue数量 \"pushed_at\": \"2011-01-26T19:06:43Z\", \"created_at\": \"2011-01-26T19:01:12Z\", \"updated_at\": \"2011-01-26T19:14:43Z\", \"subscribers_count\": 42, //订阅（关注）该项目的人数 \"license\": { // 该项目的开源许可证 \"key\": \"mit\", \"name\": \"MIT License\", \"spdx_id\": \"MIT\", \"url\": \"https://api.github.com/licenses/mit\", \"node_id\": \"MDc6TGljZW5zZW1pdA==\" } ...//省略其它字段 } 生成Dart Model类 现在，我们需要的Json数据已经定义完毕，现在只需要运行json_model package提供的命令来通过json文件生成相应的Dart类： flutter packages pub run json_model 命令执行成功后，可以看到lib/models文件夹下会生成相应的Dart Model类： ├── models │ ├── cacheConfig.dart │ ├── cacheConfig.g.dart │ ├── index.dart │ ├── profile.dart │ ├── profile.g.dart │ ├── repo.dart │ ├── repo.g.dart │ ├── user.dart │ └── user.g.dart 数据持久化 我们使用shared_preferences包来对登录用户的Profile信息进行持久化。shared_preferences是一个Flutter插件，它通过Android和iOS平台提供的机制来实现数据持久化。由于shared_preferences的使用非常简单，读者可以自行查看其文档，在此不再赘述。 "},"chapter15/globals.html":{"url":"chapter15/globals.html","title":"15.4：全局变量及共享状态","keywords":"","body":"15.4 全局变量及共享状态 应用程序中通常会包含一些贯穿APP生命周期的变量信息，这些信息在APP大多数地方可能都会被用到，比如当前用户信息、Local信息等。在Flutter中我们把需要全局共享的信息氛围两类：全局变量和共享状态。全局变量就是单纯指会贯穿整个APP生命周期的变量，用于单纯的保存一些信息，或者封装一些全局工具和方法的对象。而共享状态则是指哪些需要跨组件或跨路由共享的信息，这些信息通常也是全局变量，而共享状态和全局变量的不同在于前者者发生改变时需要通知所有使用该状态的组件，而后者不需要。为此，我们将全局变量和共享状态分开单独管理。 15.4.1 全局变量-Global类 我们在“lib/common”目录下创建一个Global类，它主要管理APP的全局变量，定义如下： // 提供四套可选主题色 const _themes = [ Colors.blue, Colors.cyan, Colors.teal, Colors.green, Colors.red, ]; class Global { static SharedPreferences _prefs; static Profile profile = Profile(); // 网络缓存对象 static NetCache netCache = NetCache(); // 可选的主题列表 static List get themes => _themes; // 是否为release版 static bool get isRelease => bool.fromEnvironment(\"dart.vm.product\"); //初始化全局信息，会在APP启动时执行 static Future init() async { _prefs = await SharedPreferences.getInstance(); var _profile = _prefs.getString(\"profile\"); if (_profile != null) { try { profile = Profile.fromJson(jsonDecode(_profile)); } catch (e) { print(e); } } // 如果没有缓存策略，设置默认缓存策略 profile.cache = profile.cache ?? CacheConfig() ..enable = true ..maxAge = 3600 ..maxCount = 100; //初始化网络请求相关配置 Git.init(); } // 持久化Profile信息 static saveProfile() => _prefs.setString(\"profile\", jsonEncode(profile.toJson())); } Global类的各个字段的意义都有注释，在此不再赘述，需要注意的是init()需要在App启动时就要执行，所以应用的main方法如下： void main() => Global.init().then((e) => runApp(MyApp())); 在此，一定要确保Global.init()方法不能抛出异常，否则 runApp(MyApp())根本执行不到。 15.4.2 共享状态 有了全局变量，我们还需要考虑如何跨组件共享状态。当然，如果我们将要共享的状态全部用全局变量替代也是可以的，但是这在Flutter开发中并不是一个好主意，因为组件的状态是和UI相关，而在状态改变时我们会期望依赖该状态的UI组件会自动更新，如果使用全局变量，那么我们必须得去手动处理状态变动通知、接收机制以及变量和组件依赖关系。因此，本实例中，我们使用前面介绍过的Provider包来实现跨组件状态共享，因此我们需要定义相关的Provider。在本实例中，需要共享的状态有登录用户信息、APP主题信息、APP语言信息。由于这些信息改变后都要立即通知其它依赖的该信息的Widget更新，所以我们应该使用ChangeNotifierProvider，另外，这些信息改变后都是需要更新Profile信息并进行持久化的。综上所述，我们可以定义一个ProfileChangeNotifier基类，然后让需要共享的Model继承自该类即可，ProfileChangeNotifier定义如下： class ProfileChangeNotifier extends ChangeNotifier { Profile get _profile => Global.profile; @override void notifyListeners() { Global.saveProfile(); //保存Profile变更 super.notifyListeners(); //通知依赖的Widget更新 } } 用户状态 用户状态在登录状态发生变化时更新、通知其依赖项，我们定义如下： class UserModel extends ProfileChangeNotifier { User get user => _profile.user; // APP是否登录(如果有用户信息，则证明登录过) bool get isLogin => user != null; //用户信息发生变化，更新用户信息并通知依赖它的子孙Widgets更新 set user(User user) { if (user?.login != _profile.user?.login) { _profile.lastLogin = _profile.user?.login; _profile.user = user; notifyListeners(); } } } APP主题状态 主题状态在用户更换APP主题时更新、通知其依赖项，定义如下： class ThemeModel extends ProfileChangeNotifier { // 获取当前主题，如果为设置主题，则默认使用蓝色主题 ColorSwatch get theme => Global.themes .firstWhere((e) => e.value == _profile.theme, orElse: () => Colors.blue); // 主题改变后，通知其依赖项，新主题会立即生效 set theme(ColorSwatch color) { if (color != theme) { _profile.theme = color[500].value; notifyListeners(); } } } APP语言状态 当APP语言选为跟随系统（Auto）时，在系通语言改变时，APP语言会更新；当用户在APP中选定了具体语言时（美国英语或中文简体），则APP便会一直使用用户选定的语言，不会再随系统语言而变。语言状态类定义如下： class LocaleModel extends ProfileChangeNotifier { // 获取当前用户的APP语言配置Locale类，如果为null，则语言跟随系统语言 Locale getLocale() { if (_profile.locale == null) return null; var t = _profile.locale.split(\"_\"); return Locale(t[0], t[1]); } // 获取当前Locale的字符串表示 String get locale => _profile.locale; // 用户改变APP语言后，通知依赖项更新，新语言会立即生效 set locale(String locale) { if (locale != _profile.locale) { _profile.locale = locale; notifyListeners(); } } } "},"chapter15/network.html":{"url":"chapter15/network.html","title":"15.5：网络请求封装","keywords":"","body":"15.5 网络请求封装 本节我们会基于前面介绍过的dio网络库封装APP中用到的网络请求接口，并同时应用一个简单的缓存策略。下面我们先介绍一下网络接口缓存原来，然后再封装APP的业务请求接口。 15.5.1 网络接口缓存 由于在国内访问Github服务器速度较慢，所以我们应用一些简单的缓存策略：将请求的url作为key，对请求的返回值在一个指定时间段类进行缓存，另外设置一个最大缓存数，当超过最大缓存数后移除最早的一条缓存。但是也得提供一种针对特定接口或请求决定是否启用缓存的机制，这种机制可以指定哪些接口或那次请求不应用缓存，这种机制是很有必要的，比如登录接口就不应该缓存，又比如用户在下拉刷新时就不应该再应用缓存。在实现缓存之前我们先定义保存缓存信息的CacheObject类： class CacheObject { CacheObject(this.response) : timeStamp = DateTime.now().millisecondsSinceEpoch; Response response; int timeStamp; // 缓存创建时间 @override bool operator ==(other) { return response.hashCode == other.hashCode; } //将请求uri作为缓存的key @override int get hashCode => response.realUri.hashCode; } 接下来我们需要实现具体的缓存策略，由于我们使用的是dio package，所以我们可以直接通过拦截器来实现缓存策略： import 'dart:collection'; import 'package:dio/dio.dart'; import '../index.dart'; class CacheObject { CacheObject(this.response) : timeStamp = DateTime.now().millisecondsSinceEpoch; Response response; int timeStamp; @override bool operator ==(other) { return response.hashCode == other.hashCode; } @override int get hashCode => response.realUri.hashCode; } class NetCache extends Interceptor { // 为确保迭代器顺序和对象插入时间一致顺序一致，我们使用LinkedHashMap var cache = LinkedHashMap(); @override onRequest(RequestOptions options) { if (!Global.profile.cache.enable) return options; // refresh标记是否是\"下拉刷新\" bool refresh = options.extra[\"refresh\"] == true; //如果是下拉刷新，先删除相关缓存 if (refresh) { if (options.extra[\"list\"] == true) { //若是列表，则只要url中包含当前path的缓存全部删除（简单实现，并不精准） cache.removeWhere((key, v) => key.contains(options.path)); } else { // 如果不是列表，则只删除uri相同的缓存 delete(options.uri.toString()); } return options; } if (options.extra[\"noCache\"] != true && options.method.toLowerCase() == 'get') { String key = options.extra[\"cacheKey\"] ?? options.uri.toString(); var ob = cache[key]; if (ob != null) { //若缓存未过期，则返回缓存内容 if ((DateTime.now().millisecondsSinceEpoch - ob.timeStamp) / 1000 关于代码的解释都在注释中了，在此需要说明的是dio包的option.extra是专门用于扩展请求参数的，我们通过定义了“refresh”和“noCache”两个参数实现了”针对特定接口或请求决定是否启用缓存的机制“，这两个参数含义如下： 参数名 类型 解释 refresh bool 如果为true，则本次请求不使用缓存，但新的请求结果依然会被缓存 noCache bool 本次请求禁用缓存，请求结果也不会被缓存。 15.5.2 封装网络请求 一个完整的APP，可能会涉及很多网络请求，为了便于管理、收敛请求入口，工程上最好的作法就是将所有网络请求放到同一个源码文件中。由于我们的接口都是请求的Github 开发平台提供的API，所以我们定义一个Git类，专门用于Github API接口调用。另外，在调试过程中，我们通常需要一些工具来查看网络请求、响应报文，使用网络代理工具来调试网络数据问题是主流方式。配置代理需要在应用中指定代理服务器的地址和端口，另外Github API是HTTPS协议，所以在配置完代理后还应该禁用证书校验，这些配置我们在Git类初始化时执行（init()方法）。下面是Git类的源码： import 'dart:async'; import 'dart:convert'; import 'dart:io'; import 'package:dio/dio.dart'; import 'package:flutter/material.dart'; import '../index.dart'; class Git { // 在网络请求过程中可能会需要使用当前的context信息，比如在请求失败时 // 打开一个新路由，而打开新路由需要context信息。 Git([this.context]) { _options = Options(extra: {\"context\": context}); } BuildContext context; Options _options; static Dio dio = new Dio(BaseOptions( baseUrl: 'https://api.github.com/', headers: { HttpHeaders.acceptHeader: \"application/vnd.github.squirrel-girl-preview,\" \"application/vnd.github.symmetra-preview+json\", }, )); static void init() { // 添加缓存插件 dio.interceptors.add(Global.netCache); // 设置用户token（可能为null，代表未登录） dio.options.headers[HttpHeaders.authorizationHeader] = Global.profile.token; // 在调试模式下需要抓包调试，所以我们使用代理，并禁用HTTPS证书校验 if (!Global.isRelease) { (dio.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate = (client) { client.findProxy = (uri) { return \"PROXY 10.1.10.250:8888\"; }; //代理工具会提供一个抓包的自签名证书，会通不过证书校验，所以我们禁用证书校验 client.badCertificateCallback = (X509Certificate cert, String host, int port) => true; }; } } // 登录接口，登录成功后返回用户信息 Future login(String login, String pwd) async { String basic = 'Basic ' + base64.encode(utf8.encode('$login:$pwd')); var r = await dio.get( \"/users/$login\", options: _options.merge(headers: { HttpHeaders.authorizationHeader: basic }, extra: { \"noCache\": true, //本接口禁用缓存 }), ); //登录成功后更新公共头（authorization），此后的所有请求都会带上用户身份信息 dio.options.headers[HttpHeaders.authorizationHeader] = basic; //清空所有缓存 Global.netCache.cache.clear(); //更新profile中的token信息 Global.profile.token = basic; return User.fromJson(r.data); } //获取用户项目列表 Future> getRepos( {Map queryParameters, //query参数，用于接收分页信息 refresh = false}) async { if (refresh) { // 列表下拉刷新，需要删除缓存（拦截器中会读取这些信息） _options.extra.addAll({\"refresh\": true, \"list\": true}); } var r = await dio.get( \"user/repos\", queryParameters: queryParameters, options: _options, ); return r.data.map((e) => Repo.fromJson(e)).toList(); } } 可以看到我们在init()方法中，我们判断了是否是调试环境，然后做了一些针对调试环境的网络配置（设置代理和禁用证书校验）。而Git.init()方法是应用启动时被调用的（Global.init()方法中会调用Git.init()）。 另外需要注意，我们所有的网络请求是通过同一个dio实例（静态变量）发出的，在创建该dio实例时我们将Github API的基地址和API支持的Header进行了全局配置，这样所有通过该dio实例发出的请求都会默认使用者些配置。 在本实例中，我们只用到了登录接口和获取用户项目的接口，所以在Git类中只定义了login(…)和getRepos(…)方法，如果读者要在本实例的基础上扩充功能，读者可以将其它的接口请求方法添加到Git类中，这样便实现了网络请求接口在代码层面的集中管理和维护。 "},"chapter15/entry.html":{"url":"chapter15/entry.html","title":"15.6：App入口及首页","keywords":"","body":"15.6 APP入口及主页 本节来介绍一下APP入口及首页。 15.6.1 APP入口 main函数为APP入口函数，实现如下： void main() => Global.init().then((e) => runApp(MyApp())); 初始化完成后才会加载UI(MyApp)，MyApp 是应用的入口Widget，实现如下： class MyApp extends StatelessWidget { // This widget is the root of your application. @override Widget build(BuildContext context) { return MultiProvider( providers: [ ChangeNotifierProvider.value(value: ThemeModel()), ChangeNotifierProvider.value(value: UserModel()), ChangeNotifierProvider.value(value: LocaleModel()), ], child: Consumer2( builder: (BuildContext context, themeModel, localeModel, Widget child) { return MaterialApp( theme: ThemeData( primarySwatch: themeModel.theme, ), onGenerateTitle: (context){ return GmLocalizations.of(context).title; }, home: HomeRoute(), //应用主页 locale: localeModel.getLocale(), //我们只支持美国英语和中文简体 supportedLocales: [ const Locale('en', 'US'), // 美国英语 const Locale('zh', 'CN'), // 中文简体 //其它Locales ], localizationsDelegates: [ // 本地化的代理类 GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, GmLocalizationsDelegate() ], localeResolutionCallback: (Locale _locale, Iterable supportedLocales) { if (localeModel.getLocale() != null) { //如果已经选定语言，则不跟随系统 return localeModel.getLocale(); } else { Locale locale; //APP语言跟随系统语言，如果系统语言不是中文简体或美国英语， //则默认使用美国英语 if (supportedLocales.contains(_locale)) { locale= _locale; } else { locale= Locale('en', 'US'); } return locale; } }, // 注册命名路由表 routes: { \"login\": (context) => LoginRoute(), \"themes\": (context) => ThemeChangeRoute(), \"language\": (context) => LanguageRoute(), }, ); }, ), ); } } 在上面的代码中： 我们的根widget是MultiProvider，它将主题、用户、语言三种状态绑定到了应用的根上，如此一来，任何路由中都可以通过Provider.of()来获取这些状态，也就是说这三种状态是全局共享的！ HomeRoute是应用的主页。 在构建MaterialApp时，我们配置了APP支持的语言列表，以及监听了系统语言改变事件；另外MaterialApp消费（依赖）了ThemeModel和LocaleModel，所以当APP主题或语言改变时MaterialApp会重新构建 我们注册了命名路由表，以便在APP中可以直接通过路由名跳转。 为了支持多语言（本APP中我们支持美国英语和中文简体两种语言）我们实现了一个GmLocalizationsDelegate，子Widget中都可以通过GmLocalizations来动态获取APP当前语言对应的文案。关于GmLocalizationsDelegate和GmLocalizations的实现方式读者可以参考”国际化“一章中的介绍，此处不再赘述。 15.6.2 主页 为了简单起见，当APP启动后，如果之前已登录了APP，则显示该用户项目列表；如果之前未登录，则显示一个登录按钮，点击后跳转到登录页。另外，我们实现一个抽屉菜单，里面包含当前用户头像及APP的菜单。下面我们先看看要实现的效果，如图15-1、15-2所示： 我们在”lib/routes“下创建一个”home_page.dart“文件，实现如下： class HomeRoute extends StatefulWidget { @override _HomeRouteState createState() => _HomeRouteState(); } class _HomeRouteState extends State { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(GmLocalizations.of(context).home), ), body: _buildBody(), // 构建主页面 drawer: MyDrawer(), //抽屉菜单 ); } ...// 省略 } 上面代码中，主页的标题（title）我们是通过GmLocalizations.of(context).home来获得，GmLocalizations是我们提供的一个Localizations类，用于支持多语言，因此当APP语言改变时，凡是使用GmLocalizations动态获取的文案都会是相应语言的文案，这在前面”国际化“一章中已经介绍过，读者可以前翻查阅。 我们通过 _buildBody()方法来构建主页内容，_buildBody()方法实现代码如下： Widget _buildBody() { UserModel userModel = Provider.of(context); if (!userModel.isLogin) { //用户未登录，显示登录按钮 return Center( child: RaisedButton( child: Text(GmLocalizations.of(context).login), onPressed: () => Navigator.of(context).pushNamed(\"login\"), ), ); } else { //已登录，则展示项目列表 return InfiniteListView( onRetrieveData: (int page, List items, bool refresh) async { var data = await Git(context).getRepos( refresh: refresh, queryParameters: { 'page': page, 'page_size': 20, }, ); //把请求到的新数据添加到items中 items.addAll(data); // 如果接口返回的数量等于'page_size'，则认为还有数据，反之则认为最后一页 return data.length==20; }, itemBuilder: (List list, int index, BuildContext ctx) { // 项目信息列表项 return RepoItem(list[index]); }, ); } } } 上面代码注释很清楚：如果用户未登录，显示登录按钮；如果用户已登录，则展示项目列表。这里项目列表使用了InfiniteListView Widget，它是flukit package中提供的。InfiniteListView同时支持了下拉刷新和上拉加载更多两种功能。onRetrieveData 为数据获取回调，该回调函数接收三个参数： 参数名 类型 解释 page int 当前页号 items List 保存当前列表数据的List refresh bool 是否是下拉刷新触发 返回值类型为bool，为true时表示还有数据，为false时则表示后续没有数据了。onRetrieveData 回调中我们调用Git(context).getRepos(...)来获取用户项目列表，同时指定每次请求获取20条。当获取成功时，首先要将新获取的项目数据添加到items中，然后根据本次请求的项目条数是否等于期望的20条来判断还有没有更多的数据。在此需要注意，Git(context).getRepos(…)方法中需要refresh参数来判断是否使用缓存。 itemBuilder为列表项的builder，我们需要在该回调中构建每一个列表项Widget。由于列表项构建逻辑较负责，我们单独封装一个RepoItem Widget 专门用于构建列表项UI。RepoItem 实现如下： import '../index.dart'; class RepoItem extends StatefulWidget { // 将`repo.id`作为RepoItem的默认key RepoItem(this.repo) : super(key: ValueKey(repo.id)); final Repo repo; @override _RepoItemState createState() => _RepoItemState(); } class _RepoItemState extends State { @override Widget build(BuildContext context) { var subtitle; return Padding( padding: const EdgeInsets.only(top: 8.0), child: Material( color: Colors.white, shape: BorderDirectional( bottom: BorderSide( color: Theme.of(context).dividerColor, width: .5, ), ), child: Padding( padding: const EdgeInsets.only(top: 0.0, bottom: 16), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ ListTile( dense: true, leading: gmAvatar( //项目owner头像 widget.repo.owner.avatar_url, width: 24.0, borderRadius: BorderRadius.circular(12), ), title: Text( widget.repo.owner.login, textScaleFactor: .9, ), subtitle: subtitle, trailing: Text(widget.repo.language ?? \"\"), ), // 构建项目标题和简介 Padding( padding: const EdgeInsets.symmetric(horizontal: 16.0), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Text( widget.repo.fork ? widget.repo.full_name : widget.repo.name, style: TextStyle( fontSize: 15, fontWeight: FontWeight.bold, fontStyle: widget.repo.fork ? FontStyle.italic : FontStyle.normal, ), ), Padding( padding: const EdgeInsets.only(top: 8, bottom: 12), child: widget.repo.description == null ? Text( GmLocalizations.of(context).noDescription, style: TextStyle( fontStyle: FontStyle.italic, color: Colors.grey[700]), ) : Text( widget.repo.description, maxLines: 3, style: TextStyle( height: 1.15, color: Colors.blueGrey[700], fontSize: 13, ), ), ), ], ), ), // 构建卡片底部信息 _buildBottom() ], ), ), ), ); } // 构建卡片底部信息 Widget _buildBottom() { const paddingWidth = 10; return IconTheme( data: IconThemeData( color: Colors.grey, size: 15, ), child: DefaultTextStyle( style: TextStyle(color: Colors.grey, fontSize: 12), child: Padding( padding: const EdgeInsets.symmetric(horizontal: 16), child: Builder(builder: (context) { var children = [ Icon(Icons.star), Text(\" \" + widget.repo.stargazers_count .toString() .padRight(paddingWidth)), Icon(Icons.info_outline), Text(\" \" + widget.repo.open_issues_count .toString() .padRight(paddingWidth)), Icon(MyIcons.fork), //我们的自定义图标 Text(widget.repo.forks_count.toString().padRight(paddingWidth)), ]; if (widget.repo.fork) { children.add(Text(\"Forked\".padRight(paddingWidth))); } if (widget.repo.private == true) { children.addAll([ Icon(Icons.lock), Text(\" private\".padRight(paddingWidth)) ]); } return Row(children: children); }), ), ), ); } } 上面代码有两点需要注意： 在构建项目拥有者头像时调用了gmAvatar(…)方法，该方法是是一个全局工具函数，专门用于获取头像图片，实现如下： Widget gmAvatar(String url, { double width = 30, double height, BoxFit fit, BorderRadius borderRadius, }) { var placeholder = Image.asset( \"imgs/avatar-default.png\", //头像占位图，加载过程中显示 width: width, height: height ); return ClipRRect( borderRadius: borderRadius ?? BorderRadius.circular(2), child: CachedNetworkImage( imageUrl: url, width: width, height: height, fit: fit, placeholder: (context, url) =>placeholder, errorWidget: (context, url, error) =>placeholder, ), ); } 代码中调用了CachedNetworkImage 是cached_network_image包中提供的一个Widget，它不仅可以在图片加载过程中指定一个占位图，而且还可以对网络请求的图片进行缓存，更多详情读者可以自行查阅其文档。 由于Flutter 的Material 图标库中没有fork图标，所以我们在iconfont.cn上找了一个fork图标，然后根据”图片和Icon“一节中介绍的使用自定义字体图标的方法集成到了我们的项目中。 15.6.3 抽屉菜单 抽屉菜单分为两部分：顶部头像和底部功能菜单项。当用户未登录，则抽屉菜单顶部会显示一个默认的灰色占位图，若用户已登录，则会显示用户的头像。抽屉菜单底部有”换肤“和”语言“两个固定菜单，若用户已登录，则会多一个”注销“菜单。用户点击”换肤“和”语言“两个菜单项，会进入相应的设置页面。我们的抽屉菜单效果如图15-3、15-4所示： 实现代码如下： class MyDrawer extends StatelessWidget { const MyDrawer({ Key key, }) : super(key: key); @override Widget build(BuildContext context) { return Drawer( //移除顶部padding child: MediaQuery.removePadding( context: context, removeTop: true, child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ _buildHeader(), //构建抽屉菜单头部 Expanded(child: _buildMenus()), //构建功能菜单 ], ), ), ); } Widget _buildHeader() { return Consumer( builder: (BuildContext context, UserModel value, Widget child) { return GestureDetector( child: Container( color: Theme.of(context).primaryColor, padding: EdgeInsets.only(top: 40, bottom: 20), child: Row( children: [ Padding( padding: const EdgeInsets.symmetric(horizontal: 16.0), child: ClipOval( // 如果已登录，则显示用户头像；若未登录，则显示默认头像 child: value.isLogin ? gmAvatar(value.user.avatar_url, width: 80) : Image.asset( \"imgs/avatar-default.png\", width: 80, ), ), ), Text( value.isLogin ? value.user.login : GmLocalizations.of(context).login, style: TextStyle( fontWeight: FontWeight.bold, color: Colors.white, ), ) ], ), ), onTap: () { if (!value.isLogin) Navigator.of(context).pushNamed(\"login\"); }, ); }, ); } // 构建菜单项 Widget _buildMenus() { return Consumer( builder: (BuildContext context, UserModel userModel, Widget child) { var gm = GmLocalizations.of(context); return ListView( children: [ ListTile( leading: const Icon(Icons.color_lens), title: Text(gm.theme), onTap: () => Navigator.pushNamed(context, \"themes\"), ), ListTile( leading: const Icon(Icons.language), title: Text(gm.language), onTap: () => Navigator.pushNamed(context, \"language\"), ), if(userModel.isLogin) ListTile( leading: const Icon(Icons.power_settings_new), title: Text(gm.logout), onTap: () { showDialog( context: context, builder: (ctx) { //退出账号前先弹二次确认窗 return AlertDialog( content: Text(gm.logoutTip), actions: [ FlatButton( child: Text(gm.cancel), onPressed: () => Navigator.pop(context), ), FlatButton( child: Text(gm.yes), onPressed: () { //该赋值语句会触发MaterialApp rebuild userModel.user = null; Navigator.pop(context); }, ), ], ); }, ); }, ), ], ); }, ); } } 用户点击”注销“，userModel.user 会被置空，此时所有依赖userModel的组件都会被rebuild，如主页会恢复成未登录的状态。 本小节我们介绍了APP入口MaterialApp的一些配置，然后实现了APP的首页。后面我们将展示登录页、换肤页、语言切换页。 "},"chapter15/login_page.html":{"url":"chapter15/login_page.html","title":"15.7：登录页","keywords":"","body":"15.7 登录页 我们说过Github有多种登录方式，为了简单起见，我们只实现通过用户名和密码登录。在实现登录页时有四点需要注意： 可以自动填充上次登录的用户名（如果有）。 为了防止密码输入错误，密码框应该有开关可以看明文。 用户名或密码字段在调用登录接口前有本地合法性校验（比如不能为空）。 登录成功后需更新用户信息。 实现代码如下： import '../index.dart'; class LoginRoute extends StatefulWidget { @override _LoginRouteState createState() => _LoginRouteState(); } class _LoginRouteState extends State { TextEditingController _unameController = new TextEditingController(); TextEditingController _pwdController = new TextEditingController(); bool pwdShow = false; //密码是否显示明文 GlobalKey _formKey = new GlobalKey(); bool _nameAutoFocus = true; @override void initState() { // 自动填充上次登录的用户名，填充后将焦点定位到密码输入框 _unameController.text = Global.profile.lastLogin; if (_unameController.text != null) { _nameAutoFocus = false; } super.initState(); } @override Widget build(BuildContext context) { var gm = GmLocalizations.of(context); return Scaffold( appBar: AppBar(title: Text(gm.login)), body: Padding( padding: const EdgeInsets.all(16.0), child: Form( key: _formKey, autovalidate: true, child: Column( children: [ TextFormField( autofocus: _nameAutoFocus, controller: _unameController, decoration: InputDecoration( labelText: gm.userName, hintText: gm.userNameOrEmail, prefixIcon: Icon(Icons.person), ), // 校验用户名（不能为空） validator: (v) { return v.trim().isNotEmpty ? null : gm.userNameRequired; }), TextFormField( controller: _pwdController, autofocus: !_nameAutoFocus, decoration: InputDecoration( labelText: gm.password, hintText: gm.password, prefixIcon: Icon(Icons.lock), suffixIcon: IconButton( icon: Icon( pwdShow ? Icons.visibility_off : Icons.visibility), onPressed: () { setState(() { pwdShow = !pwdShow; }); }, )), obscureText: !pwdShow, //校验密码（不能为空） validator: (v) { return v.trim().isNotEmpty ? null : gm.passwordRequired; }, ), Padding( padding: const EdgeInsets.only(top: 25), child: ConstrainedBox( constraints: BoxConstraints.expand(height: 55.0), child: RaisedButton( color: Theme.of(context).primaryColor, onPressed: _onLogin, textColor: Colors.white, child: Text(gm.login), ), ), ), ], ), ), ), ); } void _onLogin() async { // 提交前，先验证各个表单字段是否合法 if ((_formKey.currentState as FormState).validate()) { showLoading(context); User user; try { user = await Git(context).login(_unameController.text, _pwdController.text); // 因为登录页返回后，首页会build，所以我们传false，更新user后不触发更新 Provider.of(context, listen: false).user = user; } catch (e) { //登录失败则提示 if (e.response?.statusCode == 401) { showToast(GmLocalizations.of(context).userNameOrPasswordWrong); } else { showToast(e.toString()); } } finally { // 隐藏loading框 Navigator.of(context).pop(); } if (user != null) { // 返回 Navigator.of(context).pop(); } } } } 代码很简单，关键地方都有注释，不再赘述，下面我们看一下运行效果，如图15-5所示。 "},"chapter15/language_and_theme_setting.html":{"url":"chapter15/language_and_theme_setting.html","title":"15.8：多语言和多主题","keywords":"","body":"15.8 多语言和多主题 本实例APP中语言和主题都是可以设置的，而两者都是通过ChangeNotifierProvider来实现的：我们在main函数中使用了Consumer2，依赖了ThemeModel和LocaleModel，因此，当我们在语言和主题设置页更该当前的配置后，Consumer2的builder都会重新执行，构建一个新的MaterialApp，所以修改会立即生效。下面看一下语言和主题设置页的实现。 15.8.1 语言选择页 APP语言选择页提供三个选项：中文简体、美国英语、跟随系统。我们将当前APP使用的语言高亮显示，并且在后面添加一个”对号“图标，实现如下： class LanguageRoute extends StatelessWidget { @override Widget build(BuildContext context) { var color = Theme.of(context).primaryColor; var localeModel = Provider.of(context); var gm = GmLocalizations.of(context); //构建语言选择项 Widget _buildLanguageItem(String lan, value) { return ListTile( title: Text( lan, // 对APP当前语言进行高亮显示 style: TextStyle(color: localeModel.locale == value ? color : null), ), trailing: localeModel.locale == value ? Icon(Icons.done, color: color) : null, onTap: () { // 更新locale后MaterialApp会重新build localeModel.locale = value; }, ); } return Scaffold( appBar: AppBar( title: Text(gm.language), ), body: ListView( children: [ _buildLanguageItem(\"中文简体\", \"zh_CN\"), _buildLanguageItem(\"English\", \"en_US\"), _buildLanguageItem(gm.auto, null), ], ), ); } } 上面代码逻辑很简单，唯一需要注意的是我们在build(…)方法里面定义了_buildLanguageItem(…)方法，它和在LanguageRoute类中定义该方法的区别就在于：在build(…)内定义的方法可以共享build(...)方法上下文中的变量，本例中是共享了localeModel。当然，如果_buildLanguageItem(…)的实现复杂一些的话不建议这样做，此时最好是将其作为LanguageRoute类的方法。该页面运行效果如图15-6、15-7所示： 切换语言后立即生效。 15.8.2 主题选择页 一个完整的主题Theme包括很多选项，这些选项在ThemeData中定义。本实例为了简单起见，我们只配置主题颜色。我们提供几种默认预定义的主题色供用户选择，用户点击一种色块后则更新主题。主题选择页的实现代码如下： class ThemeChangeRoute extends StatelessWidget{ @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(GmLocalizations.of(context).theme), ), body: ListView( //显示主题色块 children: Global.themes.map((e) { return GestureDetector( child: Padding( padding: const EdgeInsets.symmetric(vertical: 5, horizontal: 16), child: Container( color: e, height: 40, ), ), onTap: () { //主题更新后，MaterialApp会重新build Provider.of(context).theme = e; }, ); }).toList(), ), ); } } 运行效果如图15-8所示： 点击其它主题色块后，APP主题色立马切换生效。 "}}